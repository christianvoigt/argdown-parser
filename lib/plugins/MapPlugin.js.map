{"version":3,"sources":["../../src/plugins/MapPlugin.ts"],"names":["StatementSelectionMode","LabelMode","GroupMode","defaultSettings","statementSelectionMode","WITH_TITLE","argumentLabelMode","HIDE_UNTITLED","statementLabelMode","excludeDisconnected","selectElementsWithoutSection","selectElementsWithoutTag","groupMode","HEADING","groupDepth","addTags","MapPlugin","config","request","r","map","response","statements","ArgdownPluginError","name","arguments","relations","_","defaultsDeep","getSettings","defaults","mapResponse","makeMap","settings","selectedStatements","Object","keys","title","filter","isPreselected","selectedStatementsMap","curr","allArguments","selectedArguments","selectedArgumentsMap","isStatementSelected","isArgumentSelected","nodeCount","statementNodes","createStatementNode","statementNodesMap","length","argumentNodes","createArgumentNode","argumentNodesMap","nodes","createMapNodeTree","concat","selectedRelations","isRelationSelected","edges","reduce","createEdgesFromRelation","push","createSupportEdgesFromEquivalences","el","sectionSelected","selectedSections","section","indexOf","tagSelected","selectedTags","tags","find","t","untitledPattern","equivalenceClass","withRelations","undefined","otherRelationMemberIsInSelection","usedInArgument","members","isUsedInSelectedArgument","inSelection","ALL","exec","TOP_LEVEL","isUsedAsTopLevelStatement","WITH_RELATIONS","NOT_USED_IN_ARGUMENT","WITH_MORE_THAN_ONE_RELATION","nrOfRelationPartners","acc","countOtherRelationMembersInSelection","statement","role","StatementRole","PRELIMINARY_CONCLUSION","get","argumentTitle","isArgumentStatementConnectedByEquivalence","s","MAIN_CONCLUSION","PREMISE","requiredRole","ec","argument","hasConnections","pcs","inference","currentCount","relation","relationMember","other","from","to","type","ArgdownTypes","EQUIVALENCE_CLASS","ARGUMENT","INFERENCE","relationMemberIsInSelection","isConnectedByEquivalence","a","ec1","s1","isUsedAsPremise","s2","initialNodeCount","index","node","STATEMENT_MAP_NODE","id","Number","TEXT","isEmpty","labelText","TITLE","startsWith","labelTitle","sortedTags","ARGUMENT_MAP_NODE","rel","froms","tos","statementNode","argumentNode","edge1","MAP_EDGE","relationType","fromEquivalenceClass","toEquivalenceClass","RelationType","CONTRADICTORY","ATTACK","edge2","CONTRARY","ENTAILS","SUPPORT","initialEdgeCount","conclusion","argumentNode2","groupMap","createGroups","values","createAncestorGroups","groups","maxGroupLevel","level","minGroupLevel","nodesWithSection","normalizeGroupLevels","nodesWithoutSection","findSection","n","Map","group","GROUP_MAP_NODE","children","set","parent","currentGroup","parentGroup","parentSection"],"mappings":"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","sourcesContent":["import * as _ from \"lodash\";\nimport { IArgdownPlugin, IRequestHandler } from \"../IArgdownPlugin\";\nimport { IArgdownRequest } from \"../IArgdownRequest\";\nimport { IArgdownResponse } from \"../IArgdownResponse\";\nimport { ArgdownPluginError } from \"../ArgdownPluginError\";\nimport { reduceToMap } from \"../utils\";\nimport {\n  IMap,\n  MapNodeType,\n  IMapNode,\n  IEquivalenceClass,\n  IArgument,\n  StatementRole,\n  RelationMember,\n  ArgdownTypes,\n  IRelation,\n  IMapEdge,\n  IArgumentStatement,\n  RelationType,\n  IConclusion,\n  IStatement,\n  IGroupMapNode,\n  ISection,\n  IInference\n} from \"../model/model\";\nimport {\n  isConclusion,\n  getCanonicalMemberText,\n  getCanonicalDescriptionText,\n  isArgumentStatement\n} from \"../model/model-utils\";\nimport { TLSSocket } from \"tls\";\nimport { echo } from \"shelljs\";\nimport { toJSON } from \"../model/toJSON\";\n\n/**\n * The StatementSelectionMode in the [[IMapSettings]] determines which statements will be added as nodes to the argument map.\n */\nexport enum StatementSelectionMode {\n  /**\n   * Every statement will be added as node to the argument map.\n   */\n  ALL = \"all\",\n  /**\n   * Only statements with the StatementRole.TOP_LEVEL_STATEMENT or statements with otherwise not represented relations will be added to the argument map.\n   */\n  TOP_LEVEL = \"top-level\",\n  /**\n   * Only statements with with manually defined titles  or statements with otherwise not represented relations will be added to the argument map.\n   */\n  WITH_TITLE = \"with-title\",\n  /**\n   * Only statements with at least one relation to another node in the map will be added to the argument map.\n   */\n  WITH_RELATIONS = \"with-relations\",\n  /**\n   * Only statements not used in any argument's premise-conclusion-structure will be added to the argument map.\n   */\n  NOT_USED_IN_ARGUMENT = \"not-used-in-argument\",\n  /**\n   * Only statements that are in relations with more than one other node in the map or statements with otherwise not represented relations will be added to the argument map.\n   */\n  WITH_MORE_THAN_ONE_RELATION = \"with-more-than-one-relation\"\n}\nexport enum LabelMode {\n  HIDE_UNTITLED = \"hide-untitled\",\n  TITLE = \"title\",\n  TEXT = \"text\"\n}\nexport enum GroupMode {\n  HEADING = \"heading\",\n  TAG = \"tag\",\n  NONE = \"none\"\n}\n/**\n * The settings for the [[MapPlugin]].\n */\nexport interface IMapSettings {\n/**\n * The StatementSelectionMode determines which statements are added as nodes to the argument map.\n */\nstatementSelectionMode?: StatementSelectionMode;\n  /**\n   * Can be used to only select arguments and statements with certain tags\n   */\n  selectedTags?: string[];\n  /**\n   * Should arguments and statements without tags be excluded from the selection?\n   * This is only relevant, if [[IMapSettings.selectedTags]] is used.\n   */\n  selectElementsWithoutTag?: boolean;\n  /**\n   * \n   * A list of headings that can be used to only selected arguments and statements from certain sections in the texts.\n   */\n  selectedSections?: string[];\n  /**\n   * Should arguments and statements that are defined under no heading be excluded from the selection?\n   * This is only relevant if [[IMapSettings.selectedSections]] is used.\n   */\n  selectElementsWithoutSection?: boolean;\n  argumentLabelMode?: LabelMode;\n  statementLabelMode?: LabelMode;\n  /**\n   * Should statements and arguments be excluded from the map if they have \n   * no relations to other selected arguments or statements?\n   */\n  excludeDisconnected?: boolean;\n  groupMode?: GroupMode;\n  groupDepth?: number;\n  /**\n   * Should tags be added to the node labels?\n   */\n  addTags?: boolean;\n}\nexport interface IMapRequest extends IArgdownRequest {\n  map?: IMapSettings;\n}\nexport interface IMapResponse extends IArgdownResponse {\n  map?: IMap;\n}\nconst defaultSettings: IMapSettings = {\n  statementSelectionMode: StatementSelectionMode.WITH_TITLE,\n  argumentLabelMode: LabelMode.HIDE_UNTITLED,\n  statementLabelMode: LabelMode.HIDE_UNTITLED,\n  excludeDisconnected: true,\n  selectElementsWithoutSection: true,\n  selectElementsWithoutTag: true,\n  groupMode: GroupMode.HEADING,\n  groupDepth: 2,\n  addTags: true\n};\nexport class MapPlugin implements IArgdownPlugin {\n  name = \"MapPlugin\";\n  defaults: IMapSettings;\n  constructor(config?: IMapSettings) {\n    this.defaults = _.defaultsDeep({}, config, defaultSettings);\n  }\n  getSettings = (request: IArgdownRequest): IMapSettings => {\n    const r = <IMapRequest>request;\n    if (r.map) {\n      return r.map;\n    } else {\n      r.map = {};\n      return r.map;\n    }\n  };\n  prepare: IRequestHandler = (request, response) => {\n    if (!response.statements) {\n      throw new ArgdownPluginError(this.name, \"No statements field in response.\");\n    }\n    if (!response.arguments) {\n      throw new ArgdownPluginError(this.name, \"No arguments field in response.\");\n    }\n    if (!response.relations) {\n      throw new ArgdownPluginError(this.name, \"No relations field in response.\");\n    }\n    _.defaultsDeep(this.getSettings(request), this.defaults);\n  };\n  run: IRequestHandler = (request, response) => {\n    const mapResponse = <IMapResponse>response;\n    mapResponse.map = this.makeMap(request, response);\n    return mapResponse;\n  };\n  makeMap(request: IMapRequest, response: IMapResponse): IMap {\n    const settings = this.getSettings(request);\n    // 1) Preselection round: Select elements by intrinsic criteria\n    // 1.1) Preselect statements by tag and section\n    let selectedStatements = Object.keys(response.statements!)\n      .map<IEquivalenceClass>(title => response.statements![title])\n      .filter(isPreselected(settings));\n    let selectedStatementsMap = reduceToMap(selectedStatements, curr => curr.title!);\n\n    // 1.2) Preselect arguments by tag and section\n    const allArguments = Object.keys(response.arguments!).map<IArgument>(title => response.arguments![title]);\n    // const selectedArguments = allArguments.filter(isArgumentSelected(settings, response));\n    let selectedArguments = allArguments.filter(isPreselected(settings));\n    let selectedArgumentsMap = reduceToMap(selectedArguments, curr => curr.title!);\n\n    // 2) Selection round: Select elements by extrinsic criteria, taking intrinsic preselection into account\n    // 2.1) Select statements from preselection based on statementSelectionMode, taking preselection into account\n    selectedStatements = selectedStatements.filter(\n      isStatementSelected(settings, selectedStatementsMap, selectedArgumentsMap)\n    );\n    selectedStatementsMap = reduceToMap(selectedStatements, curr => curr.title!);\n\n    // 2.2) Select arguments from preselection, taking argument preselection and statement selection into account\n    selectedArguments = selectedArguments.filter(\n      isArgumentSelected(settings, response, selectedStatementsMap, selectedArgumentsMap)\n    );\n    selectedArgumentsMap = reduceToMap(selectedArguments, curr => curr.title!);\n\n    // 3) Create nodes\n    // 3.1) Create statement nodes\n    let nodeCount = 0;\n    const statementNodes = selectedStatements.map<IMapNode>(createStatementNode(settings, response, nodeCount));\n    const statementNodesMap = reduceToMap<string, IMapNode>(statementNodes, curr => curr.title!);\n    nodeCount += statementNodes.length;\n    // 3.2) Create argument nodes\n    const argumentNodes = selectedArguments.map<IMapNode>(createArgumentNode(settings, response, nodeCount));\n    const argumentNodesMap = reduceToMap<string, IMapNode>(argumentNodes, curr => curr.title!);\n    nodeCount += argumentNodes.length;\n    // 3.3) Create group nodes and node tree structure\n    const nodes = createMapNodeTree(settings, response, statementNodes.concat(argumentNodes));\n\n    // 4) Select relations\n    const selectedRelations = response.relations!.filter(\n      isRelationSelected(response, settings, selectedStatementsMap, selectedArgumentsMap)\n    );\n    // 5) Create edges\n    // 5.1) Create edges from relations\n    const edges = selectedRelations.reduce<IMapEdge[]>(\n      createEdgesFromRelation(statementNodesMap, argumentNodesMap),\n      []\n    );\n    // 5.2) Create edges from equivalences\n    edges.push(\n      ...createSupportEdgesFromEquivalences(\n        response,\n        edges.length,\n        statementNodes,\n        statementNodesMap,\n        argumentNodes,\n        argumentNodesMap\n      )\n    );\n    return <IMap>{\n      nodes,\n      edges\n    };\n  }\n}\nconst isPreselected = (settings: IMapSettings) => (el: IEquivalenceClass | IArgument) => {\n  const sectionSelected = !settings.selectedSections || (!el.section && settings.selectElementsWithoutSection) || (el.section && settings.selectedSections.indexOf(el.section!.title!) > -1);\n  const tagSelected =\n    !settings.selectedTags ||\n    (!el.tags && settings.selectElementsWithoutTag) ||\n    (el.tags && el.tags.find(t => settings.selectedTags!.indexOf(t) > -1));\n  return sectionSelected && tagSelected;\n};\nconst untitledPattern = /^Untitled/;\nconst isStatementSelected = (\n  settings: IMapSettings,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n) => (equivalenceClass: IEquivalenceClass) => {\n  const withRelations =\n    equivalenceClass.relations!.length > 0 &&\n    undefined !==\n      equivalenceClass.relations!.find(r =>\n        otherRelationMemberIsInSelection(r, equivalenceClass, selectedStatements, selectedArguments)\n      );\n  const usedInArgument = equivalenceClass.members.find(isUsedInSelectedArgument(selectedArguments));\n  let inSelection = false;\n  switch (settings.statementSelectionMode) {\n    case StatementSelectionMode.ALL:\n      inSelection = true;\n    case StatementSelectionMode.WITH_TITLE:\n      inSelection = (!usedInArgument && withRelations) || !untitledPattern.exec(equivalenceClass.title!);\n      break;\n    case StatementSelectionMode.TOP_LEVEL:\n      inSelection = (!usedInArgument && withRelations) || !!equivalenceClass.isUsedAsTopLevelStatement;\n      break;\n    case StatementSelectionMode.WITH_RELATIONS:\n      inSelection = withRelations;\n      break;\n    case StatementSelectionMode.NOT_USED_IN_ARGUMENT:\n      inSelection = !usedInArgument;\n      break;\n    case StatementSelectionMode.WITH_MORE_THAN_ONE_RELATION:\n      const nrOfRelationPartners = equivalenceClass.relations!.reduce((acc, r) => {\n        return countOtherRelationMembersInSelection(acc, r, equivalenceClass, selectedStatements, selectedArguments);\n      }, 0);\n      inSelection = withRelations && (!usedInArgument ||Â nrOfRelationPartners > 1);\n      break;\n  }\n  return (!settings.excludeDisconnected || (usedInArgument || withRelations)) && inSelection;\n};\nconst isUsedInSelectedArgument = (selectedArguments: Map<string, IArgument>) => (statement: IStatement) => {\n  if (isArgumentStatement(statement) && statement.role !== StatementRole.PRELIMINARY_CONCLUSION) {\n    return selectedArguments.get(statement.argumentTitle!) !== undefined;\n  }\n  return false;\n};\nconst isArgumentStatementConnectedByEquivalence = (\n  response: IMapResponse,\n  s: IStatement,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n): boolean => {\n  if (s.role === StatementRole.MAIN_CONCLUSION || s.role === StatementRole.PREMISE) {\n    let requiredRole = StatementRole.MAIN_CONCLUSION;\n    if (s.role === StatementRole.MAIN_CONCLUSION) {\n      requiredRole = StatementRole.PREMISE;\n    }\n    if (selectedStatements.get(s.title!) !== undefined) {\n      return true;\n    }\n    const ec = response.statements![s.title!];\n    return (\n      undefined !==\n      ec.members.find(\n        s => s.role === requiredRole && selectedArguments.get((<IArgumentStatement>s).argumentTitle!) !== undefined\n      )\n    );\n  }\n  return false;\n};\n/**\n * Selects arguments if\n *  - either settings.excludeDisconnected is false\n *  - or one of the following conditions applies:\n *    - argument.relations is not empty\n *    - a premise is supported/attacked by another argument or selected statement\n *    - the main conclusion is supporting/attacking another argument or selected statement\n *    - an inference is undercut by an argument or a selected statement\n *    - implicit support: a premise is equivalent with a main conclusion of another argument or a selected statement\n *    - implicit support: the main conclusion is equivalent with a premise of another argument or a selected statement\n */\nconst isArgumentSelected = (\n  settings: IMapSettings,\n  response: IMapResponse,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n) => (argument: IArgument) => {\n  if (!settings.excludeDisconnected) {\n    return true;\n  }\n  let hasConnections = false;\n  if (argument.relations && argument.relations.length > 0) {\n    hasConnections =\n      undefined !==\n      argument.relations.find(r =>\n        otherRelationMemberIsInSelection(r, argument, selectedStatements, selectedArguments)\n      );\n  }\n  if (hasConnections) {\n    return true;\n  }\n  if (argument.pcs && argument.pcs.length > 0) {\n    hasConnections =\n      undefined !==\n      argument.pcs.find(s => {\n        let hasConnections = false;\n        if (isConclusion(s) && (<IConclusion>s).inference!.relations!.length > 0) {\n          const inference = (<IConclusion>s).inference!;\n          hasConnections =\n            undefined !==\n            inference.relations!.find(r =>\n              otherRelationMemberIsInSelection(r, inference, selectedStatements, selectedArguments)\n            );\n        }\n        if (hasConnections) {\n          return true;\n        }\n        const equivalenceClass = response.statements![s.title!];\n        if (equivalenceClass.relations) {\n          hasConnections =\n            undefined !==\n            equivalenceClass.relations.find(r =>\n              otherRelationMemberIsInSelection(r, equivalenceClass, selectedStatements, selectedArguments)\n            );\n          if (hasConnections) {\n            return true;\n          }\n        }\n        if (hasConnections) {\n          return true;\n        }\n        return isArgumentStatementConnectedByEquivalence(response, s, selectedStatements, selectedArguments);\n      });\n  }\n  return hasConnections;\n};\nconst countOtherRelationMembersInSelection = (\n  currentCount: number,\n  relation: IRelation,\n  relationMember: RelationMember,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n): number => {\n  const other = relation.from === relationMember ? relation.to! : relation.from!;\n  if (other.type === ArgdownTypes.EQUIVALENCE_CLASS) {\n    if (selectedStatements.get(relationMember.title!) === undefined) {\n      return currentCount;\n    }\n    let role = StatementRole.MAIN_CONCLUSION;\n    if (relation.to === other) {\n      role = StatementRole.PREMISE;\n    }\n    return other.members!.reduce(\n      (acc, s) =>\n        s.role === role && selectedArguments.get((<IArgumentStatement>s).argumentTitle!) !== undefined\n          ? currentCount + 1\n          : currentCount,\n      currentCount\n    );\n  } else if (other.type === ArgdownTypes.ARGUMENT && selectedArguments.get(other.title!) !== undefined) {\n    return currentCount + 1;\n  } else if (other.type === ArgdownTypes.INFERENCE && selectedArguments.get(other.argumentTitle!) !== undefined) {\n    return currentCount + 1;\n  }\n  return currentCount;\n};\nconst otherRelationMemberIsInSelection = (\n  relation: IRelation,\n  relationMember: RelationMember,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n) => {\n  const other = relation.from === relationMember ? relation.to! : relation.from!;\n  return relationMemberIsInSelection(relation, other, selectedStatements, selectedArguments);\n};\nconst relationMemberIsInSelection = (\n  relation: IRelation,\n  relationMember: RelationMember,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n) => {\n  if (relationMember.type === ArgdownTypes.EQUIVALENCE_CLASS) {\n    if (selectedStatements.get(relationMember.title!)) {\n      return true;\n    }\n    let role = StatementRole.MAIN_CONCLUSION;\n    if (relation.to === relationMember) {\n      role = StatementRole.PREMISE;\n    }\n    return (\n      undefined !==\n      relationMember.members.find(\n        s => s.role === role && selectedArguments.get((<IArgumentStatement>s).argumentTitle!) !== undefined\n      )\n    );\n  } else if (relationMember.type === ArgdownTypes.ARGUMENT && selectedArguments.get(relationMember.title!)) {\n    return true;\n  } else if (relationMember.type === ArgdownTypes.INFERENCE && selectedArguments.get(relationMember.argumentTitle!)) {\n    return true;\n  }\n  return false;\n};\nconst isRelationSelected = (\n  response: IMapResponse,\n  settings: IMapSettings,\n  selectedStatements: Map<string, IEquivalenceClass>,\n  selectedArguments: Map<string, IArgument>\n) => (relation: IRelation): boolean => {\n  return (\n    relationMemberIsInSelection(relation, relation.from!, selectedStatements, selectedArguments) &&\n    relationMemberIsInSelection(relation, relation.to!, selectedStatements, selectedArguments)\n  );\n};\nconst isConnectedByEquivalence = (response: IMapResponse) => (a: IArgument) => {\n  // a) For all premises: find out if there is an equivalent conclusion\n  // b) For the main conclusion: find out if there is an equivalent premise\n  if (a.pcs) {\n    return (\n      undefined !==\n      a.pcs.find(s1 => {\n        const ec1 = response.statements![s1.title!];\n        if (s1.role === StatementRole.MAIN_CONCLUSION && ec1.isUsedAsPremise) {\n          // b)\n          return true;\n        }\n        if (s1.role === StatementRole.PRELIMINARY_CONCLUSION) {\n          return false;\n        }\n        // a) s1 is premise. find equivalent main conclusions\n        return (\n          undefined !==\n          ec1.members.find(s2 => {\n            if (s2.role === StatementRole.MAIN_CONCLUSION) {\n              return true;\n            }\n            return false;\n          })\n        );\n      })\n    );\n  }\n  return false;\n};\nconst createStatementNode = (settings: IMapSettings, response: IMapResponse, initialNodeCount: number) => (\n  ec: IEquivalenceClass,\n  index: number\n) => {\n  const node: IMapNode = {\n    type: ArgdownTypes.STATEMENT_MAP_NODE,\n    title: ec.title,\n    id: \"n\" + Number(initialNodeCount + index)\n  };\n  if (settings.statementLabelMode !== LabelMode.TEXT || _.isEmpty(node.labelText)) {\n    if (settings.statementLabelMode === LabelMode.TITLE || !ec.title!.startsWith(\"Untitled\")) {\n      node.labelTitle = ec.title;\n    }\n  }\n  if (settings.statementLabelMode !== LabelMode.TITLE) {\n    node.labelText = getCanonicalMemberText(ec) || undefined;\n  }\n  if (settings.addTags && ec.sortedTags) {\n    node.tags = ec.sortedTags;\n  }\n  return node;\n};\nconst createArgumentNode = (settings: IMapSettings, response: IMapResponse, initialNodeCount: number) => (\n  a: IArgument,\n  index: number\n) => {\n  const node: IMapNode = {\n    title: a.title,\n    type: ArgdownTypes.ARGUMENT_MAP_NODE,\n    id: \"n\" + Number(initialNodeCount + index)\n  };\n  if (settings.argumentLabelMode != LabelMode.TITLE) {\n    node.labelText = getCanonicalDescriptionText(a) || undefined;\n  }\n  if (settings.argumentLabelMode !== LabelMode.TEXT || _.isEmpty(node.labelText)) {\n    if (!a.title!.startsWith(\"Untitled\") || settings.argumentLabelMode == LabelMode.TITLE) {\n      node.labelTitle = a.title;\n    }\n  }\n  if (settings.addTags && a.sortedTags) {\n    node.tags = a.sortedTags;\n  }\n  return node;\n};\nconst createEdgesFromRelation = (statementNodesMap: Map<string, IMapNode>, argumentNodesMap: Map<string, IMapNode>) => (\n  acc: IMapEdge[],\n  rel: IRelation\n): IMapEdge[] => {\n  const froms: IMapNode[] = [];\n  const tos: IMapNode[] = [];\n  if (rel.from!.type === ArgdownTypes.ARGUMENT) {\n    froms.push(argumentNodesMap.get(rel.from!.title!)!);\n  } else if (rel.from!.type === ArgdownTypes.EQUIVALENCE_CLASS) {\n    const statementNode = statementNodesMap.get(rel.from!.title!);\n    if (statementNode) {\n      froms.push(statementNode);\n    } else {\n      const ec = <IEquivalenceClass>rel.from!;\n      ec.members.reduce((acc, s) => {\n        if (s.role === StatementRole.MAIN_CONCLUSION) {\n          const node = argumentNodesMap.get((<IArgumentStatement>s).argumentTitle!);\n          if (node) {\n            acc.push(node);\n          }\n        }\n        return acc;\n      }, froms);\n    }\n  }\n  if (rel.to!.type === ArgdownTypes.ARGUMENT) {\n    tos.push(argumentNodesMap.get(rel.to!.title!)!);\n  } else if (rel.to!.type === ArgdownTypes.INFERENCE) {\n    const argumentNode = argumentNodesMap.get((<IInference>rel.to).argumentTitle!);\n    tos.push(argumentNode!);\n  } else if (rel.to!.type === ArgdownTypes.EQUIVALENCE_CLASS) {\n    const statementNode = statementNodesMap.get(rel.to!.title!);\n    if (statementNode) {\n      tos.push(statementNode);\n    } else {\n      const ec = <IEquivalenceClass>rel.to;\n      ec.members.reduce((acc, s) => {\n        if (s.role === StatementRole.PREMISE) {\n          const node = argumentNodesMap.get((<IArgumentStatement>s).argumentTitle!);\n          if (node) {\n            acc.push(node);\n          }\n        }\n        return acc;\n      }, tos);\n    }\n  }\n  for (let from of froms) {\n    for (let to of tos) {\n      const edge1: IMapEdge = {\n        type: ArgdownTypes.MAP_EDGE,\n        from: from,\n        to: to,\n        id: \"e\" + Number(acc.length + 1),\n        relationType: rel.relationType\n      };\n      acc.push(edge1);\n      if (rel.from!.type === ArgdownTypes.EQUIVALENCE_CLASS) {\n        edge1.fromEquivalenceClass = <IEquivalenceClass>rel.from;\n      }\n      if (rel.to!.type === ArgdownTypes.EQUIVALENCE_CLASS) {\n        edge1.toEquivalenceClass = <IEquivalenceClass>rel.to;\n      }\n      if (rel.relationType === RelationType.CONTRADICTORY) {\n        edge1.relationType = RelationType.ATTACK;\n        const edge2: IMapEdge = {\n          type: ArgdownTypes.MAP_EDGE,\n          from: to,\n          to: from,\n          id: \"e\" + Number(acc.length + 1),\n          relationType: RelationType.ATTACK,\n          fromEquivalenceClass: edge1.toEquivalenceClass,\n          toEquivalenceClass: edge1.fromEquivalenceClass\n        };\n        acc.push(edge2);\n      } else if (rel.relationType === RelationType.CONTRARY) {\n        edge1.relationType = RelationType.ATTACK;\n      } else if (rel.relationType === RelationType.ENTAILS) {\n        edge1.relationType = RelationType.SUPPORT;\n      }\n    }\n  }\n  return acc;\n};\n/**\n * Add implicit support edges derived from statement-statement equivalences:\n * 1. For all argument-nodes: Create support edges for conclusion-in-argument-node +> statement-node equivalences\n * 2. For all argument-nodes: Create support edges for conclusion-in-argument-node +> premise-in-argument-node\n * 3. For all statement-nodes: Create support edges for statement-node +> premise-in-argument-node equivalences\n **/\nconst createSupportEdgesFromEquivalences = (\n  response: IMapResponse,\n  initialEdgeCount: number,\n  statementNodes: IMapNode[],\n  statementNodesMap: Map<string, IMapNode>,\n  argumentNodes: IMapNode[],\n  argumentNodesMap: Map<string, IMapNode>\n): IMapEdge[] => {\n  const edges: IMapEdge[] = [];\n  for (let argumentNode of argumentNodes) {\n    const argument = response.arguments![argumentNode.title!];\n    if (argument.pcs.length == 0) {\n      continue;\n    }\n    const conclusion = argument.pcs[argument.pcs.length - 1];\n    const ec = response.statements![conclusion.title!];\n    const statementNode = statementNodesMap.get(conclusion.title!);\n    // 1)\n    if (statementNode) {\n      edges.push({\n        type: ArgdownTypes.MAP_EDGE,\n        relationType: RelationType.SUPPORT,\n        from: argumentNode,\n        to: statementNode,\n        fromEquivalenceClass: ec,\n        toEquivalenceClass: ec,\n        id: \"n\" + Number(initialEdgeCount + edges.length + 1)\n      });\n      continue;\n    }\n    // 2)\n    for (let statement of ec.members) {\n      if (statement.role === StatementRole.PREMISE) {\n        const argumentNode2 = argumentNodesMap.get((<IArgumentStatement>statement).argumentTitle!);\n        if (argumentNode2) {\n          edges.push({\n            type: ArgdownTypes.MAP_EDGE,\n            relationType: RelationType.SUPPORT,\n            from: argumentNode,\n            to: argumentNode2,\n            fromEquivalenceClass: ec,\n            toEquivalenceClass: ec,\n            id: \"n\" + Number(initialEdgeCount + edges.length + 1)\n          });\n        }\n      }\n    }\n  }\n  for (let statementNode of statementNodes) {\n    const ec = response.statements![statementNode.title!];\n    for (let statement of ec.members) {\n      if (statement.role === StatementRole.PREMISE) {\n        const argumentNode = argumentNodesMap.get((<IArgumentStatement>statement).argumentTitle!);\n        // 3)\n        if (argumentNode) {\n          edges.push({\n            type: ArgdownTypes.MAP_EDGE,\n            relationType: RelationType.SUPPORT,\n            from: statementNode,\n            to: argumentNode,\n            fromEquivalenceClass: ec,\n            toEquivalenceClass: ec,\n            id: \"e\" + Number(initialEdgeCount + edges.length + 1)\n          });\n        }\n      }\n    }\n  }\n  return edges;\n};\n/**\n * Creates group nodes and returns a tree structure containing all group, statement and argument nodes of the map.\n */\nconst createMapNodeTree = (settings: IMapSettings, response: IMapResponse, nodes: IMapNode[]): IMapNode[] => {\n  if (settings.groupMode && settings.groupMode === \"none\") {\n    return [...nodes];\n  }\n  const groupMap = createGroups(response, nodes);\n  [...groupMap.values()].reduce(createAncestorGroups, groupMap);\n  const groups = [...groupMap.values()];\n  //normalize group levels\n  const maxGroupLevel = groups.reduce((acc, curr) => (curr.level! > acc ? curr.level! : acc), 0);\n  const minGroupLevel = maxGroupLevel - settings.groupDepth! + 1;\n  const nodesWithSection = normalizeGroupLevels(minGroupLevel, groups);\n  const nodesWithoutSection: IMapNode[] = nodes.filter(n => findSection(response, n) === undefined);\n  return [...nodesWithSection, ...nodesWithoutSection];\n};\nconst createGroups = (response: IMapResponse, nodes: IMapNode[]) => {\n  const groupMap = new Map<string, IGroupMapNode>();\n  for (let node of nodes) {\n    let section = findSection(response, node);\n    if (section !== undefined) {\n      let group: IGroupMapNode | undefined = groupMap.get(section.id);\n      if (!group) {\n        group = {\n          type: ArgdownTypes.GROUP_MAP_NODE,\n          id: section.id,\n          title: section.title,\n          labelTitle: section.title,\n          children: <IGroupMapNode[]>[],\n          level: section.level,\n          section: section\n        };\n        groupMap.set(section.id, group);\n        if (section.parent) {\n          group.parent = section.parent.id;\n        }\n      }\n      group.children!.push(node);\n    }\n  }\n  return groupMap;\n};\nconst findSection = (response: IMapResponse, node: IMapNode): ISection | undefined => {\n  let section = null;\n  if (node.type == ArgdownTypes.ARGUMENT_MAP_NODE) {\n    let argument = response.arguments![node.title!];\n    return argument.section;\n  } else {\n    let equivalenceClass = response.statements![node.title!];\n    return equivalenceClass.section;\n  }\n};\nconst normalizeGroupLevels = (minGroupLevel: number, groups: IGroupMapNode[]): IMapNode[] => {\n  const nodes: IMapNode[] = [];\n  for (let group of groups) {\n    group.level = group.level! - minGroupLevel;\n  }\n\n  for (let group of groups) {\n    if (group.level! < 0) {\n      for (let node of group.children!) {\n        if (node.type !== ArgdownTypes.GROUP_MAP_NODE || (<IGroupMapNode>node).level! >= 0) {\n          nodes.push(node);\n        }\n      }\n    } else if (!group.parent) {\n      nodes.push(group);\n    }\n  }\n  return nodes;\n};\n/**\n * Creates all ancestor groups of a group that are not already existing\n * @param acc A map of all groups so far\n * @param curr The group\n * @returns The original group map with the new groups added\n */\nconst createAncestorGroups = (\n  groupMap: Map<string, IGroupMapNode>,\n  group: IGroupMapNode\n): Map<string, IGroupMapNode> => {\n  let currentGroup = group;\n  while (currentGroup.parent) {\n    let parentGroup = groupMap.get(currentGroup.parent);\n    if (parentGroup) {\n      parentGroup.children!.push(currentGroup);\n      break;\n    }\n    const parentSection = currentGroup.section!.parent;\n    if (parentSection) {\n      parentGroup = {\n        type: ArgdownTypes.GROUP_MAP_NODE,\n        id: parentSection.id,\n        title: parentSection.title,\n        labelTitle: parentSection.title,\n        children: [currentGroup],\n        level: parentSection.level,\n        section: parentSection\n      };\n      if (parentSection.parent) {\n        parentGroup.parent = parentSection.parent.id;\n      }\n      groupMap.set(currentGroup.parent, parentGroup);\n      currentGroup = parentGroup;\n    }\n  }\n  return groupMap;\n};\n"],"file":"MapPlugin.js"}