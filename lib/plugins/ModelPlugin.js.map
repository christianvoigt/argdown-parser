{"version":3,"sources":["../../src/plugins/ModelPlugin.ts"],"names":["isModelRequest","r","model","undefined","defaultSettings","removeTagsFromText","ModelPlugin","config","request","response","logger","_","defaultsDeep","getSettings","defaults","ast","ArgdownPluginError","name","statements","arguments","relations","relation","from","to","fromIsReconstructedArgument","type","ArgdownTypes","ARGUMENT","toIsReconstructedArgument","argument","index","indexOf","splice","conclusionStatement","pcs","length","equivalenceClass","title","relationExists","existingRelation","occurrences","push","inference","last","relationType","RelationType","SUPPORT","ENTAILS","ATTACK","CONTRARY","$","statementReferencePattern","statementDefinitionPattern","statementMentionPattern","argumentReferencePattern","argumentDefinitionPattern","argumentMentionPattern","linkPattern","tagPattern","uniqueTitleCounter","getUniqueTitle","currentStatement","currentRelationParent","currentArgument","currentPCS","currentInference","rangesStack","relationParentsStack","currentRelation","currentHeading","currentSection","sectionCounter","getRelationMember","relationParent","target","STATEMENT","getEquivalenceClass","updateArgument","argumentsDict","descriptions","addTags","tags","object","union","onRelationExit","node","children","contentNode","content","statement","relationSource","CONTRADICTORY","tokenListeners","TokenNames","STATEMENT_DEFINITION","token","parentNode","match","exec","image","STATEMENT_REFERENCE","isReference","STATEMENT_MENTION","trailingWhitespace","previousText","text","newText","ranges","range","RangeType","start","stop","ARGUMENT_DEFINITION","startLine","endLine","startColumn","endColumn","role","StatementRole","ARGUMENT_DESCRIPTION","section","ARGUMENT_REFERENCE","ARGUMENT_MENTION","LINK","url","oldText","linkRange","TAG","tag","settings","tagRange","ruleListeners","RuleNames","ARGDOWN","sections","HEADING","headingStart","level","sectionId","newSection","SECTION","id","heading","metaData","parentSection","parent","TOP_LEVEL_STATEMENT","RELATION_STATEMENT","merge","members","isUsedAsTopLevelStatement","isUsedAsRelationStatement","PCS","childIndex","precedingSibling","argdownLexer","Emptyline","precedingSibling2","log","lastStatement","PRELIMINARY_CONCLUSION","MAIN_CONCLUSION","ec","isUsedAsMainConclusion","find","s","isUsedAsPreliminaryConclusion","ARGUMENT_STATEMENT","statementNode","PREMISE","argumentTitle","INFERENCE","conclusion","conclusionIndex","isUsedAsPremise","statementNr","inferenceRules","INFERENCE_RULES","child","FREESTYLE_TEXT","trim","description","ruleNode","INCOMING_SUPPORT","RELATION","INCOMING_ATTACK","OUTGOING_SUPPORT","OUTGOING_ATTACK","CONTRADICTION","OUTGOING_UNDERCUT","UNDERCUT","INCOMING_UNDERCUT","RELATIONS","pop","EscapedChar","substring","ITALIC","startPos","italicRange","italicEnd","BOLD","boldRange","boldEnd"],"mappings":"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","sourcesContent":["import * as _ from \"lodash\";\nimport { tokenMatcher, IToken } from \"chevrotain\";\nimport * as argdownLexer from \"./../lexer\";\nimport { IArgdownPlugin, IRequestHandler } from \"../IArgdownPlugin\";\nimport { IArgdownRequest } from \"../IArgdownRequest\";\nimport { IArgdownResponse } from \"../IArgdownResponse\";\nimport { IAstNodeHandler, IRuleNodeHandler, ITokenNodeHandler } from \"../ArgdownTreeWalker\";\nimport { ArgdownPluginError } from \"../ArgdownPluginError\";\nimport {\n  IEquivalenceClass,\n  ArgdownTypes,\n  IConclusion,\n  IArgument,\n  RelationType,\n  IStatement,\n  IInference,\n  IRange,\n  IRelation,\n  IRuleNode,\n  ISection,\n  RelationMember,\n  StatementRole,\n  ITokenNode,\n  IArgumentStatement,\n  RangeType\n} from \"../model/model\";\nimport { createEquivalenceClass, isReconstructed, isRuleNode, isTokenNode } from \"../model/model-utils\";\nimport { RuleNames } from \"../RuleNames\";\nimport { TokenNames } from \"../TokenNames\";\n\nexport interface IModelPluginSettings {\n  removeTagsFromText?: boolean;\n}\nexport interface IModelPluginRequest extends IArgdownRequest {\n  model?: IModelPluginSettings;\n}\nconst isModelRequest = (r: IArgdownRequest): r is IModelPluginRequest => {\n  return (<IModelPluginRequest>r).model !== undefined;\n};\nconst defaultSettings = {\n  removeTagsFromText: false\n};\n/**\n * The ModelPlugin builds the basic data model from the abstract syntax tree (AST) in the [[IArgdownResponse.ast]] response property that is provided by the [[ParserPlugin]].\n * This includes the following response object properties:\n *\n *  - [[IArgdownResponse.statements]]\n *  - [[IArgdownResponse.arguments]]\n *  - [[IArgdownResponse.relations]]\n *  - [[IArgdownResponse.sections]]\n *\n * Most of the other plugins depend on the data produced by this plugin. Whenever possible plugins should use the\n * data processed by this plugin instead of working with the AST nodes directly.\n *\n * depends on data from: [[ParserPlugin]]\n */\nexport class ModelPlugin implements IArgdownPlugin {\n  name: string = \"ModelPlugin\";\n  defaults: IModelPluginSettings = {};\n  ruleListeners: { [eventId: string]: IRuleNodeHandler };\n  tokenListeners: { [eventId: string]: ITokenNodeHandler };\n  getSettings = (request: IArgdownRequest) => {\n    const r = <IModelPluginRequest>request;\n    if (!r.model) {\n      r.model = {};\n    }\n    return r.model;\n  };\n  prepare: IRequestHandler = (request, response, logger) => {\n    _.defaultsDeep(this.getSettings(request), this.defaults);\n  };\n  run: IRequestHandler = (request, response, logger) => {\n    if (!response.ast) {\n      throw new ArgdownPluginError(this.name, \"No AST field in response.\");\n    }\n    if (!response.statements) {\n      throw new ArgdownPluginError(this.name, \"No statements field in response.\");\n    }\n    if (!response.arguments) {\n      throw new ArgdownPluginError(this.name, \"No arguments field in response.\");\n    }\n    if (!response.relations) {\n      throw new ArgdownPluginError(this.name, \"No relations field in response.\");\n    }\n    for (let relation of response.relations) {\n      if (!relation.from) {\n        throw new ArgdownPluginError(this.name, \"Relation without source.\");\n      }\n      if (!relation.to) {\n        throw new ArgdownPluginError(this.name, \"Relation without target.\");\n      }\n      const fromIsReconstructedArgument =\n        relation.from.type === ArgdownTypes.ARGUMENT && isReconstructed(relation.from);\n      const toIsReconstructedArgument = relation.to.type === ArgdownTypes.ARGUMENT && isReconstructed(relation.to);\n\n      // For reconstructed arguments: change outgoing argument relations\n      // to outgoing relations of the main conclusion, removing duplicates\n      if (fromIsReconstructedArgument) {\n        //change relation.from to point to the argument's conclusion\n        let argument = <IArgument>relation.from;\n\n        //remove from argument\n        let index = _.indexOf(argument.relations, relation);\n        argument.relations!.splice(index, 1);\n\n        let conclusionStatement = argument.pcs![argument.pcs!.length - 1];\n        let equivalenceClass = response.statements[conclusionStatement.title!];\n        //change to relation of main conclusion\n        relation.from = equivalenceClass;\n\n        //check if this relation already exists\n        let relationExists = false;\n        for (let existingRelation of equivalenceClass.relations!) {\n          if (relation.to == existingRelation.to && relation.type === existingRelation.type) {\n            relationExists = true;\n            existingRelation.occurrences.push(...relation.occurrences)\n            break;\n          }\n        }\n        if (!relationExists) {\n          equivalenceClass.relations!.push(relation);\n        } else {\n          //remove relation from target\n          let index = _.indexOf(relation.to.relations, relation);\n          relation.to.relations!.splice(index, 1);\n          //remove relation from relations\n          index = _.indexOf(response.relations, relation);\n          response.relations.splice(index, 1);\n        }\n      }\n      // For reconstructed arguments: change incoming undercut relations\n      // to incoming relations of last inference, removing duplicates\n      if (toIsReconstructedArgument) {\n        let argument = <IArgument>relation.to;\n        let inference = (<IConclusion>_.last(argument.pcs)!).inference!;\n        relation.to = inference;\n        // remove relation from argument\n        let index = _.indexOf(argument.relations, relation);\n        argument.relations!.splice(index, 1);\n\n        let relationExists = false;\n        for (let existingRelation of inference.relations!) {\n          if (relation.from == existingRelation.from && relation.type === existingRelation.type) {\n            relationExists = true;\n            existingRelation.occurrences.push(...relation.occurrences);\n            break;\n          }\n        }\n        if (!relationExists) {\n          inference.relations!.push(relation);\n        } else {\n          //remove relation from source\n          let index = _.indexOf(relation.from.relations, relation);\n          relation.from.relations!.splice(index, 1);\n          //remove relation from relations\n          index = _.indexOf(response.relations, relation);\n          response.relations.splice(index, 1);\n        }\n      }\n    }\n    //Change dialectical types of statement-to-statement relations to semantic types\n    //Doing this in a separate loop makes it easier to identify duplicates in the previous loop,\n    //even though it is less efficient.\n    for (let relation of response.relations) {\n      if (relation.from!.type === ArgdownTypes.ARGUMENT || relation.to!.type === ArgdownTypes.ARGUMENT) {\n        continue;\n      }\n      if (relation.relationType === RelationType.SUPPORT) {\n        relation.relationType = RelationType.ENTAILS;\n      } else if (relation.relationType === RelationType.ATTACK) {\n        relation.relationType = RelationType.CONTRARY;\n      }\n    }\n    return response;\n  };\n  constructor(config?: IModelPluginSettings) {\n    this.defaults = _.defaultsDeep({}, config, defaultSettings);\n    this.name = \"ModelPlugin\";\n    let $ = this;\n\n    const statementReferencePattern = /\\[(.+)\\]/;\n    const statementDefinitionPattern = /\\[(.+)\\]\\:/;\n    const statementMentionPattern = /\\@\\[(.+)\\](\\s?)/;\n    const argumentReferencePattern = /\\<(.+)\\>/;\n    const argumentDefinitionPattern = /\\<(.+)\\>\\:/;\n    const argumentMentionPattern = /\\@\\<(.+)\\>(\\s?)/;\n    // const statementReferenceByNumberPattern = /\\<(.+)\\>\\((.+)\\)/;\n    // const statementDefinitionByNumberPattern = /\\<(.+)\\>\\((.+)\\)\\:/;\n    // const statementMentionByNumberPattern = /\\@\\<(.+)\\>\\((.+)\\)/;\n    const linkPattern = /\\[(.+)\\]\\((.+)\\)/;\n    const tagPattern = /#(?:\\(([^\\)]+)\\)|([a-zA-z0-9-\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+))/;\n\n    let uniqueTitleCounter = 0;\n    function getUniqueTitle() {\n      uniqueTitleCounter++;\n      return \"Untitled \" + uniqueTitleCounter;\n    }\n\n    let currentStatement: IStatement | null = null;\n    let currentRelationParent: IArgument | IStatement | IInference | null = null;\n    let currentArgument: IArgument | null = null;\n    let currentPCS: IArgument | null = null;\n    let currentInference: IInference | null = null;\n    let rangesStack: IRange[] = [];\n    let relationParentsStack: RelationMember[] = [];\n    let currentRelation: IRelation | null = null;\n    let currentHeading: IRuleNode | null = null;\n    let currentSection: ISection | null = null;\n    let sectionCounter = 0;\n    const getRelationMember = (\n      response: IArgdownResponse,\n      relationParent: IStatement | IArgument | IInference\n    ): IArgument | IEquivalenceClass | IInference => {\n      let target = relationParent;\n      if (relationParent.type === ArgdownTypes.STATEMENT) {\n        if (!relationParent.title) relationParent.title = getUniqueTitle();\n        return getEquivalenceClass(response.statements!, relationParent.title);\n      } else {\n        return <IArgument | IInference>target;\n      }\n    };\n    const updateArgument = (argumentsDict: { [title: string]: IArgument }, title?: string): IArgument => {\n      if (title) {\n        currentArgument = argumentsDict[title];\n      }\n      if (!title || !currentArgument) {\n        currentArgument = {\n          type: ArgdownTypes.ARGUMENT,\n          title,\n          relations: [],\n          descriptions: [],\n          pcs: []\n        };\n        if (!title) {\n          currentArgument.title = getUniqueTitle();\n        } else {\n          currentArgument.title = title;\n        }\n        argumentsDict[currentArgument.title] = currentArgument;\n      }\n      currentRelationParent = currentArgument;\n      return currentArgument;\n    };\n    const addTags = (tags: string[], object: { tags?: string[] }): void => {\n      if (!object.tags) {\n        object.tags = [];\n      }\n      object.tags = _.union(object.tags, tags);\n    };\n    const onRelationExit: IRuleNodeHandler = (request, response, node, {}, {}, logger) => {\n      let relation = node.relation;\n      if (!node.children || node.children.length < 2) {\n        throw new ArgdownPluginError(this.name, \"Relation without children.\");\n      }\n      let contentNode = node.children[1] as IRuleNode;\n      let content = contentNode.argument || contentNode.statement;\n      if (!content) {\n        throw new ArgdownPluginError(this.name, \"Relation member not found.\");\n      }\n      let target = getRelationMember(response, content);\n      if (relation) {\n        if (relation.from) {\n          relation.to = target;\n        } else {\n          relation.from = target;\n        }\n        let relationExists = false;\n        const relationSource = relation.from;\n        for (let existingRelation of relationSource.relations!) {\n          if (relation.to === existingRelation.to && relation.type === existingRelation.type) {\n            relationExists = true;\n            existingRelation.occurrences.push(...relation.occurrences);\n            break;\n          } else if (\n            relation.relationType === RelationType.CONTRADICTORY &&\n            relation.relationType === existingRelation.relationType &&\n            relation.from === existingRelation.to &&\n            relation.to === existingRelation.from\n          ) {\n            relationExists = true;\n            existingRelation.occurrences.push(...relation.occurrences);\n            break;\n          }\n        }\n        if (!relationExists) {\n          if (!relation.from || !relation.to) {\n            throw new ArgdownPluginError(this.name, \"Missing relation source or target.\");\n          }\n          response.relations!.push(relation);\n          relation.from.relations!.push(relation);\n          relation.to!.relations!.push(relation);\n        }\n      }\n    };\n\n    this.tokenListeners = {\n      [TokenNames.STATEMENT_DEFINITION]: ({}, {}, token, parentNode) => {\n        let match = statementDefinitionPattern.exec(token.image);\n        if (match != null && currentStatement) {\n          currentStatement.title = match[1];\n          token.title = currentStatement.title;\n          parentNode!.statement = currentStatement;\n        }\n      },\n      [TokenNames.STATEMENT_REFERENCE]: (request, response, token, parentNode) => {\n        let match = statementReferencePattern.exec(token.image);\n        if (match != null && currentStatement) {\n          currentStatement.title = match[1];\n          currentStatement.isReference = true;\n          token.title = currentStatement.title;\n          parentNode!.statement = currentStatement;\n        }\n      },\n      [TokenNames.STATEMENT_MENTION]: ({}, {}, token) => {\n        let match = statementMentionPattern.exec(token.image);\n        if (match) {\n          token.title = match[1];\n          if (token.image[token.image.length - 1] == \" \") {\n            token.trailingWhitespace = \" \";\n          } else {\n            token.trailingWhitespace = \"\";\n          }\n          const target = currentHeading || currentStatement;\n          if (target) {\n            const previousText = target.text || \"\";\n            const newText = previousText + token.image;\n            target.text = newText;\n            if (!target.ranges) {\n              target.ranges = [];\n            }\n            let range: IRange = {\n              type: RangeType.STATEMENT_MENTION,\n              title: token.title,\n              start: previousText.length,\n              stop: newText.length - 1\n            };\n            target.ranges.push(range);\n          }\n        }\n      },\n      [TokenNames.ARGUMENT_DEFINITION]: ({}, response, token, parentNode) => {\n        let match = argumentDefinitionPattern.exec(token.image);\n        if (match != null) {\n          let title = match[1];\n          updateArgument(response.arguments!, title);\n          currentStatement = {\n            type: ArgdownTypes.STATEMENT,\n            text: \"\"\n          };\n          currentStatement.startLine = token.startLine;\n          currentStatement.endLine = token.endLine;\n          currentStatement.startColumn = token.startColumn;\n          currentStatement.endColumn = token.endColumn;\n          currentStatement.role = StatementRole.ARGUMENT_DESCRIPTION;\n          if (currentSection) {\n            currentStatement.section = currentSection;\n          }\n          currentArgument!.descriptions.push(currentStatement);\n          if(currentArgument!.section === undefined){\n            currentArgument!.section = currentStatement.section;\n          }\n          token.title = title;\n          parentNode!.argument = currentArgument!;\n        }\n      },\n      [TokenNames.ARGUMENT_REFERENCE]: (request, response, token, parentNode) => {\n        let match = argumentReferencePattern.exec(token.image);\n        if (match != null) {\n          let title = match[1];\n          updateArgument(response.arguments!, title);\n          token.title = title;\n          parentNode!.argument = currentArgument!;\n        }\n      },\n      [TokenNames.ARGUMENT_MENTION]: ({}, {}, token) => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        let match = argumentMentionPattern.exec(token.image);\n        if (match) {\n          token.title = match[1];\n          if (token.image[token.image.length - 1] == \" \") {\n            token.trailingWhitespace = \" \";\n          } else {\n            token.trailingWhitespace = \"\";\n          }\n          if (target) {\n            const previousText = target.text || \"\";\n            const newText = previousText + token.image;\n            target.text = newText;\n            if (!target.ranges) {\n              target.ranges = [];\n            }\n            let range: IRange = {\n              type: RangeType.ARGUMENT_MENTION,\n              title: token.title,\n              start: previousText.length,\n              stop: newText.length - 1\n            };\n            target.ranges.push(range);\n          }\n        }\n      },\n      [TokenNames.LINK]: ({}, {}, token, {}, {}, logger) => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        if (!target) {\n          return;\n        }\n        let match = linkPattern.exec(token.image);\n        if (!match || match.length < 3) {\n          throw new ArgdownPluginError(this.name, \"Could not match link.\");\n        }\n        token.url = match[2];\n        token.text = match[1];\n        const oldText = target.text || \"\";\n        const newText = oldText + token.text;\n        target.text = newText;\n        let linkRange = <IRange>{ type: \"link\", start: oldText.length, stop: newText.length - 1 };\n        linkRange.url = token.url;\n        if (!target.ranges) {\n          target.ranges = [];\n        }\n        target.ranges.push(linkRange);\n        if (token.image[token.image.length - 1] == \" \") {\n          target.text += \" \";\n          token.trailingWhitespace = \" \";\n        } else {\n          token.trailingWhitespace = \"\";\n        }\n      },\n      [TokenNames.TAG]: (request, response, token, {}, {}, logger) => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        if (!target) {\n          return;\n        }\n        let match = tagPattern.exec(token.image);\n        if (!match || match.length < 2) {\n          throw new ArgdownPluginError(this.name, \"Could not parse tag.\");\n        }\n        let tag = match[1] || match[2];\n        const settings = $.getSettings(request);\n        token.tag = tag;\n        if (!settings.removeTagsFromText) {\n          const oldText = target.text || \"\";\n          const newText = oldText + token.image;\n          let tagRange: IRange = { type: RangeType.TAG, start: oldText.length, stop: newText.length - 1 };\n          token.text = token.image;\n          target.text = newText;\n          tagRange.tag = token.tag;\n          if (!target.ranges) {\n            target.ranges = [];\n          }\n          target.ranges.push(tagRange);\n        }\n        target.tags = target.tags || [];\n        let tags = target.tags;\n        if (target.tags.indexOf(tag) == -1) {\n          tags.push(tag);\n        }\n        if (response.tags!.indexOf(tag) == -1) {\n          response.tags!.push(tag);\n        }\n      }\n    };\n    this.ruleListeners = {\n      [RuleNames.ARGDOWN + \"Entry\"]: ({}, response) => {\n        response.statements = {};\n        response.arguments = {};\n        response.sections = [];\n        response.relations = [];\n        response.tags = [];\n        uniqueTitleCounter = 0;\n        currentHeading = null;\n        currentSection = null;\n        currentRelationParent = null;\n        currentPCS = null;\n        currentInference = null;\n        currentArgument = null;\n        rangesStack = [];\n        relationParentsStack = [];\n        currentRelation = null;\n        sectionCounter = 0;\n      },\n      [RuleNames.HEADING + \"Entry\"]: ({}, {}, node) => {\n        currentHeading = node;\n        currentHeading.text = \"\";\n        currentHeading.ranges = [];\n      },\n      [RuleNames.HEADING + \"Exit\"]: ({}, response, node, {}, {}, logger) => {\n        if (!currentHeading) {\n          throw new ArgdownPluginError(this.name, \"Missing heading.\");\n        }\n        if (node.children) {\n          let headingStart = node.children[0] as ITokenNode;\n          currentHeading.level = headingStart.image.length - 1; //number of # - whitespace\n          sectionCounter++;\n          let sectionId = \"s\" + sectionCounter;\n          let newSection: ISection = {\n            type: ArgdownTypes.SECTION,\n            id: sectionId,\n            level: currentHeading.level,\n            title: currentHeading.text || \"\",\n            children: []\n          };\n          newSection.tags = currentHeading.tags;\n          newSection.ranges = currentHeading.ranges;\n          newSection.startLine = node.startLine;\n          newSection.startColumn = node.startColumn;\n          newSection.heading = currentHeading;\n          newSection.metaData = currentHeading.metaData;\n\n          if (newSection.level > 1 && currentSection) {\n            let parentSection = currentSection;\n            while (parentSection.parent && parentSection.level >= newSection.level) {\n              parentSection = parentSection.parent;\n            }\n            parentSection.children.push(newSection);\n            newSection.parent = parentSection;\n          } else {\n            response.sections!.push(newSection);\n          }\n          currentSection = newSection;\n          currentHeading.section = newSection;\n          currentHeading = null;\n        }\n      },\n      [RuleNames.STATEMENT + \"Entry\"]: ({}, {}, node, parentNode) => {\n        currentStatement = {\n          type: ArgdownTypes.STATEMENT\n        };\n        if (parentNode!.name === \"argdown\") {\n          currentStatement.role = StatementRole.TOP_LEVEL_STATEMENT;\n        } else if (currentRelation) {\n          currentStatement.role = StatementRole.RELATION_STATEMENT;\n        }\n        currentRelationParent = currentStatement;\n        node.statement = currentStatement;\n      },\n      [RuleNames.STATEMENT + \"Exit\"]: ({}, response, node) => {\n        let statement = node.statement;\n        if (!statement) {\n          return;\n        }\n        statement.startLine = node.startLine;\n        statement.startColumn = node.startColumn;\n        statement.endLine = node.endLine;\n        statement.endColumn = node.endColumn;\n        statement.metaData = node.metaData;\n        if (!statement.title || statement.title == \"\") {\n          statement.title = getUniqueTitle();\n        }\n        let equivalenceClass = getEquivalenceClass(response.statements!, statement.title);\n        node.equivalenceClass = equivalenceClass;\n        if (statement.tags) {\n          addTags(statement.tags, equivalenceClass);\n        }\n        if (statement.metaData) {\n          equivalenceClass.metaData = _.merge(equivalenceClass.metaData, statement.metaData);\n        }\n        if (currentSection) {\n          statement.section = currentSection;\n        }\n        equivalenceClass.members.push(statement);\n        if(equivalenceClass.section === undefined && !statement.isReference){\n          equivalenceClass.section = statement.section;\n        }\n        if (statement.role === StatementRole.TOP_LEVEL_STATEMENT) {\n          equivalenceClass.isUsedAsTopLevelStatement = true; //members are used outside of argument reconstructions (not as premise or conclusion)\n        } else if (statement.role === StatementRole.RELATION_STATEMENT) {\n          equivalenceClass.isUsedAsRelationStatement = true;\n        }\n        currentStatement = null;\n      },\n      [RuleNames.PCS + \"Entry\"]: (request, response, node, parentNode, childIndex, logger) => {\n        let argument = null;\n        if (childIndex !== null && childIndex > 0 && parentNode && parentNode.children) {\n          const precedingSibling = parentNode.children[childIndex - 1];\n          if (\n            isRuleNode(precedingSibling) &&\n            (precedingSibling.name === RuleNames.ARGUMENT_REFERENCE ||\n              precedingSibling.name === RuleNames.ARGUMENT_DEFINITION)\n          ) {\n            argument = precedingSibling.argument;\n          } else if (isTokenNode(precedingSibling) && tokenMatcher(precedingSibling, argdownLexer.Emptyline)) {\n            const precedingSibling2 = parentNode.children[childIndex - 2];\n            if (\n              isRuleNode(precedingSibling2) &&\n              (precedingSibling2.name === RuleNames.ARGUMENT_REFERENCE ||\n                precedingSibling2.name === RuleNames.ARGUMENT_DEFINITION)\n            ) {\n              argument = precedingSibling2.argument;\n            }\n          }\n        }\n        if (!argument) {\n          argument = updateArgument(response.arguments!);\n        }\n        if (currentSection) {\n          argument.section = currentSection;\n        }\n        //if there is a previous reconstruction, overwrite it\n        if (!argument.pcs) {\n          argument.pcs = [];\n        }\n        if (argument.pcs.length > 0) {\n          logger.log(\"warning\", \"[ModelPlugin]: Overwriting duplicate pcs: \" + argument.title);\n          argument.pcs = [];\n        }\n        node.argument = argument;\n        currentPCS = argument;\n      },\n      [RuleNames.PCS + \"Exit\"]: ({}, response, node, {}, {}, logger) => {\n        const argument = node.argument;\n        if (!argument) {\n          throw new ArgdownPluginError(this.name, \"Missing argument.\");\n        }\n        if(argument.pcs.length == 0){\n          throw new ArgdownPluginError(this.name, \"Missing argument statements.\");\n        }\n        const lastStatement = argument.pcs[argument.pcs.length - 1];\n        if(lastStatement.role === StatementRole.PRELIMINARY_CONCLUSION){\n          lastStatement.role = StatementRole.MAIN_CONCLUSION;\n          const ec = response.statements![lastStatement.title!];\n          ec.isUsedAsMainConclusion = true;\n          if(!ec.members.find(s => s.role === StatementRole.PRELIMINARY_CONCLUSION)){\n            ec.isUsedAsPreliminaryConclusion = false;\n          }\n        }else{\n          throw new ArgdownPluginError(this.name, \"Missing main conclusions.\");\n        }\n        argument.startLine = node.startLine;\n        argument.startColumn = node.startColumn;\n        argument.endLine = node.endLine;\n        argument.endColumn = node.endColumn;\n        currentStatement = null;\n        currentArgument = null;\n        currentPCS = null;\n      },\n      [RuleNames.ARGUMENT_STATEMENT + \"Exit\"]: (request, response, node, parentNode, childIndex, logger) => {\n        if (!currentPCS) {\n          throw new ArgdownPluginError(this.name, \"Missing argument reconstruction.\");\n        }\n        if (node.children && node.children.length > 1) {\n          //first node is ArgumentStatementStart\n          let statementNode = node.children[1] as IRuleNode;\n          let statement = statementNode.statement;\n          if (!statement) {\n            throw new ArgdownPluginError(this.name, \"Missing statement.\");\n          }\n          let ec = getEquivalenceClass(response.statements!, statement.title!);\n          statement.role = StatementRole.PREMISE;\n          (<IArgumentStatement>statement).argumentTitle = currentPCS.title;\n          if (childIndex !== null && childIndex > 0 && parentNode && parentNode.children) {\n            let precedingSibling = parentNode.children[childIndex - 1] as IRuleNode;\n            if (precedingSibling.name === RuleNames.INFERENCE) {\n              // We first assume that this is a preliminary conclusion\n              // If we exit the argument we will change the role of the last statement in the pcs\n              statement.role = StatementRole.PRELIMINARY_CONCLUSION;\n              const conclusion = <IConclusion>statement;\n              ec.isUsedAsPreliminaryConclusion = true;\n              conclusion.inference = precedingSibling.inference;\n              conclusion.inference!.conclusionIndex = currentPCS.pcs!.length;\n              conclusion.inference!.argumentTitle = currentPCS.title;\n            }\n          }\n          if (statement.role == StatementRole.PREMISE) {\n            ec.isUsedAsPremise = true;\n          }\n          currentPCS.pcs!.push(statement);\n          node.statement = statement;\n          node.statementNr = currentPCS.pcs!.length;\n        }\n      },\n      [RuleNames.INFERENCE + \"Entry\"]: ({}, {}, node) => {\n        currentInference = {\n          type: ArgdownTypes.INFERENCE,\n          relations: []\n        };\n        currentInference.relations = [];\n        currentInference.inferenceRules = [];\n        currentInference.metaData = {};\n        currentInference.startLine = node.startLine;\n        currentInference.startColumn = node.startColumn;\n        currentInference.endLine = node.endLine;\n        currentInference.endColumn = node.endColumn;\n        node.inference = currentInference!;\n        currentRelationParent = currentInference;\n        relationParentsStack.push(currentInference!);\n      },\n      [RuleNames.INFERENCE_RULES + \"Exit\"]: (request, response, node) => {\n        if (node.children && currentInference !== null) {\n          for (let child of node.children) {\n            if (isRuleNode(child) && child.name == RuleNames.FREESTYLE_TEXT) {\n              if (!currentInference.inferenceRules) {\n                currentInference.inferenceRules = [];\n              }\n              const text = child.text ? child.text.trim() : \"\";\n              currentInference.inferenceRules.push(text);\n            }\n          }\n        }\n      },\n      [RuleNames.ARGUMENT_DEFINITION + \"Exit\"]: ({}, {}, node) => {\n        if (node.argument) {\n          let description = _.last(node.argument.descriptions);\n          if (description && description.tags) {\n            addTags(description.tags, node.argument);\n          }\n          node.argument.metaData = _.merge(node.argument.metaData, node.metaData);\n        }\n        currentStatement = null;\n        currentArgument = null;\n      },\n      [RuleNames.ARGUMENT_REFERENCE + \"Exit\"]: (request, response, node) => {\n        const ruleNode = node as IRuleNode;\n        if (ruleNode.argument) {\n          ruleNode.argument.metaData = _.merge(ruleNode.argument.metaData, node.metaData);\n        }\n        currentStatement = null;\n        currentArgument = null;\n      },\n      [RuleNames.INCOMING_SUPPORT + \"Entry\"]: (request, response, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = { type: ArgdownTypes.RELATION, relationType: RelationType.SUPPORT, occurrences: [node] };\n        currentRelation.from = target;\n        node.relation = currentRelation;\n      },\n      [RuleNames.INCOMING_SUPPORT + \"Exit\"]: onRelationExit,\n      [RuleNames.INCOMING_ATTACK + \"Entry\"]: (request, response, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = { type: ArgdownTypes.RELATION, relationType: RelationType.ATTACK, occurrences: [node] };\n        currentRelation.from = target;\n        node.relation = currentRelation;\n      },\n      [RuleNames.INCOMING_ATTACK + \"Exit\"]: onRelationExit,\n      [RuleNames.OUTGOING_SUPPORT + \"Entry\"]: (request, response, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = { type: ArgdownTypes.RELATION, relationType: RelationType.SUPPORT, occurrences: [node] };\n        currentRelation.to = target;\n        node.relation = currentRelation;\n      },\n      [RuleNames.OUTGOING_SUPPORT + \"Exit\"]: onRelationExit,\n      [RuleNames.OUTGOING_ATTACK + \"Entry\"]: ({}, {}, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = { type: ArgdownTypes.RELATION, relationType: RelationType.ATTACK, occurrences: [node] };\n        currentRelation.to = target;\n        node.relation = currentRelation;\n      },\n      [RuleNames.OUTGOING_ATTACK + \"Exit\"]: onRelationExit,\n      [RuleNames.CONTRADICTION + \"Entry\"]: (request, response, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = {\n          type: ArgdownTypes.RELATION,\n          relationType: RelationType.CONTRADICTORY,\n          occurrences: [node]\n        };\n        currentRelation.from = target;\n        node.relation = currentRelation;\n      },\n      [RuleNames.CONTRADICTION + \"Exit\"]: onRelationExit,\n      [RuleNames.OUTGOING_UNDERCUT + \"Entry\"]: ({}, {}, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = { type: ArgdownTypes.RELATION, relationType: RelationType.UNDERCUT, occurrences: [node] };\n        if (currentRelationParent && currentRelationParent.type === ArgdownTypes.STATEMENT) {\n          //const inference = (<Statement>currentRelationParent).inference!; // this is not working as statement has no inference yet\n          if (currentInference) {\n            currentRelation.to = currentInference;\n          } else {\n            throw new ArgdownPluginError(this.name, \"Missing inference.\");\n          }\n        } else {\n          currentRelation.to = target;\n        }\n        node.relation = currentRelation;\n      },\n      [RuleNames.OUTGOING_UNDERCUT + \"Exit\"]: onRelationExit,\n      [RuleNames.INCOMING_UNDERCUT + \"Entry\"]: ({}, {}, node) => {\n        const target = _.last(relationParentsStack);\n        currentRelation = { type: ArgdownTypes.RELATION, relationType: RelationType.UNDERCUT, occurrences: [node] };\n        currentRelation.from = target;\n        node.relation = currentRelation;\n      },\n      [RuleNames.INCOMING_UNDERCUT + \"Exit\"]: onRelationExit,\n      [RuleNames.RELATIONS + \"Entry\"]: ({}, response, {}, {}, {}, logger) => {\n        if (!currentRelationParent) {\n          throw new ArgdownPluginError(this.name, \"Parent of relation missing.\");\n        }\n        relationParentsStack.push(getRelationMember(response, currentRelationParent));\n      },\n      [RuleNames.RELATIONS + \"Exit\"]: () => {\n        currentRelation = null;\n        relationParentsStack.pop();\n      },\n      [RuleNames.FREESTYLE_TEXT + \"Entry\"]: (request, response, node) => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        node.text = \"\";\n        if (node.children) {\n          for (let child of node.children) {\n            if (isTokenNode(child) && child.image !== undefined) {\n              if (tokenMatcher(child, argdownLexer.EscapedChar)) {\n                node.text += child.image.substring(1, child.image.length);\n              } else {\n                node.text += child.image;\n              }\n            }\n          }\n        }\n        if (target) {\n          target.text = target.text || \"\";\n          target.text += node.text;\n        }\n      },\n      [RuleNames.ITALIC + \"Entry\"]: () => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        if (!target) {\n          return;\n        }\n        const startPos = target.text ? target.text.length : 0;\n        let italicRange = { type: RangeType.ITALIC, start: startPos, stop: startPos };\n        rangesStack.push(italicRange);\n        if (!target.ranges) {\n          target.ranges = [];\n        }\n        target.ranges.push(italicRange);\n      },\n      [RuleNames.ITALIC + \"Exit\"]: ({}, {}, node) => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        if (!target) {\n          return;\n        }\n        let italicEnd = _.last(node.children) as ITokenNode;\n        if (italicEnd.image[italicEnd.image.length - 1] == \" \") {\n          target.text += \" \";\n          node.trailingWhitespace = \" \";\n        } else {\n          node.trailingWhitespace = \"\";\n        }\n        let range = _.last(rangesStack);\n        if (range) {\n          range.stop = target.text ? target.text.length - 1 : 0;\n          rangesStack.pop();\n        }\n      },\n      [RuleNames.BOLD + \"Entry\"]: () => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        if (!target) {\n          return;\n        }\n        const text = target.text || \"\";\n        let boldRange: IRange = { type: RangeType.BOLD, start: text.length, stop: text.length };\n        rangesStack.push(boldRange);\n        if (!target.ranges) {\n          target.ranges = [];\n        }\n        target.ranges.push(boldRange);\n      },\n      [RuleNames.BOLD + \"Exit\"]: (request, response, node) => {\n        const target = currentHeading ? currentHeading : currentStatement;\n        if (!target) {\n          return;\n        }\n        const ruleNode = node as IRuleNode;\n        let boldEnd = _.last(ruleNode.children) as ITokenNode;\n        if (boldEnd && boldEnd.image[boldEnd.image.length - 1] == \" \") {\n          target.text += \" \";\n          ruleNode.trailingWhitespace = \" \";\n        } else {\n          ruleNode.trailingWhitespace = \"\";\n        }\n        let range = _.last(rangesStack);\n        if (range) {\n          range.stop = target.text ? target.text.length - 1 : 0;\n          rangesStack.pop();\n        }\n      }\n    };\n  }\n}\nconst getEquivalenceClass = (statements: { [title: string]: IEquivalenceClass }, title: string): IEquivalenceClass => {\n  let ec = null;\n  ec = statements[title];\n  if (!ec) {\n    ec = createEquivalenceClass(title);\n    statements[title] = ec;\n  }\n  return ec;\n};\n"],"file":"ModelPlugin.js"}