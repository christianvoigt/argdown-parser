{"version":3,"sources":["../../src/model/model-utils.ts"],"names":["getCanonicalMember","ec","members","length","undefined","i","current","isReference","getCanonicalMemberText","statement","text","getCanonicalDescription","a","descriptions","getCanonicalDescriptionText","s","edgeToString","e","type","from","title","to","relationToString","r","createRuleNode","name","children","firstChild","lastChild","ArgdownTypes","RULE_NODE","startLine","startColumn","endLine","endColumn","isRuleNode","n","isTokenNode","tokenType","createEquivalenceClass","EQUIVALENCE_CLASS","relations","isReconstructed","pcs","isConclusion","role","StatementRole","PRELIMINARY_CONCLUSION","MAIN_CONCLUSION","inference","isArgumentStatement","PREMISE"],"mappings":"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","sourcesContent":["import {\n  IStatement,\n  IEquivalenceClass,\n  IArgument,\n  IMapEdge,\n  IMapNode,\n  IRelation,\n  ISection,\n  ArgdownTypes,\n  IAstNode,\n  IRuleNode,\n  ITokenNode,\n  IConclusion,\n  StatementRole,\n  IArgumentStatement\n} from \"./model\";\nimport { RuleNames } from \"../RuleNames\";\n\n/**\n * Provides a default statement that can be used to reqpresent this equivalence class.\n * The statement chosen is the one that occurs last in the Argdown source code.\n */\nexport const getCanonicalMember = (ec: IEquivalenceClass): IStatement | undefined => {\n  if (!ec.members || ec.members.length <= 0) {\n    return undefined;\n  }\n  for (let i = ec.members.length - 1; i >= 0; i--) {\n    const current = ec.members[i];\n    if (!current.isReference) {\n      return current;\n    }\n  }\n};\n/**\n * Convenience method that directly returns the text of the equivalence class's canonical statement.\n */\nexport const getCanonicalMemberText = (ec: IEquivalenceClass): string | undefined => {\n  let statement = getCanonicalMember(ec);\n  if (statement) {\n    return statement.text;\n  }\n};\n/**\n * Provides a default description.\n * Chooses the last description defined in the Argdown source code.\n */\nexport const getCanonicalDescription = (a: IArgument): IStatement | undefined => {\n  if (!a.descriptions || a.descriptions.length <= 0) {\n    return undefined;\n  }\n  return a.descriptions[a.descriptions.length - 1];\n};\nexport const getCanonicalDescriptionText = (a: IArgument): string | undefined => {\n  const s = getCanonicalDescription(a);\n  if (s) {\n    return s.text;\n  }\n};\nexport const edgeToString = (e: IMapEdge) => {\n  return `Edge(type: ${e.type} from: ${e.from.title} to: ${e.to.title})`;\n};\nexport const relationToString = (r: IRelation) => {\n  return `Relation(from: ${r.from!.title}, to: ${r.to!.title}, type: ${r.type})`;\n};\nexport const createRuleNode = (name: RuleNames, children: IAstNode[]): IRuleNode => {\n  const firstChild = children[0];\n  const lastChild = children[children.length - 1];\n  return {\n    type: ArgdownTypes.RULE_NODE,\n    name,\n    startLine: firstChild.startLine,\n    startColumn: firstChild.startColumn,\n    endLine: lastChild.endLine,\n    endColumn: lastChild.endColumn,\n    children\n  };\n};\nexport const isRuleNode = (n: IAstNode): n is IRuleNode => {\n  return (<IRuleNode>n).type === ArgdownTypes.RULE_NODE;\n};\nexport const isTokenNode = (n: IAstNode): n is ITokenNode => {\n  return !(<any>n).type && (<ITokenNode>n).tokenType != null;\n};\nexport const createEquivalenceClass = (title: string): IEquivalenceClass => {\n  return <IEquivalenceClass>{\n    type: ArgdownTypes.EQUIVALENCE_CLASS,\n    title,\n    relations: [],\n    members: []\n  };\n};\nexport const isReconstructed = (a: IArgument): boolean => {\n  return a.pcs !== undefined && a.pcs.length > 0;\n};\nexport const isConclusion = (s: IStatement): s is IConclusion => {\n  return (\n    (s.role === StatementRole.PRELIMINARY_CONCLUSION || s.role === StatementRole.MAIN_CONCLUSION) &&\n    (<IConclusion>s).inference != undefined\n  );\n};\nexport const isArgumentStatement = (s: IStatement): s is IArgumentStatement => {\n  return (\n    s.role === StatementRole.PREMISE ||\n    s.role === StatementRole.PRELIMINARY_CONCLUSION ||\n    s.role == StatementRole.MAIN_CONCLUSION\n  );\n};\n"],"file":"model-utils.js"}