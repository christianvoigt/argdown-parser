{"version":3,"sources":["../../src/model/model.ts"],"names":["ArgdownTypes","RelationType","RangeType","StatementRole"],"mappings":";;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;IAwBYA,Y;AAgBZ;;;;;;;;;;;;;;;;;;;;WAhBYA,Y;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;GAAAA,Y,4BAAAA,Y;;IAiCAC,Y;AAQZ;;;;;;;;WARYA,Y;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;AAAAA,c;GAAAA,Y,4BAAAA,Y;;IAqBAC,S;;;WAAAA,S;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;GAAAA,S,yBAAAA,S;;AA0GZ;;;;;;;;;;;IAWYC,a;AAQZ;;;;;;WARYA,a;AAAAA,e;AAAAA,e;AAAAA,e;AAAAA,e;AAAAA,e;AAAAA,e;GAAAA,a,6BAAAA,a","sourcesContent":["import { RuleNames } from \"../RuleNames\";\n\n/**\n * All data objects stored in the [[IArgdownResponse]] are simple object literals implementing an interface.\n * You can simply instantiate an argument, statement or relation by creating an object literal and adding properties to it.\n *\n * To support runtime type checking, each of these objects has a required `obj.type` property with its own ArgdownTypes member as type.\n * Typescript will automatically narrow the type if you check if some object's type property is equal to a specific ArgdownTypes member.\n *\n * @example\n * ```javascript\n * // Instantiate a new statement by using an object literal:\n * const obj = {\n *  type: ArgdownTypes.STATEMENT,\n *  title: \"Some title\",\n *  text: \"Some text\"\n * }\n *\n * if(obj.type === ArgdownTypes.STATEMENT){\n *  // Because IStatement is the only type with ArgdownTypes.STATEMENT as type of its `type`property\n *  // Typescript will now know that obj is of type IStatement, you don't have to cast it explicitely.\n *  obj.tags = [\"some tag\"];\n *  obj.role = StatementRole.PREMISE;\n * }\n * ```\n */\nexport enum ArgdownTypes {\n  EQUIVALENCE_CLASS = \"equivalence-class\",\n  STATEMENT = \"statement\",\n  STATEMENT_REFERENCE = \"statement-reference\",\n  ARGUMENT = \"argument\",\n  RELATION = \"relation\",\n  INFERENCE = \"inference\",\n  STATEMENT_MAP_NODE = \"statement-map-node\",\n  ARGUMENT_MAP_NODE = \"argument-map-node\",\n  GROUP_MAP_NODE = \"group-map-node\",\n  MAP_EDGE = \"map-edge\",\n  SECTION = \"section\",\n  RULE_NODE = \"rule-node\",\n  TOKEN_NODE = \"token-node\"\n}\n\n/**\n * The relation types of the Argdown syntax used in [[IRelation.relationType]].\n *\n * Note that ATTACK/CONTRARY and SUPPORT/ENTAILS are using the same relations symbols (- and +).\n * The difference lies in the source and target of the relations: attack and support relations\n * are dialectical relations from an argument/statement to an argument.\n *\n * An UNDERCUT is a dialectical relation between an argument/statement to an inference of an argument.\n *\n * ENTAILS, CONTRARY and CONTRADICTORY are logical relations between two statements.\n * Dialectical support and attack relations can be derived from logical statement-to-statement relations\n * if these statements are used as premises or main conclusions in arguments.\n *\n * Logical equivalence between statements is missing from this list of relation types because it is not modeled as an [[IRelation]],\n * but instead as an [[IEquivalenceClass]].\n *\n */\nexport enum RelationType {\n  ATTACK = \"attack\",\n  SUPPORT = \"support\",\n  ENTAILS = \"entails\",\n  CONTRARY = \"contrary\",\n  CONTRADICTORY = \"contradictory\",\n  UNDERCUT = \"undercut\"\n}\n/**\n * A formatted range of text.\n *\n * Used to save information about ranges containing bold and italic text, a mention, link or a tag.\n */\nexport interface IRange {\n  type: RangeType;\n  start: number;\n  stop: number;\n  title?: string;\n  url?: string;\n  tag?: string;\n}\nexport enum RangeType {\n  BOLD = \"bold\",\n  ITALIC = \"italic\",\n  LINK = \"link\",\n  TAG = \"tag\",\n  STATEMENT_MENTION = \"statement-mention\",\n  ARGUMENT_MENTION = \"argument-mention\"\n}\nexport interface HasTitle {\n  title?: string;\n}\nexport interface HasText {\n  text?: string;\n  ranges?: IRange[];\n}\nexport interface HasRelations {\n  relations?: IRelation[];\n}\nexport interface HasTags {\n  tags?: string[];\n  sortedTags?: string[];\n}\nexport interface HasMetaData {\n  metaData?: any;\n}\nexport interface HasLocation {\n  startLine?: number;\n  endLine?: number;\n  startOffset?: number;\n  endOffset?: number;\n  startColumn?: number;\n  endColumn?: number;\n}\nexport interface HasSection {\n  section?: ISection;\n}\n/**\n * Represents a matched Argdown syntax rule in the abstract syntax tree produced by the [[ParserPlugin]].\n * Has either other [[IRuleNode]]s or [[ITokenNode]]s as children.\n */\nexport interface IRuleNode extends HasLocation, HasMetaData, HasText, HasTags, HasTitle {\n  type: ArgdownTypes.RULE_NODE;\n  name: RuleNames;\n  children?: IAstNode[];\n  statement?: IStatement;\n  statementNr?: number;\n  level?: number;\n  section?: ISection;\n  argument?: IArgument;\n  relation?: IRelation;\n  equivalenceClass?: IEquivalenceClass;\n  inference?: IInference;\n  trailingWhitespace?: string;\n}\n/**\n * Represents a matched Argdown token in the abstract syntax tree produced by the [[ParserPlugin]].\n */\nexport interface ITokenNode extends chevrotain.IToken, HasTitle, HasMetaData, HasText {\n  trailingWhitespace?: string;\n  url?: string;\n  tag?: string;\n}\n/**\n * A node in the abstract syntax tree produced by the [[ParserPlugin]]\n */\nexport type IAstNode = IRuleNode | ITokenNode;\n/**\n * Argument with an optional premise-conclusion-structure (pcs)\n *\n * If the argument has a premise-conclusion-structure,\n * all outgoing relations that were defined for this argument\n * are transformed by the [[ModelPlugin]] into relations of the argument's main conclusion\n * (the last statement in the argument's pcs).\n */\nexport interface IArgument extends HasTitle, HasRelations, HasTags, HasMetaData, HasLocation, HasSection {\n  type: ArgdownTypes.ARGUMENT;\n  /**\n   * If the argument was logically reconstructed, it has a premise conclusion structure (pcs).\n   * A pcs consists of a statement list (not a list of equivalence classes)\n   * in which each statement plays either the role of \"premise\" or \"conclusion\".\n   * Using statements makes it possible to save argument-specific data in the statements:\n   * This is used to save the role of the statement in this argument. It is either a PREMISE, PRELIMINARY_CONCLUSION or MAIN_CONCLUSION.\n   * Statements that have the role of a conclusion in the argument possess an inference property.\n   */\n  pcs: IStatement[];\n  /**\n   * The statements that were used to describe the argument in argument definitions.\n   * These statements are not members of any equivalence class,\n   * have no logical relations and do not exist in the model apart from the argument.\n   */\n  descriptions: IStatement[];\n}\n/**\n * Each statement represents a paragraph of text in the original Argdown source code.\n * Statements are thus not \"propositions\" in the philosophical sense or \"strings\" in the computational sense.\n * Instead they represent string occurrences in a document.\n *\n * Each statement belongs to exactly one [[IEquivalenceClass]], identified by the statement's title. If no title was defined, a title is automatically generated.\n *\n * For further details on the relationship between equivalence classes and statements, see [[IEquivalenceClass]].\n */\nexport interface IStatement extends HasTitle, HasTags, HasMetaData, HasLocation, HasSection, HasText {\n  type: ArgdownTypes.STATEMENT;\n  role?: StatementRole;\n  isReference?: boolean;\n}\n/**\n * The role of a statement occurrence in an Argdown document.\n *\n * If the statement is used in an argument's premise conclusion structure\n * it is either a PREMISE, PRELIMINARY_CONCLUSION or a CONCLUSION.\n *\n * If it is used to describe an argument in an argument definition, it is an ARGUMENT_DESCRIPTION.\n *\n * If it is used to define a relation it is a RELATION_STATEMENT and\n * if it is a standalone paragraph within the Argdown text it is a TOP_LEVEL_STATEMENT.\n */\nexport enum StatementRole {\n  PREMISE = \"premise\",\n  PRELIMINARY_CONCLUSION = \"preliminary-conclusion\",\n  MAIN_CONCLUSION = \"main-conclusion\",\n  ARGUMENT_DESCRIPTION = \"argument-description\",\n  TOP_LEVEL_STATEMENT = \"top-level-statement\",\n  RELATION_STATEMENT = \"relation-statement\"\n}\n/**\n * A statement used within an argument's premise-conclusion-structure ([[IArgument.pcs]])\n */\nexport interface IArgumentStatement extends IStatement {\n  role: StatementRole.PREMISE | StatementRole.MAIN_CONCLUSION | StatementRole.PRELIMINARY_CONCLUSION;\n  argumentTitle?: string;\n}\n/**\n * A statement used as conclusion within an argument's premise-conclusion-structure ([[IArgument.pcs]])\n */\nexport interface IConclusion extends IArgumentStatement {\n  role: StatementRole.PRELIMINARY_CONCLUSION | StatementRole.MAIN_CONCLUSION;\n  inference?: IInference;\n}\n/**\n * Argdown statements are automatically grouped into equivalence classes by using their titles as identifiers.\n * All member statements of such a class are considered to be logically equivalent (as essentially meaning the same).\n *\n * Each [[Statement]] (apart from argument descriptions) belongs to one and only one equivalence class.\n *\n * Statements for which no title is defined will be given an automatically generated one and will\n * belong to an equivalence class with only one member.\n *\n * Statements in Argdown are basically string occurrences, not strings.\n * This means that for each time a statement is defined with a certain title and text in the Argdown source code,\n * there will be a separate member in the equivalence class with this title.\n * This makes it possible to save occurrence-specific data with each statement (e.g. its location in the text).\n *\n * The relations/tags of an equivalence class are the union set of all relations/tags of the class members.\n * Logical relations with other statements can be of type: entails, contrary, contradictory\n * Dialectical relations with arguments or inferences can be of type: support, attack, undercut.\n *\n */\nexport interface IEquivalenceClass extends HasTitle, HasRelations, HasTags, HasMetaData, HasLocation, HasSection {\n  type: ArgdownTypes.EQUIVALENCE_CLASS;\n  /**\n   * The statements that share the title with this equivalence class and are considered to be logically equivalent.\n   * See the description of this class for further details.\n   */\n  members: IStatement[];\n  /**\n   * is true if any member statement is used as a premise in an argument's pcs\n   */\n  isUsedAsPremise?: boolean;\n  /**\n   * is true if any member statement is used as a main conclusion in an argument's pcs\n   */\n  isUsedAsMainConclusion?: boolean;\n  /**\n   * is true if any member statement is used as a main conclusion in an argument's pcs\n   */\n  isUsedAsPreliminaryConclusion?: boolean;\n  /**\n   * is true if any member statement is used as top level element (as child of the argdown rule)\n   */\n  isUsedAsTopLevelStatement?: boolean;\n  /**\n   * is true if any member statement is used as content of a relation (will ignore references)\n   */\n  isUsedAsRelationStatement?: boolean;\n}\n/**\n * An inference in an argument's premise-conclusion-structure (pcs).\n * To keep the pcs simple, inferences are stored as property of the conclusion statement that is inferred.\n * Thus, the last statement of a pcs will always be a conclusion containing an inference.\n *\n * Inferences can be identified by their argument's title and their conclusion's index in the argument's pcs.\n */\nexport interface IInference extends HasTitle, HasRelations, HasMetaData, HasLocation, HasSection {\n  type: ArgdownTypes.INFERENCE;\n  inferenceRules?: string[];\n  /**\n   * The title of the argument of whose pcs this inference is a part of\n   */\n  argumentTitle?: string;\n  /**\n   * The pcs index of the conclusion containing this inference\n   */\n  conclusionIndex?: number;\n}\n/**\n * The data types that can be either source or target of a relation.\n *\n * Note that [[IInference]] can only be a relation target and never be a relation source.\n */\nexport type RelationMember = IArgument | IEquivalenceClass | IInference;\n\n/**\n * Represents a relation between two Argdown elements.\n * The relation source and target can be an [[IEquivalenceClass]], [[IArgument]] or [[IInference]].\n *\n * Syntactically Ardown does not clearly distinguish between statement-statement relations\n * and statement-argument relations. This is intentionally: the + and - symbols can either represent\n * attack and support relations or contrariness and entailment, depending on the type of the relation's source\n * and target.\n *\n * The model plugin will determine the correct relation types, depending on the type of the relation's source and target.\n * If the source is a reconstructed argument,\n * the relation will be transformed to a logical relation of the argument's main conclusion.\n */\nexport interface IRelation {\n  type: ArgdownTypes.RELATION;\n  from?: RelationMember;\n  to?: RelationMember;\n  relationType: RelationType;\n  /**\n   * The locations in the Argdown source code at which this relation was defined.\n   * The same relation can be defined in different ways.\n   * It can also be defined in the same way, but in multiple places.\n   */\n  occurrences: IRuleNode[];\n}\n/**\n * A section in an Argdown document.\n * Sections can contain other sections as children. They are derived from headings\n * and used to derive groups (clusters) in argument maps.\n */\nexport interface ISection extends HasTitle, HasTags, HasText, HasLocation, HasMetaData {\n  type: ArgdownTypes.SECTION;\n  /**\n   * An automatically generated id unique among sections\n   */\n  id: string;\n  level: number;\n  children: ISection[];\n  parent?: ISection;\n  heading?: IRuleNode;\n}\n/**\n * The ArgdownTypes members identifying nodes in an argument map.\n */\nexport type MapNodeType =\n  | ArgdownTypes.STATEMENT_MAP_NODE\n  | ArgdownTypes.ARGUMENT_MAP_NODE\n  | ArgdownTypes.GROUP_MAP_NODE;\n\n/**\n * A node in an argument map.\n *\n * Can be either a statement, argument or group node.\n */\nexport interface IMapNode extends HasTitle, HasTags {\n  type: MapNodeType;\n  labelTitle?: string;\n  labelText?: string;\n  id: string;\n}\n/**\n * A group node within an argument map.\n *\n * Groups are clusters of child nodes and can be children of other groups.\n */\nexport interface IGroupMapNode extends IMapNode {\n  type: ArgdownTypes.GROUP_MAP_NODE;\n  level?: number;\n  children?: IMapNode[];\n  parent?: string;\n  section?: ISection;\n}\n/**\n * An edge in an argument map derived from an [[IRelation]] or an [[IEquivalenceClass]].\n *\n */\nexport interface IMapEdge {\n  type: ArgdownTypes.MAP_EDGE;\n  id: string;\n  /**\n   * Source node of this edge\n   */\n  from: IMapNode;\n  /**\n   * Target node of this edge\n   */\n  to: IMapNode;\n  /**\n   * Stores the equivalence class if the edge is based on a relation that has one as a source or if this edge is derived from an equivalence class itself.\n   */\n  fromEquivalenceClass?: IEquivalenceClass;\n  /**\n   * Stores the equivalence class if the edge is based on a relation that has one as a target or if this edge is derived from an equivalence class itself.\n   */\n  toEquivalenceClass?: IEquivalenceClass;\n  relationType: RelationType;\n}\n/**\n * An argument map, consisting of argument, statement and group nodes and support and attack edges between arguments and statements.\n */\nexport interface IMap {\n  nodes: IMapNode[];\n  edges: IMapEdge[];\n}\n"],"file":"model.js"}