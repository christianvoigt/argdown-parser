{"version":3,"sources":["../src/ArgdownErrorMessageProvider.ts"],"names":["defaultParserErrorProvider","chevrotain","tokenMatcher","MISSING_TEXT_CONTENT_ERROR","INVALID_INFERENCE_ERROR","INVALID_RELATION_ERROR","INVALID_INDENTATION_ERROR","MISSING_RELATION_CONTENT_ERROR","MISSING_INFERENCE_END_ERROR","INVALID_INFERENCE_POSITION_ERROR","MISSING_INFERENCE_ERROR","MISSING_CONCLUSION_ERROR","ARGUMENT_RECONSTRUCTION_POSITION_ERROR","INVALID_ARGUMENT_STATEMENT_CONTENT_ERROR","INCOMPLETE_ARGUMENT_RECONSTRUCTION_ERROR","GetParagraphStartTokenDescription","token","ArgdownLexer","OutgoingSupport","IncomingSupport","OutgoingAttack","IncomingAttack","Contradiction","IncomingUndercut","OutgoingUndercut","isRelationToken","isRelationRule","ruleName","endsWith","ArgdownErrorMessageProvider","options","expected","InferenceStart","InferenceEnd","Dedent","actual","ArgumentReference","ArgumentDefinition","StatementReference","StatementDefinition","StatementNumber","buildMismatchTokenMessage","tokenDescription","firstRedundant","Indent","Freestyle","buildNotAllInputParsedMessage","tokens","length","secondToken","buildNoViableAltMessage","firstToken","buildEarlyExitMessage"],"mappings":"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","sourcesContent":["import * as chevrotain from \"chevrotain\";\nimport { TokenType, IToken, IParserErrorMessageProvider } from \"chevrotain\";\nimport * as ArgdownLexer from \"./lexer\";\n\n//import * as _ from 'lodash';\n\nconst defaultParserErrorProvider = chevrotain.defaultParserErrorProvider;\nconst tokenMatcher = chevrotain.tokenMatcher;\n//const EOF = chevrotain.EOF;\nconst MISSING_TEXT_CONTENT_ERROR =\n  \"Missing text content. \" +\n  \"Please add a line of text or refer to an existing statement or argument instead by replacing the content in this line with [Statement Title] or <Argument Title> (without a colon). \" +\n  \"If you want to define a statement ([Statement Title]:) or argument (<Argument Title>:), the defining text content has to follow the defined element title without any empty lines in between.\";\nconst INVALID_INFERENCE_ERROR =\n  \"Invalid inference. Inferences can either be marked by four hyphens (----) or have the following format: \" +\n  \"--Inference Rule 1, Inference Rule 2 (my meta data property 1: 1, 2, 3; my meta data property 2: value) --\";\nconst INVALID_RELATION_ERROR =\n  \"Invalid relation syntax. This may either be caused by a) an invalid relation parent or b) invalid indentation. a) Invalid relation parent: Only statements and arguments can have relations as child elements. b) Invalid Indentation tree: Please check that if there are preceding relations in this paragraph, there is at least one with equal or less indentation.\";\nconst INVALID_INDENTATION_ERROR = \"Invalid indentation.\";\nconst MISSING_RELATION_CONTENT_ERROR =\n  \"Missing relation content. Please define or refer to a statement or argument (you can define a statement by simply adding a line of text).\";\nconst MISSING_INFERENCE_END_ERROR = \"Invalid inference syntax. Please end your inference with two hyphens (--)\";\nconst INVALID_INFERENCE_POSITION_ERROR =\n  \"Invalid inference position. An inference may only occur within an argument reconstruction, in which it is preceded by a premise and followed by a conclusion (both of which have to be numbered statements: '(1) Statement').\";\nconst MISSING_INFERENCE_ERROR =\n  \"Missing inference. Use four hyphens (----) between two numbered statements to insert an inference in your reconstruction and mark the latter statement as a conclusion.\";\nconst MISSING_CONCLUSION_ERROR = \"Missing conclusion. Please add a numbered statement after the inference.\";\nconst ARGUMENT_RECONSTRUCTION_POSITION_ERROR =\n  \"Invalid position of argument reconstruction. Make sure the argument reconstruction is preceded by an empty line.\";\nconst INVALID_ARGUMENT_STATEMENT_CONTENT_ERROR =\n  \"Invalid statement content. An argument reference (<Argument Title>) or definition (<Argument Title>:) can not be used as premise or conclusion within an argument reconstruction. Use statement references ([Statement Title]) or definitions ([Statement Title]:) instead.\";\nconst INCOMPLETE_ARGUMENT_RECONSTRUCTION_ERROR =\n  \"Incomplete argument reconstruction. An argument reconstruction has to consist of at least one premise (a numbered statement: '(1) Statement Text'), one inference (marked by four hyphens ----) and one conclusion (a numbered statement after an inference). There may no be any empty lines between these elements.\";\n\nconst GetParagraphStartTokenDescription = (token: IToken): string | undefined => {\n  if (tokenMatcher(token, ArgdownLexer.OutgoingSupport)) {\n    return \"an outgoing support relation (+ or <+)\";\n  } else if (tokenMatcher(token, ArgdownLexer.IncomingSupport)) {\n    return \"an incoming support relation (+>)\";\n  } else if (tokenMatcher(token, ArgdownLexer.OutgoingAttack)) {\n    return \"an outgoing attack relation (- or <-)\";\n  } else if (tokenMatcher(token, ArgdownLexer.IncomingAttack)) {\n    return \"an incoming attack relation (->)\";\n  } else if (tokenMatcher(token, ArgdownLexer.Contradiction)) {\n    return \"a contradictory relation (><)\";\n  } else if (tokenMatcher(token, ArgdownLexer.IncomingUndercut)) {\n    return \"an incoming undercut relation (_>)\";\n  } else if (tokenMatcher(token, ArgdownLexer.OutgoingUndercut)) {\n    return \"an incoming undercut relation (<_)\";\n  }\n};\nconst isRelationToken = (token: IToken): boolean => {\n  return (\n    tokenMatcher(token, ArgdownLexer.IncomingSupport) ||\n    tokenMatcher(token, ArgdownLexer.OutgoingSupport) ||\n    tokenMatcher(token, ArgdownLexer.IncomingAttack) ||\n    tokenMatcher(token, ArgdownLexer.OutgoingAttack) ||\n    tokenMatcher(token, ArgdownLexer.IncomingUndercut) ||\n    tokenMatcher(token, ArgdownLexer.OutgoingUndercut) ||\n    tokenMatcher(token, ArgdownLexer.Contradiction)\n  );\n};\nconst isRelationRule = (ruleName: string): boolean => {\n  return (\n    ruleName.endsWith(\"Support\") ||\n    ruleName.endsWith(\"Attack\") ||\n    ruleName.endsWith(\"Undercut\") ||\n    ruleName == \"Contradiction\"\n  );\n};\nexport class ArgdownErrorMessageProvider implements IParserErrorMessageProvider {\n  buildMismatchTokenMessage(options: { expected: TokenType; actual: IToken; previous: IToken; ruleName: string }) {\n    if (options.ruleName == \"inference\") {\n      if (options.expected == ArgdownLexer.InferenceStart) {\n        return MISSING_INFERENCE_ERROR;\n      } else if (options.expected == ArgdownLexer.InferenceEnd) {\n        return MISSING_INFERENCE_END_ERROR;\n      }\n    } else if (\n      options.expected == ArgdownLexer.Dedent &&\n      (options.ruleName == \"statementRelations\" || options.ruleName == \"argumentRelations\")\n    ) {\n      if (tokenMatcher(options.actual, ArgdownLexer.ArgumentReference)) {\n        return \"Invalid relation text content. An argument reference (<Argument Title>) may not be preceded or followed by other content. If you want to start a new paragraph, insert an empty line before the reference. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n      } else if (tokenMatcher(options.actual, ArgdownLexer.ArgumentDefinition)) {\n        return \"Invalid relation text content. An argument definition (<Argument Title>:) may not be preceded by other content. If you want to start a new paragraph, insert an empty line before the definition. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n      } else if (tokenMatcher(options.actual, ArgdownLexer.StatementReference)) {\n        return \"Invalid relation text content. A statement reference ([Statement Title]) may not be preceded or followed by other content.  If you want to start a new paragraph, insert an empty line before the reference. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n      } else if (tokenMatcher(options.actual, ArgdownLexer.StatementDefinition)) {\n        return \"Invalid relation text content. A statement definition ([Statement Title]:) may not be preceded by other content.  If you want to start a new paragraph, insert an empty line before the definition. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n      } else {\n        return \"Invalid relation text content. Check that the content is not preceded by a statement reference ([Statement Title]) or argument reference (<Argument Title>). If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n      }\n    } else if (options.ruleName == \"argumentStatement\") {\n      if (options.expected == ArgdownLexer.StatementNumber) {\n        return MISSING_CONCLUSION_ERROR;\n      }\n    }\n    return defaultParserErrorProvider.buildMismatchTokenMessage!(options);\n  }\n  buildNotAllInputParsedMessage(options: { firstRedundant: IToken; ruleName: string }) {\n    var tokenDescription = \"\";\n    if (tokenMatcher(options.firstRedundant, ArgdownLexer.Indent) || isRelationToken(options.firstRedundant)) {\n      return INVALID_RELATION_ERROR;\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.InferenceStart)) {\n      return INVALID_INFERENCE_POSITION_ERROR;\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementNumber)) {\n      return ARGUMENT_RECONSTRUCTION_POSITION_ERROR;\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.ArgumentReference)) {\n      tokenDescription = \"An argument reference (<Argument Title>)\";\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.ArgumentDefinition)) {\n      tokenDescription = \"An argument definition (<Argument Title>:)\";\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementReference)) {\n      tokenDescription = \"A statement reference ([Statement Title])\";\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementDefinition)) {\n      tokenDescription = \"A statement  definition ([Statement Title]:)\";\n    } else if (tokenMatcher(options.firstRedundant, ArgdownLexer.Freestyle)) {\n      tokenDescription =\n        \"Invalid position of text content. Make sure it is not preceded by a statement reference ([Statement Title]) or argument reference (<Argument Title>).\";\n    } else {\n      return defaultParserErrorProvider.buildNotAllInputParsedMessage!(options);\n    }\n    return `Invalid element position. ${tokenDescription} may only occur at the beginning of a line or after a relation symbol.`;\n  }\n  buildNoViableAltMessage(options: {\n    expectedPathsPerAlt: TokenType[][][];\n    actual: IToken[];\n    previous: IToken;\n    customUserDescription: string;\n    ruleName: string;\n  }) {\n    const tokens = options.actual;\n    if (options.ruleName == \"argdown\" && tokens.length > 0) {\n      let tokenDescription = \"\";\n      if (tokens.length >= 2 && tokenMatcher(tokens[0], ArgdownLexer.Indent)) {\n        let secondToken = tokens[1];\n        tokenDescription = GetParagraphStartTokenDescription(secondToken) || \"\";\n      } else if (tokens.length > 0) {\n        tokenDescription = GetParagraphStartTokenDescription(tokens[0]) || \"\";\n      }\n      return `Invalid paragraph start. Argdown paragraphs may not start with ${tokenDescription}. If you do not want to start a new paragraph, remove any empty lines above this one. If you do want to start a new paragraph, try starting with normal text, a statement title, argument title or a list item (using * for unordered or 1. for ordered lists).`;\n    } else if (isRelationRule(options.ruleName)) {\n      return MISSING_RELATION_CONTENT_ERROR;\n    } else if (options.ruleName == \"statement\") {\n      if (\n        tokens.length > 0 &&\n        (tokenMatcher(tokens[0], ArgdownLexer.ArgumentReference) ||\n          tokenMatcher(tokens[0], ArgdownLexer.ArgumentDefinition))\n      ) {\n        return INVALID_ARGUMENT_STATEMENT_CONTENT_ERROR;\n      }\n      return MISSING_TEXT_CONTENT_ERROR;\n    }\n    return defaultParserErrorProvider.buildNoViableAltMessage!(options);\n  }\n  buildEarlyExitMessage(options: {\n    expectedIterationPaths: TokenType[][];\n    actual: IToken[];\n    previous: IToken;\n    customUserDescription: string;\n    ruleName: string;\n  }): string {\n    var firstToken = options.actual.length > 0 ? options.actual[0] : null;\n    if (options.ruleName == \"argdown\") {\n      if (firstToken && isRelationToken(firstToken)) {\n        return INVALID_RELATION_ERROR;\n      } else if (firstToken && tokenMatcher(firstToken, ArgdownLexer.InferenceStart)) {\n        return INVALID_INFERENCE_POSITION_ERROR;\n      }\n    } else if (options.ruleName == \"statementContent\") {\n      return MISSING_TEXT_CONTENT_ERROR;\n    } else if (options.ruleName == \"pcs\") {\n      if (firstToken && isRelationToken(firstToken)) {\n        return INVALID_INDENTATION_ERROR;\n      }\n      return INCOMPLETE_ARGUMENT_RECONSTRUCTION_ERROR;\n    } else if (options.ruleName == \"metadata\") {\n      return INVALID_INFERENCE_ERROR;\n    } else if (firstToken && tokenMatcher(firstToken, ArgdownLexer.InferenceEnd)) {\n      return INVALID_INFERENCE_ERROR;\n    }\n    return defaultParserErrorProvider.buildEarlyExitMessage!(options);\n  }\n}\n"],"file":"ArgdownErrorMessageProvider.js"}