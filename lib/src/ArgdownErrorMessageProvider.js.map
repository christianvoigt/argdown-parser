{"version":3,"sources":["../../src/ArgdownErrorMessageProvider.js"],"names":["chevrotain","_","defaultErrorProvider","tokenMatcher","EOF","MISSING_TEXT_CONTENT_ERROR","INVALID_INFERENCE_ERROR","INVALID_METADATA_ERROR","INVALID_RELATION_ERROR","MISSING_INFERENCE_END_ERROR","INVALID_INFERENCE_POSITION_ERROR","GetParagraphStartTokenDescription","token","OutgoingSupport","IncomingSupport","OutgoingAttack","IncomingAttack","Contradiction","IncomingUndercut","OutgoingUndercut","isRelationToken","isRelationRule","ruleName","endsWith","argdownErrorMessageProvider","buildMismatchTokenMessage","options","expected","InferenceStart","InferenceEnd","Dedent","actual","ArgumentReference","ArgumentDefinition","StatementReference","StatementDefinition","StatementNumber","buildNotAllInputParsedMessage","tokenDescription","firstRedundant","Indent","Freestyle","buildNoViableAltMessage","tokens","length","secondToken","buildEarlyExitMessage","firstToken","INVALID_INDENTATION_ERROR","MetadataEnd","module","exports","ArgdownErrorMessageProvider"],"mappings":"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","file":"ArgdownErrorMessageProvider.js","sourcesContent":["import * as chevrotain from 'chevrotain';\nimport { ArgdownLexer } from './ArgdownLexer.js';\nimport * as _ from 'lodash';\n\nconst defaultErrorProvider = chevrotain.defaultErrorProvider\nconst tokenMatcher = chevrotain.tokenMatcher;\nconst EOF = chevrotain.EOF;\nconst MISSING_TEXT_CONTENT_ERROR = \"Missing text content. \"\n    + \"Please add a line of text or refer to an existing statement or argument instead by replacing the content in this line with [Statement Title] or <Argument Title> (without a colon). \"\n    + \"If you want to define a statement ([Statement Title]:) or argument (<Argument Title>:), the defining text content has to follow the defined element title without any empty lines in between.\";\nconst INVALID_INFERENCE_ERROR = \"Invalid inference. Inferences can either be marked by four hyphens (----) or have the following format: \"\n    + \"--Inference Rule 1, Inference Rule 2 (my meta data property 1: 1, 2, 3; my meta data property 2: value) --\";\nconst INVALID_METADATA_ERROR = \"Invalid metadata statement. Metadata has the following format: (my meta data property 1: 1, 2, 3; my meta data property 2: value)\";\nconst INVALID_RELATION_ERROR = \"Invalid relation syntax. This may either be caused by a) an invalid relation parent or b) invalid indentation. a) Invalid relation parent: Only statements and arguments can have relations as child elements. b) Invalid Indentation tree: Please check that if there are preceding relations in this paragraph, there is at least one with equal or less indentation.\";\nconst MISSING_INFERENCE_END_ERROR = \"Invalid inference syntax. Please end your inference with two hyphens (--)\";\nconst INVALID_INFERENCE_POSITION_ERROR = \"Invalid inference position. An inference may only occur within an argument reconstruction, in which it is preceded by a premise and followed by a conclusion (both of which have to be numbered statements: '(1) Statement').\";\nfunction GetParagraphStartTokenDescription(token) {\n    if (tokenMatcher(token, ArgdownLexer.OutgoingSupport)) {\n        return \"an outgoing support relation (+ or <+)\"\n    } else if (tokenMatcher(token, ArgdownLexer.IncomingSupport)) {\n        return \"an incoming support relation (+>)\"\n    } else if (tokenMatcher(token, ArgdownLexer.OutgoingAttack)) {\n        return \"an outgoing attack relation (- or <-)\"\n    } else if (tokenMatcher(token, ArgdownLexer.IncomingAttack)) {\n        return \"an incoming attack relation (->)\"\n    } else if (tokenMatcher(token, ArgdownLexer.Contradiction)) {\n        return \"a contradictory relation (><)\"\n    } else if (tokenMatcher(token, ArgdownLexer.IncomingUndercut)) {\n        return \"an incoming undercut relation (_>)\"\n    } else if (tokenMatcher(token, ArgdownLexer.OutgoingUndercut)) {\n        return \"an incoming undercut relation (<_)\"\n    }\n}\nfunction isRelationToken(token) {\n    return tokenMatcher(token, ArgdownLexer.IncomingSupport)\n        || tokenMatcher(token, ArgdownLexer.OutgoingSupport)\n        || tokenMatcher(token, ArgdownLexer.IncomingAttack)\n        || tokenMatcher(token, ArgdownLexer.OutgoingAttack)\n        || tokenMatcher(token, ArgdownLexer.IncomingUndercut)\n        || tokenMatcher(token, ArgdownLexer.OutgoingUndercut)\n        || tokenMatcher(token, ArgdownLexer.Contradiction);\n}\nfunction isRelationRule(ruleName) {\n    return ruleName.endsWith(\"Support\") || ruleName.endsWith(\"Attack\") || ruleName.endsWith(\"Undercut\") || ruleName == \"Contradiction\";\n}\nconst argdownErrorMessageProvider = {\n    buildMismatchTokenMessage: function (options) {\n        if (options.ruleName == \"inference\") {\n            if (options.expected == ArgdownLexer.InferenceStart) {\n                return \"Argument reconstruction with missing inference. Use four hyphens (----) between two numbered statements to insert an inference in your reconstruction and mark the latter statement as a conclusion.\";\n            } else if (options.expected == ArgdownLexer.InferenceEnd) {\n                return MISSING_INFERENCE_END_ERROR;\n            }\n        }\n        else if(options.ruleName == \"metadataStatement\"){\n            return INVALID_METADATA_ERROR;\n        }\n        else if(options.expected == ArgdownLexer.Dedent && (options.ruleName == \"statementRelations\" || options.ruleName == \"argumentRelations\")){\n            if (tokenMatcher(options.actual, ArgdownLexer.ArgumentReference)){\n                return \"Invalid relation text content. An argument reference (<Argument Title>) may not be preceded or followed by other content. If you want to start a new paragraph, insert an empty line before the reference. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }\n            else if(tokenMatcher(options.actual, ArgdownLexer.ArgumentDefinition)){\n                return \"Invalid relation text content. An argument definition (<Argument Title>:) may not be preceded by other content. If you want to start a new paragraph, insert an empty line before the definition. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }\n            else if (tokenMatcher(options.actual, ArgdownLexer.StatementReference)){\n                return \"Invalid relation text content. A statement reference ([Statement Title]) may not be preceded or followed by other content.  If you want to start a new paragraph, insert an empty line before the reference. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }\n            else if (tokenMatcher(options.actual, ArgdownLexer.StatementDefinition)) {\n                return \"Invalid relation text content. A statement definition ([Statement Title]:) may not be preceded by other content.  If you want to start a new paragraph, insert an empty line before the definition. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }else{\n                return \"Invalid relation text content. Check that the content is not preceded by a statement reference ([Statement Title]) or argument reference (<Argument Title>). If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";                \n            }\n        }\n        else if (options.ruleName == \"argumentStatement\") {\n            if (options.expected == ArgdownLexer.StatementNumber) {\n                return \"Argument reconstruction with missing conclusion. Please add a numbered statement after the inference.\"\n            }\n        }\n        return defaultErrorProvider.buildMismatchTokenMessage(options)\n    },\n    buildNotAllInputParsedMessage: function (options) {\n        var tokenDescription = \"\";\n        if (tokenMatcher(options.firstRedundant, ArgdownLexer.Indent) || isRelationToken(options.firstRedundant)) {\n            return INVALID_RELATION_ERROR;\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.InferenceStart)){\n            return INVALID_INFERENCE_POSITION_ERROR;\n        }\n        else if(tokenMatcher(options.firstRedundant, ArgdownLexer.StatementNumber)){\n            return \"Invalid position of argument reconstruction. Make sure the argument reconstruction is preceded by an empty line.\";            \n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.ArgumentReference)) {\n            tokenDescription = \"An argument reference (<Argument Title>)\";\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.ArgumentDefinition)) {\n            tokenDescription = \"An argument definition (<Argument TItle>:)\";\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementReference)) {\n            tokenDescription = \"A statement reference ([Statement Title])\";\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementDefinition)) {\n            tokenDescription = \"A statement  definition ([Statement Title]:)\";\n        } \n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.Freestyle)) {\n            tokenDescription = \"Invalid position of text content. Make sure it is not preceded by a statement reference ([Statement Title]) or argument reference (<Argument Title>).\";\n        } \n        else {\n            return defaultErrorProvider.buildNotAllInputParsedMessage(options);\n        }\n        return `${tokenDescription} may only occur at the beginning of a line or after a relation symbol.`;\n    },\n    buildNoViableAltMessage: function (options) {\n        const tokens = options.actual;\n        if (options.ruleName == \"argdown\" && tokens.length > 0) {\n            let tokenDescription = \"\";\n            if (tokens.length >= 2 && tokenMatcher(tokens[0], ArgdownLexer.Indent)) {\n                let secondToken = tokens[1];\n                tokenDescription = GetParagraphStartTokenDescription(secondToken);\n            } else if (tokens.length > 0) {\n                tokenDescription = GetParagraphStartTokenDescription(tokens[0]);\n            }\n            return `Argdown paragraphs may not start with ${tokenDescription}. If you do not want to start a new paragraph, remove any empty lines above this one. If you do want to start a new paragraph, try starting with normal text, a statement title, argument title or a list item (using * for unordered or 1. for ordered lists).`;\n        } else if (isRelationRule(options.ruleName)) {\n            return \"Missing relation content. Please define or refer to a statement or argument (you can define a statement by simply adding a line of text).\"\n        } else if (options.ruleName == \"statement\") {\n            if (tokens.length > 0 && (tokenMatcher(tokens[0], ArgdownLexer.ArgumentReference) || tokenMatcher(tokens[0], ArgdownLexer.ArgumentDefinition))) {\n                return \"An argument reference (<Argument Title>) or definition (<Argument Title>:) can not be used as premise or conclusion within an argument reconstruction. Use statement references ([Statement Title]) or definitions ([Statement Title]:) instead.\";\n            }\n            return MISSING_TEXT_CONTENT_ERROR;\n        }\n        return defaultErrorProvider.buildNoViableAltMessage(options);\n    },\n    buildEarlyExitMessage: function (options) {\n        var firstToken = options.actual[0]? null : options.actual[0];\n        if(options.ruleName == \"argdown\"){\n            if(firstToken && isRelationToken(firstToken)){\n                return INVALID_RELATION_ERROR;\n            }else if(firstToken && tokenMatcher(firstToken, ArgdownLexer.InferenceStart)){\n                return INVALID_INFERENCE_POSITION_ERROR;\n            }\n        }\n        else if (options.ruleName == \"statementContent\") {\n            return MISSING_TEXT_CONTENT_ERROR;\n        }\n        else if (options.ruleName == \"argument\") {\n            if(firstToken && isRelationToken(firstToken)){\n                return INVALID_INDENTATION_ERROR;\n            }\n            return \"Incomplete argument reconstruction. An argument reconstruction has to consist of at least one premise (a numbered statement: '(1) Statement Text'), one inference (marked by four hyphens ----) and one conclusion (a numbered statement after an inference). There may no be any empty lines between these elements.\"\n        }\n        else if(options.ruleName == \"metadata\") {\n            return INVALID_INFERENCE_ERROR;\n        }\n        else if(firstToken && tokenMatcher(firstToken, ArgdownLexer.MetadataEnd)){\n            return INVALID_METADATA_ERROR;\n        }\n        else if (firstToken && tokenMatcher(firstToken, ArgdownLexer.InferenceEnd)) {\n            return INVALID_INFERENCE_ERROR;\n        }\n        else {\n            return defaultErrorProvider.buildEarlyExitMessage(options);\n        }\n    }\n}\n\nmodule.exports = {\n    ArgdownErrorMessageProvider: argdownErrorMessageProvider\n};"]}