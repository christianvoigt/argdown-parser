{"version":3,"sources":["../../src/ArgdownErrorMessageProvider.js"],"names":["chevrotain","defaultParserErrorProvider","tokenMatcher","MISSING_TEXT_CONTENT_ERROR","INVALID_INFERENCE_ERROR","INVALID_METADATA_ERROR","INVALID_RELATION_ERROR","MISSING_RELATION_CONTENT_ERROR","MISSING_INFERENCE_END_ERROR","INVALID_INFERENCE_POSITION_ERROR","MISSING_INFERENCE_ERROR","MISSING_CONCLUSION_ERROR","ARGUMENT_RECONSTRUCTION_POSITION_ERROR","INVALID_ARGUMENT_STATEMENT_CONTENT_ERROR","INCOMPLETE_ARGUMENT_RECONSTRUCTION_ERROR","GetParagraphStartTokenDescription","token","OutgoingSupport","IncomingSupport","OutgoingAttack","IncomingAttack","Contradiction","IncomingUndercut","OutgoingUndercut","isRelationToken","isRelationRule","ruleName","endsWith","argdownErrorMessageProvider","buildMismatchTokenMessage","options","expected","InferenceStart","InferenceEnd","Dedent","actual","ArgumentReference","ArgumentDefinition","StatementReference","StatementDefinition","StatementNumber","buildNotAllInputParsedMessage","tokenDescription","firstRedundant","Indent","Freestyle","buildNoViableAltMessage","tokens","length","secondToken","buildEarlyExitMessage","firstToken","INVALID_INDENTATION_ERROR","MetadataEnd","module","exports","ArgdownErrorMessageProvider"],"mappings":";;AAAA;;IAAYA,U;;AACZ;;;;AACA;;AAEA,IAAMC,6BAA6BD,WAAWC,0BAA9C;AACA,IAAMC,eAAeF,WAAWE,YAAhC;AACA;AACA,IAAMC,6BAA6B,2BAC7B,sLAD6B,GAE7B,+LAFN;AAGA,IAAMC,0BAA0B,6GAC1B,4GADN;AAEA,IAAMC,yBAAyB,mIAA/B;AACA,IAAMC,yBAAyB,yWAA/B;AACA,IAAMC,iCAAiC,2IAAvC;AACA,IAAMC,8BAA8B,2EAApC;AACA,IAAMC,mCAAmC,+NAAzC;AACA,IAAMC,0BAA0B,yKAAhC;AACA,IAAMC,2BAA2B,0EAAjC;AACA,IAAMC,yCAAyC,kHAA/C;AACA,IAAMC,2CAA2C,6QAAjD;AACA,IAAMC,2CAA2C,uTAAjD;;AAEA,SAASC,iCAAT,CAA2CC,KAA3C,EAAkD;AAC9C,QAAId,aAAac,KAAb,EAAoB,2BAAaC,eAAjC,CAAJ,EAAuD;AACnD,eAAO,wCAAP;AACH,KAFD,MAEO,IAAIf,aAAac,KAAb,EAAoB,2BAAaE,eAAjC,CAAJ,EAAuD;AAC1D,eAAO,mCAAP;AACH,KAFM,MAEA,IAAIhB,aAAac,KAAb,EAAoB,2BAAaG,cAAjC,CAAJ,EAAsD;AACzD,eAAO,uCAAP;AACH,KAFM,MAEA,IAAIjB,aAAac,KAAb,EAAoB,2BAAaI,cAAjC,CAAJ,EAAsD;AACzD,eAAO,kCAAP;AACH,KAFM,MAEA,IAAIlB,aAAac,KAAb,EAAoB,2BAAaK,aAAjC,CAAJ,EAAqD;AACxD,eAAO,+BAAP;AACH,KAFM,MAEA,IAAInB,aAAac,KAAb,EAAoB,2BAAaM,gBAAjC,CAAJ,EAAwD;AAC3D,eAAO,oCAAP;AACH,KAFM,MAEA,IAAIpB,aAAac,KAAb,EAAoB,2BAAaO,gBAAjC,CAAJ,EAAwD;AAC3D,eAAO,oCAAP;AACH;AACJ;AACD,SAASC,eAAT,CAAyBR,KAAzB,EAAgC;AAC5B,WAAOd,aAAac,KAAb,EAAoB,2BAAaE,eAAjC,KACAhB,aAAac,KAAb,EAAoB,2BAAaC,eAAjC,CADA,IAEAf,aAAac,KAAb,EAAoB,2BAAaI,cAAjC,CAFA,IAGAlB,aAAac,KAAb,EAAoB,2BAAaG,cAAjC,CAHA,IAIAjB,aAAac,KAAb,EAAoB,2BAAaM,gBAAjC,CAJA,IAKApB,aAAac,KAAb,EAAoB,2BAAaO,gBAAjC,CALA,IAMArB,aAAac,KAAb,EAAoB,2BAAaK,aAAjC,CANP;AAOH;AACD,SAASI,cAAT,CAAwBC,QAAxB,EAAkC;AAC9B,WAAOA,SAASC,QAAT,CAAkB,SAAlB,KAAgCD,SAASC,QAAT,CAAkB,QAAlB,CAAhC,IAA+DD,SAASC,QAAT,CAAkB,UAAlB,CAA/D,IAAgGD,YAAY,eAAnH;AACH;AACD,IAAME,8BAA8B;AAChCC,+BAA2B,mCAAUC,OAAV,EAAmB;AAC1C,YAAIA,QAAQJ,QAAR,IAAoB,WAAxB,EAAqC;AACjC,gBAAII,QAAQC,QAAR,IAAoB,2BAAaC,cAArC,EAAqD;AACjD,uBAAOtB,uBAAP;AACH,aAFD,MAEO,IAAIoB,QAAQC,QAAR,IAAoB,2BAAaE,YAArC,EAAmD;AACtD,uBAAOzB,2BAAP;AACH;AACJ,SAND,MAOK,IAAGsB,QAAQJ,QAAR,IAAoB,mBAAvB,EAA2C;AAC5C,mBAAOrB,sBAAP;AACH,SAFI,MAGA,IAAGyB,QAAQC,QAAR,IAAoB,2BAAaG,MAAjC,KAA4CJ,QAAQJ,QAAR,IAAoB,oBAApB,IAA4CI,QAAQJ,QAAR,IAAoB,mBAA5G,CAAH,EAAoI;AACrI,gBAAIxB,aAAa4B,QAAQK,MAArB,EAA6B,2BAAaC,iBAA1C,CAAJ,EAAiE;AAC7D,uBAAO,oUAAP;AACH,aAFD,MAGK,IAAGlC,aAAa4B,QAAQK,MAArB,EAA6B,2BAAaE,kBAA1C,CAAH,EAAiE;AAClE,uBAAO,2TAAP;AACH,aAFI,MAGA,IAAInC,aAAa4B,QAAQK,MAArB,EAA6B,2BAAaG,kBAA1C,CAAJ,EAAkE;AACnE,uBAAO,sUAAP;AACH,aAFI,MAGA,IAAIpC,aAAa4B,QAAQK,MAArB,EAA6B,2BAAaI,mBAA1C,CAAJ,EAAoE;AACrE,uBAAO,6TAAP;AACH,aAFI,MAEA;AACD,uBAAO,sRAAP;AACH;AACJ,SAfI,MAgBA,IAAIT,QAAQJ,QAAR,IAAoB,mBAAxB,EAA6C;AAC9C,gBAAII,QAAQC,QAAR,IAAoB,2BAAaS,eAArC,EAAsD;AAClD,uBAAO7B,wBAAP;AACH;AACJ;AACD,eAAOV,2BAA2B4B,yBAA3B,CAAqDC,OAArD,CAAP;AACH,KAlC+B;AAmChCW,mCAA+B,uCAAUX,OAAV,EAAmB;AAC9C,YAAIY,mBAAmB,EAAvB;AACA,YAAIxC,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaC,MAAlD,KAA6DpB,gBAAgBM,QAAQa,cAAxB,CAAjE,EAA0G;AACtG,mBAAOrC,sBAAP;AACH,SAFD,MAGK,IAAIJ,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaX,cAAlD,CAAJ,EAAsE;AACvE,mBAAOvB,gCAAP;AACH,SAFI,MAGA,IAAGP,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaH,eAAlD,CAAH,EAAsE;AACvE,mBAAO5B,sCAAP;AACH,SAFI,MAGA,IAAIV,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaP,iBAAlD,CAAJ,EAA0E;AAC3EM,+BAAmB,0CAAnB;AACH,SAFI,MAGA,IAAIxC,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaN,kBAAlD,CAAJ,EAA2E;AAC5EK,+BAAmB,4CAAnB;AACH,SAFI,MAGA,IAAIxC,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaL,kBAAlD,CAAJ,EAA2E;AAC5EI,+BAAmB,2CAAnB;AACH,SAFI,MAGA,IAAIxC,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaJ,mBAAlD,CAAJ,EAA4E;AAC7EG,+BAAmB,8CAAnB;AACH,SAFI,MAGA,IAAIxC,aAAa4B,QAAQa,cAArB,EAAqC,2BAAaE,SAAlD,CAAJ,EAAkE;AACnEH,+BAAmB,uJAAnB;AACH,SAFI,MAGA;AACD,mBAAOzC,2BAA2BwC,6BAA3B,CAAyDX,OAAzD,CAAP;AACH;AACD,8CAAoCY,gBAApC;AACH,KAjE+B;AAkEhCI,6BAAyB,iCAAUhB,OAAV,EAAmB;AACxC,YAAMiB,SAASjB,QAAQK,MAAvB;AACA,YAAIL,QAAQJ,QAAR,IAAoB,SAApB,IAAiCqB,OAAOC,MAAP,GAAgB,CAArD,EAAwD;AACpD,gBAAIN,mBAAmB,EAAvB;AACA,gBAAIK,OAAOC,MAAP,IAAiB,CAAjB,IAAsB9C,aAAa6C,OAAO,CAAP,CAAb,EAAwB,2BAAaH,MAArC,CAA1B,EAAwE;AACpE,oBAAIK,cAAcF,OAAO,CAAP,CAAlB;AACAL,mCAAmB3B,kCAAkCkC,WAAlC,CAAnB;AACH,aAHD,MAGO,IAAIF,OAAOC,MAAP,GAAgB,CAApB,EAAuB;AAC1BN,mCAAmB3B,kCAAkCgC,OAAO,CAAP,CAAlC,CAAnB;AACH;AACD,uFAAyEL,gBAAzE;AACH,SATD,MASO,IAAIjB,eAAeK,QAAQJ,QAAvB,CAAJ,EAAsC;AACzC,mBAAOnB,8BAAP;AACH,SAFM,MAEA,IAAIuB,QAAQJ,QAAR,IAAoB,WAAxB,EAAqC;AACxC,gBAAIqB,OAAOC,MAAP,GAAgB,CAAhB,KAAsB9C,aAAa6C,OAAO,CAAP,CAAb,EAAwB,2BAAaX,iBAArC,KAA2DlC,aAAa6C,OAAO,CAAP,CAAb,EAAwB,2BAAaV,kBAArC,CAAjF,CAAJ,EAAgJ;AAC5I,uBAAOxB,wCAAP;AACH;AACD,mBAAOV,0BAAP;AACH;AACD,eAAOF,2BAA2B6C,uBAA3B,CAAmDhB,OAAnD,CAAP;AACH,KAtF+B;AAuFhCoB,2BAAuB,+BAAUpB,OAAV,EAAmB;AACtC,YAAIqB,aAAarB,QAAQK,MAAR,CAAea,MAAf,GAAwB,CAAxB,GAA4BlB,QAAQK,MAAR,CAAe,CAAf,CAA5B,GAAgD,IAAjE;AACA,YAAGL,QAAQJ,QAAR,IAAoB,SAAvB,EAAiC;AAC7B,gBAAGyB,cAAc3B,gBAAgB2B,UAAhB,CAAjB,EAA6C;AACzC,uBAAO7C,sBAAP;AACH,aAFD,MAEM,IAAG6C,cAAcjD,aAAaiD,UAAb,EAAyB,2BAAanB,cAAtC,CAAjB,EAAuE;AACzE,uBAAOvB,gCAAP;AACH;AACJ,SAND,MAOK,IAAIqB,QAAQJ,QAAR,IAAoB,kBAAxB,EAA4C;AAC7C,mBAAOvB,0BAAP;AACH,SAFI,MAGA,IAAI2B,QAAQJ,QAAR,IAAoB,UAAxB,EAAoC;AACrC,gBAAGyB,cAAc3B,gBAAgB2B,UAAhB,CAAjB,EAA6C;AACzC,uBAAOC,yBAAP;AACH;AACD,mBAAOtC,wCAAP;AACH,SALI,MAMA,IAAGgB,QAAQJ,QAAR,IAAoB,UAAvB,EAAmC;AACpC,mBAAOtB,uBAAP;AACH,SAFI,MAGA,IAAG+C,cAAcjD,aAAaiD,UAAb,EAAyB,2BAAaE,WAAtC,CAAjB,EAAoE;AACrE,mBAAOhD,sBAAP;AACH,SAFI,MAGA,IAAI8C,cAAcjD,aAAaiD,UAAb,EAAyB,2BAAalB,YAAtC,CAAlB,EAAuE;AACxE,mBAAO7B,uBAAP;AACH;AACD,eAAOH,2BAA2BiD,qBAA3B,CAAiDpB,OAAjD,CAAP;AACH;AAnH+B,CAApC;;AAsHAwB,OAAOC,OAAP,GAAiB;AACbC,iCAA6B5B;AADhB,CAAjB","file":"ArgdownErrorMessageProvider.js","sourcesContent":["import * as chevrotain from 'chevrotain';\nimport { ArgdownLexer } from './ArgdownLexer.js';\n//import * as _ from 'lodash';\n\nconst defaultParserErrorProvider = chevrotain.defaultParserErrorProvider\nconst tokenMatcher = chevrotain.tokenMatcher;\n//const EOF = chevrotain.EOF;\nconst MISSING_TEXT_CONTENT_ERROR = \"Missing text content. \"\n    + \"Please add a line of text or refer to an existing statement or argument instead by replacing the content in this line with [Statement Title] or <Argument Title> (without a colon). \"\n    + \"If you want to define a statement ([Statement Title]:) or argument (<Argument Title>:), the defining text content has to follow the defined element title without any empty lines in between.\";\nconst INVALID_INFERENCE_ERROR = \"Invalid inference. Inferences can either be marked by four hyphens (----) or have the following format: \"\n    + \"--Inference Rule 1, Inference Rule 2 (my meta data property 1: 1, 2, 3; my meta data property 2: value) --\";\nconst INVALID_METADATA_ERROR = \"Invalid metadata statement. Metadata has the following format: (my meta data property 1: 1, 2, 3; my meta data property 2: value)\";\nconst INVALID_RELATION_ERROR = \"Invalid relation syntax. This may either be caused by a) an invalid relation parent or b) invalid indentation. a) Invalid relation parent: Only statements and arguments can have relations as child elements. b) Invalid Indentation tree: Please check that if there are preceding relations in this paragraph, there is at least one with equal or less indentation.\";\nconst MISSING_RELATION_CONTENT_ERROR = \"Missing relation content. Please define or refer to a statement or argument (you can define a statement by simply adding a line of text).\";\nconst MISSING_INFERENCE_END_ERROR = \"Invalid inference syntax. Please end your inference with two hyphens (--)\";\nconst INVALID_INFERENCE_POSITION_ERROR = \"Invalid inference position. An inference may only occur within an argument reconstruction, in which it is preceded by a premise and followed by a conclusion (both of which have to be numbered statements: '(1) Statement').\";\nconst MISSING_INFERENCE_ERROR = \"Missing inference. Use four hyphens (----) between two numbered statements to insert an inference in your reconstruction and mark the latter statement as a conclusion.\";\nconst MISSING_CONCLUSION_ERROR = \"Missing conclusion. Please add a numbered statement after the inference.\";\nconst ARGUMENT_RECONSTRUCTION_POSITION_ERROR = \"Invalid position of argument reconstruction. Make sure the argument reconstruction is preceded by an empty line.\";\nconst INVALID_ARGUMENT_STATEMENT_CONTENT_ERROR = \"Invalid statement content. An argument reference (<Argument Title>) or definition (<Argument Title>:) can not be used as premise or conclusion within an argument reconstruction. Use statement references ([Statement Title]) or definitions ([Statement Title]:) instead.\";\nconst INCOMPLETE_ARGUMENT_RECONSTRUCTION_ERROR = \"Incomplete argument reconstruction. An argument reconstruction has to consist of at least one premise (a numbered statement: '(1) Statement Text'), one inference (marked by four hyphens ----) and one conclusion (a numbered statement after an inference). There may no be any empty lines between these elements.\";\n\nfunction GetParagraphStartTokenDescription(token) {\n    if (tokenMatcher(token, ArgdownLexer.OutgoingSupport)) {\n        return \"an outgoing support relation (+ or <+)\"\n    } else if (tokenMatcher(token, ArgdownLexer.IncomingSupport)) {\n        return \"an incoming support relation (+>)\"\n    } else if (tokenMatcher(token, ArgdownLexer.OutgoingAttack)) {\n        return \"an outgoing attack relation (- or <-)\"\n    } else if (tokenMatcher(token, ArgdownLexer.IncomingAttack)) {\n        return \"an incoming attack relation (->)\"\n    } else if (tokenMatcher(token, ArgdownLexer.Contradiction)) {\n        return \"a contradictory relation (><)\"\n    } else if (tokenMatcher(token, ArgdownLexer.IncomingUndercut)) {\n        return \"an incoming undercut relation (_>)\"\n    } else if (tokenMatcher(token, ArgdownLexer.OutgoingUndercut)) {\n        return \"an incoming undercut relation (<_)\"\n    }\n}\nfunction isRelationToken(token) {\n    return tokenMatcher(token, ArgdownLexer.IncomingSupport)\n        || tokenMatcher(token, ArgdownLexer.OutgoingSupport)\n        || tokenMatcher(token, ArgdownLexer.IncomingAttack)\n        || tokenMatcher(token, ArgdownLexer.OutgoingAttack)\n        || tokenMatcher(token, ArgdownLexer.IncomingUndercut)\n        || tokenMatcher(token, ArgdownLexer.OutgoingUndercut)\n        || tokenMatcher(token, ArgdownLexer.Contradiction);\n}\nfunction isRelationRule(ruleName) {\n    return ruleName.endsWith(\"Support\") || ruleName.endsWith(\"Attack\") || ruleName.endsWith(\"Undercut\") || ruleName == \"Contradiction\";\n}\nconst argdownErrorMessageProvider = {\n    buildMismatchTokenMessage: function (options) {\n        if (options.ruleName == \"inference\") {\n            if (options.expected == ArgdownLexer.InferenceStart) {\n                return MISSING_INFERENCE_ERROR;\n            } else if (options.expected == ArgdownLexer.InferenceEnd) {\n                return MISSING_INFERENCE_END_ERROR;\n            }\n        }\n        else if(options.ruleName == \"metadataStatement\"){\n            return INVALID_METADATA_ERROR;\n        }\n        else if(options.expected == ArgdownLexer.Dedent && (options.ruleName == \"statementRelations\" || options.ruleName == \"argumentRelations\")){\n            if (tokenMatcher(options.actual, ArgdownLexer.ArgumentReference)){\n                return \"Invalid relation text content. An argument reference (<Argument Title>) may not be preceded or followed by other content. If you want to start a new paragraph, insert an empty line before the reference. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }\n            else if(tokenMatcher(options.actual, ArgdownLexer.ArgumentDefinition)){\n                return \"Invalid relation text content. An argument definition (<Argument Title>:) may not be preceded by other content. If you want to start a new paragraph, insert an empty line before the definition. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }\n            else if (tokenMatcher(options.actual, ArgdownLexer.StatementReference)){\n                return \"Invalid relation text content. A statement reference ([Statement Title]) may not be preceded or followed by other content.  If you want to start a new paragraph, insert an empty line before the reference. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }\n            else if (tokenMatcher(options.actual, ArgdownLexer.StatementDefinition)) {\n                return \"Invalid relation text content. A statement definition ([Statement Title]:) may not be preceded by other content.  If you want to start a new paragraph, insert an empty line before the definition. If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";\n            }else{\n                return \"Invalid relation text content. Check that the content is not preceded by a statement reference ([Statement Title]) or argument reference (<Argument Title>). If you want to mention a statement or argument, without directly using it, use @[Statement Title] or @<Argument Title>.\";                \n            }\n        }\n        else if (options.ruleName == \"argumentStatement\") {\n            if (options.expected == ArgdownLexer.StatementNumber) {\n                return MISSING_CONCLUSION_ERROR;\n            }\n        }\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options)\n    },\n    buildNotAllInputParsedMessage: function (options) {\n        var tokenDescription = \"\";\n        if (tokenMatcher(options.firstRedundant, ArgdownLexer.Indent) || isRelationToken(options.firstRedundant)) {\n            return INVALID_RELATION_ERROR;\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.InferenceStart)){\n            return INVALID_INFERENCE_POSITION_ERROR;\n        }\n        else if(tokenMatcher(options.firstRedundant, ArgdownLexer.StatementNumber)){\n            return ARGUMENT_RECONSTRUCTION_POSITION_ERROR;            \n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.ArgumentReference)) {\n            tokenDescription = \"An argument reference (<Argument Title>)\";\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.ArgumentDefinition)) {\n            tokenDescription = \"An argument definition (<Argument Title>:)\";\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementReference)) {\n            tokenDescription = \"A statement reference ([Statement Title])\";\n        }\n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.StatementDefinition)) {\n            tokenDescription = \"A statement  definition ([Statement Title]:)\";\n        } \n        else if (tokenMatcher(options.firstRedundant, ArgdownLexer.Freestyle)) {\n            tokenDescription = \"Invalid position of text content. Make sure it is not preceded by a statement reference ([Statement Title]) or argument reference (<Argument Title>).\";\n        } \n        else {\n            return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\n        }\n        return `Invalid element position. ${tokenDescription} may only occur at the beginning of a line or after a relation symbol.`;\n    },\n    buildNoViableAltMessage: function (options) {\n        const tokens = options.actual;\n        if (options.ruleName == \"argdown\" && tokens.length > 0) {\n            let tokenDescription = \"\";\n            if (tokens.length >= 2 && tokenMatcher(tokens[0], ArgdownLexer.Indent)) {\n                let secondToken = tokens[1];\n                tokenDescription = GetParagraphStartTokenDescription(secondToken);\n            } else if (tokens.length > 0) {\n                tokenDescription = GetParagraphStartTokenDescription(tokens[0]);\n            }\n            return `Invalid paragraph start. Argdown paragraphs may not start with ${tokenDescription}. If you do not want to start a new paragraph, remove any empty lines above this one. If you do want to start a new paragraph, try starting with normal text, a statement title, argument title or a list item (using * for unordered or 1. for ordered lists).`;\n        } else if (isRelationRule(options.ruleName)) {\n            return MISSING_RELATION_CONTENT_ERROR;\n        } else if (options.ruleName == \"statement\") {\n            if (tokens.length > 0 && (tokenMatcher(tokens[0], ArgdownLexer.ArgumentReference) || tokenMatcher(tokens[0], ArgdownLexer.ArgumentDefinition))) {\n                return INVALID_ARGUMENT_STATEMENT_CONTENT_ERROR;\n            }\n            return MISSING_TEXT_CONTENT_ERROR;\n        }\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\n    },\n    buildEarlyExitMessage: function (options) {\n        var firstToken = options.actual.length > 0 ? options.actual[0] : null;\n        if(options.ruleName == \"argdown\"){\n            if(firstToken && isRelationToken(firstToken)){\n                return INVALID_RELATION_ERROR;\n            }else if(firstToken && tokenMatcher(firstToken, ArgdownLexer.InferenceStart)){\n                return INVALID_INFERENCE_POSITION_ERROR;\n            }\n        }\n        else if (options.ruleName == \"statementContent\") {\n            return MISSING_TEXT_CONTENT_ERROR;\n        }\n        else if (options.ruleName == \"argument\") {\n            if(firstToken && isRelationToken(firstToken)){\n                return INVALID_INDENTATION_ERROR;\n            }\n            return INCOMPLETE_ARGUMENT_RECONSTRUCTION_ERROR;\n        }\n        else if(options.ruleName == \"metadata\") {\n            return INVALID_INFERENCE_ERROR;\n        }\n        else if(firstToken && tokenMatcher(firstToken, ArgdownLexer.MetadataEnd)){\n            return INVALID_METADATA_ERROR;\n        }\n        else if (firstToken && tokenMatcher(firstToken, ArgdownLexer.InferenceEnd)) {\n            return INVALID_INFERENCE_ERROR;\n        }\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\n    }\n}\n\nmodule.exports = {\n    ArgdownErrorMessageProvider: argdownErrorMessageProvider\n};"]}