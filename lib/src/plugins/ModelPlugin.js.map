{"version":3,"sources":["../../../src/plugins/ModelPlugin.js"],"names":["_","RelationObjectTypes","Object","freeze","STATEMENT","Symbol","RECONSTRUCTED_ARGUMENT","SKETCHED_ARGUMENT","ModelPlugin","request","model","defaultsDeep","getSettings","defaults","response","relations","relation","fromType","getElementType","from","toType","to","argument","index","indexOf","splice","conclusionStatement","pcs","length","equivalenceClass","statements","title","relationExists","existingRelation","type","push","status","obj","config","defaultSettings","removeTagsFromText","name","$","statementReferencePattern","statementDefinitionPattern","statementMentionPattern","argumentReferencePattern","argumentDefinitionPattern","argumentMentionPattern","linkPattern","tagPattern","uniqueTitleCounter","getUniqueTitle","getEquivalenceClass","ec","currentStatement","currentStatementOrArgument","currentArgument","currentArgumentReconstruction","currentInference","rangesStack","parentsStack","currentRelation","inStatementTree","currentHeading","currentSection","sectionCounter","onArgdownEntry","arguments","sections","tags","onStatementEntry","node","parentNode","isRootOfStatementTree","isChildOfStatementTree","statement","onStatementExit","startLine","startColumn","endLine","endColumn","addTags","isEmpty","text","section","members","isUsedAsRootOfStatementTree","isUsedAsChildOfStatementTree","onStatementDefinitionEntry","match","exec","image","onStatementReferenceEntry","onStatementMentionExit","target","trailingWhitespace","range","start","stop","ranges","updateArgument","object","union","onArgumentDefinitionEntry","role","descriptions","onArgumentDefinitionExit","description","last","onArgumentReferenceEntry","onArgumentReferenceExit","onArgumentMentionExit","onFreestyleTextEntry","children","child","EscapedChar","substring","onLinkEntry","linkRange","url","onTagEntry","tag","settings","tagRange","onBoldEntry","boldRange","onBoldExit","boldEnd","pop","onItalicEntry","italicRange","onItalicExit","italicEnd","onRelationExit","contentNode","content","getRelationTarget","onIncomingSupportEntry","onIncomingAttackEntry","onOutgoingSupportEntry","onOutgoingAttackEntry","onContradictionEntry","onIncomingUndercutEntry","onOutgoingUndercutEntry","onRelationsEntry","statementOrArgument","onRelationsExit","onArgumentEntry","childIndex","precedingSibling","Emptyline","onArgumentExit","onArgumentStatementExit","statementNode","isUsedAsConclusion","inference","isUsedAsPremise","statementNr","onInferenceEntry","inferenceRules","metaData","onInferenceRulesExit","trim","onMetadataStatementExit","key","value","i","onHeadingEntry","onHeadingExit","headingStart","level","sectionId","newSection","heading","parentSection","parent","argdownListeners","argdownEntry","headingEntry","headingExit","statementEntry","statementExit","argumentEntry","argumentExist","argumentStatementExit","inferenceEntry","inferenceRulesExit","metadataStatementExit","StatementDefinitionEntry","StatementReferenceEntry","StatementMentionExit","ArgumentDefinitionEntry","ArgumentReferenceEntry","ArgumentMentionExit","argumentDefinitionExit","argumentReferenceExit","incomingSupportEntry","incomingSupportExit","incomingAttackEntry","incomingAttackExit","outgoingSupportEntry","outgoingSupportExit","outgoingAttackEntry","outgoingAttackExit","contradictionEntry","contradictionExit","outgoingUndercutEntry","outgoingUndercutExit","incomingUndercutEntry","incomingUndercutExit","relationsEntry","relationsExit","freestyleTextEntry","italicEntry","italicExit","boldEntry","boldExit","LinkEntry","TagEntry","keys","statementKey","console","log","argumentKey","module","exports"],"mappings":"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","file":"ModelPlugin.js","sourcesContent":["import * as _ from \"lodash\";\nimport { Statement } from \"../model/Statement.js\";\nimport { Argument } from \"../model/Argument.js\";\nimport { Relation } from \"../model/Relation.js\";\nimport { Section } from \"../model/Section.js\";\nimport { EquivalenceClass } from \"../model/EquivalenceClass.js\";\nimport { tokenMatcher } from \"chevrotain\";\nimport { ArgdownLexer } from \"./../ArgdownLexer.js\";\n\nconst RelationObjectTypes = Object.freeze({\n  STATEMENT: Symbol(\"STATEMENT\"),\n  RECONSTRUCTED_ARGUMENT: Symbol(\"RECONSTRUCTED ARGUMENT\"),\n  SKETCHED_ARGUMENT: Symbol(\"SKETCHED ARGUMENT\")\n});\n\nclass ModelPlugin {\n  getSettings(request) {\n    if (!request.model) {\n      request.model = {};\n    }\n    return request.model;\n  }\n  prepare(request) {\n    _.defaultsDeep(this.getSettings(request), this.defaults);\n  }\n  run(request, response) {\n    if (response.relations) {\n      for (let relation of response.relations) {\n        let fromType = this.getElementType(relation.from);\n        let toType = this.getElementType(relation.to);\n\n        // For reconstructed arguments: change outgoing argument relations\n        // to outgoing relations of the main conclusion, removing duplicates\n        if (fromType == RelationObjectTypes.RECONSTRUCTED_ARGUMENT) {\n          //change relation.from to point to the argument's conclusion\n          let argument = relation.from;\n\n          //remove from argument\n          let index = _.indexOf(argument.relations, relation);\n          argument.relations.splice(index, 1);\n\n          let conclusionStatement = argument.pcs[relation.from.pcs.length - 1];\n          let equivalenceClass = response.statements[conclusionStatement.title];\n          //change to relation of main conclusion\n          relation.from = equivalenceClass;\n\n          //check if this relation already exists\n          let relationExists = false;\n          for (let existingRelation of equivalenceClass.relations) {\n            if (\n              relation.to == existingRelation.to &&\n              relation.type == existingRelation.type\n            ) {\n              relationExists = true;\n              break;\n            }\n          }\n          if (!relationExists) {\n            equivalenceClass.relations.push(relation);\n          } else {\n            //remove relation from target\n            let index = _.indexOf(relation.to.relations, relation);\n            relation.to.relations.splice(index, 1);\n            //remove relation from relations\n            index = _.indexOf(response.relations, relation);\n            response.relations.splice(index, 1);\n          }\n        }\n        //Add relation status: \"Reconstructed\" for statement-to-statement relations, \"sketched\" for all others\n        if (\n          fromType == RelationObjectTypes.SKETCHED_ARGUMENT ||\n          toType == RelationObjectTypes.RECONSTRUCTED_ARGUMENT ||\n          toType == RelationObjectTypes.SKETCHED_ARGUMENT\n        ) {\n          relation.status = \"sketched\";\n        } else if (\n          fromType == RelationObjectTypes.STATEMENT ||\n          fromType == RelationObjectTypes.RECONSTRUCTED_ARGUMENT\n        ) {\n          relation.status = \"reconstructed\";\n        }\n      }\n      //Change dialectical types of statement-to-statement relations to semantic types\n      //Doing this in a separate loop makes it easier to identify duplicates in the previous loop,\n      //even though it is less efficient.\n      for (let relation of response.relations) {\n        if (relation.status == \"sketched\") {\n          continue;\n        }\n        if (relation.type == \"support\") {\n          relation.type = \"entails\";\n        } else if (relation.type == \"attack\") {\n          relation.type = \"contrary\";\n        }\n      }\n    }\n\n    return response;\n  }\n  getElementType(obj) {\n    if (obj instanceof Argument) {\n      if (obj.pcs && obj.pcs.length > 0) {\n        return RelationObjectTypes.RECONSTRUCTED_ARGUMENT;\n      } else {\n        return RelationObjectTypes.SKETCHED_ARGUMENT;\n      }\n    } else if (obj instanceof EquivalenceClass) {\n      return RelationObjectTypes.STATEMENT;\n    }\n    return null;\n  }\n  constructor(config) {\n    let defaultSettings = {\n      removeTagsFromText: false\n    };\n    this.defaults = _.defaultsDeep({}, config, defaultSettings);\n    this.name = \"ModelPlugin\";\n    let $ = this;\n\n    const statementReferencePattern = /\\[(.+)\\]/;\n    const statementDefinitionPattern = /\\[(.+)\\]\\:/;\n    const statementMentionPattern = /\\@\\[(.+)\\](\\s?)/;\n    const argumentReferencePattern = /\\<(.+)\\>/;\n    const argumentDefinitionPattern = /\\<(.+)\\>\\:/;\n    const argumentMentionPattern = /\\@\\<(.+)\\>(\\s?)/;\n    // const statementReferenceByNumberPattern = /\\<(.+)\\>\\((.+)\\)/;\n    // const statementDefinitionByNumberPattern = /\\<(.+)\\>\\((.+)\\)\\:/;\n    // const statementMentionByNumberPattern = /\\@\\<(.+)\\>\\((.+)\\)/;\n    const linkPattern = /\\[(.+)\\]\\((.+)\\)/;\n    const tagPattern = /#(?:\\(([^\\)]+)\\)|([a-zA-z0-9-\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+))/;\n\n    let uniqueTitleCounter = 0;\n    function getUniqueTitle() {\n      uniqueTitleCounter++;\n      return \"Untitled \" + uniqueTitleCounter;\n    }\n    function getEquivalenceClass(response, title) {\n      if (!title) {\n        return null;\n      }\n      let ec = null;\n      ec = response.statements[title];\n      if (!ec) {\n        ec = new EquivalenceClass();\n        ec.title = title;\n        response.statements[title] = ec;\n      }\n      return ec;\n    }\n\n    let currentStatement = null;\n    let currentStatementOrArgument = null;\n    let currentArgument = null;\n    let currentArgumentReconstruction = null;\n    let currentInference = null;\n    let rangesStack = [];\n    let parentsStack = [];\n    let currentRelation = null;\n    let inStatementTree = false;\n    let currentHeading = null;\n    let currentSection = null;\n    let sectionCounter = 0;\n\n    function onArgdownEntry(request, response) {\n      if (request.model) {\n        $.config = request.model;\n      }\n      response.statements = {};\n      response.arguments = {};\n      response.sections = [];\n      response.relations = [];\n      response.tags = [];\n      uniqueTitleCounter = 0;\n      currentHeading = null;\n      currentSection = null;\n      currentStatementOrArgument = null;\n      currentArgumentReconstruction = null;\n      currentInference = null;\n      currentArgument = null;\n      rangesStack = [];\n      parentsStack = [];\n      currentRelation = null;\n      inStatementTree = false;\n      sectionCounter = 0;\n    }\n    function onStatementEntry(request, response, node, parentNode) {\n      currentStatement = new Statement();\n      if (parentNode.name == \"argdown\") {\n        currentStatement.isRootOfStatementTree = true;\n        inStatementTree = true;\n      } else if (inStatementTree) {\n        currentStatement.isChildOfStatementTree = true;\n      }\n      currentStatementOrArgument = currentStatement;\n      node.statement = currentStatement;\n    }\n    function onStatementExit(request, response, node) {\n      let statement = node.statement;\n      statement.startLine = node.startLine;\n      statement.startColumn = node.startColumn;\n      statement.endLine = node.endLine;\n      statement.endColumn = node.endColumn;\n      if (!statement.title || statement.title == \"\") {\n        statement.title = getUniqueTitle();\n      }\n      if (statement.isRootOfStatementTree) {\n        inStatementTree = false;\n      }\n      // //If we are in an argument reconstruction, we have to get argument title and statement number\n      // //getEquivalenceClass will look for equivalenceClasses that were already defined by using a reference to this argumentStatement\n\n      // if (currentArgumentReconstruction && !currentRelation) {\n      //   node.argumentTitle = currentArgumentReconstruction.title;\n      //   node.statementNumber = currentArgumentReconstruction.pcs.length + 1;\n      // }\n      let equivalenceClass = getEquivalenceClass(response, statement.title);\n      node.equivalenceClass = equivalenceClass;\n      if (statement.tags) {\n        addTags(statement.tags, equivalenceClass);\n      }\n      if (!_.isEmpty(statement.text)) {\n        if (currentSection) {\n          statement.section = currentSection;\n        }\n        equivalenceClass.members.push(statement);\n      }\n      if (statement.isRootOfStatementTree) {\n        equivalenceClass.isUsedAsRootOfStatementTree = true; //members are used outside of argument reconstructions (not as premise or conclusion)\n      } else if (statement.isChildOfStatementTree) {\n        equivalenceClass.isUsedAsChildOfStatementTree = true;\n      }\n      currentStatement = null;\n    }\n    function onStatementDefinitionEntry(request, response, node, parentNode) {\n      let match = statementDefinitionPattern.exec(node.image);\n      if (match != null) {\n        currentStatement.title = match[1];\n        node.title = currentStatement.title;\n        parentNode.statement = currentStatement;\n      }\n    }\n    // function onStatementDefinitionByNumberEntry(node){\n    //   let match = statementDefinitionByNumberPattern.exec(node.image);\n    //   if (match != null) {\n    //     node.statementUsedInArgument = match[1];\n    //     node.statementNumber = match[2];\n    //     node.statement = currentStatement;\n    //   }\n    // }\n    function onStatementReferenceEntry(request, response, node, parentNode) {\n      let match = statementReferencePattern.exec(node.image);\n      if (match != null) {\n        currentStatement.title = match[1];\n        node.title = currentStatement.title;\n        parentNode.statement = currentStatement;\n      }\n    }\n    // function onStatementReferenceByNumberEntry(node) {\n    //   let match = statementReferenceByNumberPattern.exec(node.image);\n    //   if (match != null) {\n    //     node.statementUsedInArgument = match[1];\n    //     node.statementNumber = match[2];\n    //     node.statement = currentStatement;\n    //   }\n    // }\n    function onStatementMentionExit(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      let match = statementMentionPattern.exec(node.image);\n      if (match) {\n        node.title = match[1];\n        if (node.image[node.image.length - 1] == \" \") {\n          node.trailingWhitespace = \" \";\n        } else {\n          node.trailingWhitespace = \"\";\n        }\n        if (target) {\n          let range = {\n            type: \"statement-mention\",\n            title: node.title,\n            start: target.text.length\n          };\n          target.text += node.image;\n          range.stop = target.text.length - 1;\n          target.ranges.push(range);\n        }\n      }\n    }\n    // function onStatementMentionByNumberExit(node) {\n    //   const target = (currentHeading) ? currentHeading : currentStatement;\n    //   let match = statementMentionByNumberPattern.exec(node.image);\n    //   if (match) {\n    //     node.argumentTitle = match[1];\n    //     node.statementNumber = match[2];\n    //     if (node.image[node.image.length - 1] == \" \") {\n    //       node.trailingWhitespace = ' ';\n    //     } else {\n    //       node.trailingWhitespace = '';\n    //     }\n    //     if (target) {\n    //       let range = { type: 'statement-mention-by-number', argumentTitle: node.title, statementNumber: node.statementNumber, start: target.text.length };\n    //       target.text += node.image;\n    //       range.stop = target.text.length - 1;\n    //       target.ranges.push(range);\n    //     }\n    //   }\n    // }\n    function updateArgument(response, title) {\n      if (title) {\n        currentArgument = response.arguments[title];\n      }\n      if (!title || !currentArgument) {\n        currentArgument = new Argument();\n        if (!title) {\n          currentArgument.title = getUniqueTitle();\n        } else {\n          currentArgument.title = title;\n        }\n        response.arguments[currentArgument.title] = currentArgument;\n      }\n      currentStatementOrArgument = currentArgument;\n      return currentArgument;\n    }\n    function addTags(tags, object) {\n      if (!object.tags) {\n        object.tags = [];\n      }\n      object.tags = _.union(object.tags, tags);\n    }\n    function onArgumentDefinitionEntry(request, response, node, parentNode) {\n      let match = argumentDefinitionPattern.exec(node.image);\n      if (match != null) {\n        let title = match[1];\n        updateArgument(response, title);\n        currentStatement = new Statement();\n        currentStatement.role = \"argument-description\";\n        if (currentSection) {\n          currentStatement.section = currentSection;\n        }\n        currentArgument.descriptions.push(currentStatement);\n        node.title = title;\n        parentNode.argument = currentArgument;\n      }\n    }\n    function onArgumentDefinitionExit(request, response, node) {\n      if (node.argument) {\n        let description = _.last(node.argument.descriptions);\n        if (description.tags) {\n          addTags(description.tags, node.argument);\n        }\n      }\n      currentStatement = null;\n      currentArgument = null;\n    }\n    function onArgumentReferenceEntry(request, response, node, parentNode) {\n      let match = argumentReferencePattern.exec(node.image);\n      if (match != null) {\n        let title = match[1];\n        updateArgument(response, title);\n        node.title = title;\n        parentNode.argument = currentArgument;\n      }\n    }\n    function onArgumentReferenceExit() {\n      currentStatement = null;\n      currentArgument = null;\n    }\n    function onArgumentMentionExit(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      let match = argumentMentionPattern.exec(node.image);\n      if (match) {\n        node.title = match[1];\n        if (node.image[node.image.length - 1] == \" \") {\n          node.trailingWhitespace = \" \";\n        } else {\n          node.trailingWhitespace = \"\";\n        }\n        if (target) {\n          let range = {\n            type: \"argument-mention\",\n            title: node.title,\n            start: target.text.length\n          };\n          target.text += node.image;\n          range.stop = target.text.length - 1;\n          target.ranges.push(range);\n        }\n      }\n    }\n    function onFreestyleTextEntry(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      node.text = \"\";\n      for (let child of node.children) {\n        if (tokenMatcher(child, ArgdownLexer.EscapedChar)) {\n          node.text += child.image.substring(1, child.image.length);\n        } else {\n          node.text += child.image;\n        }\n      }\n      if (target) {\n        target.text += node.text;\n      }\n    }\n    function onLinkEntry(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      if (!target) {\n        return;\n      }\n      let match = linkPattern.exec(node.image);\n      let linkRange = { type: \"link\", start: target.text.length };\n      node.url = match[2];\n      node.text = match[1];\n      target.text += node.text;\n      linkRange.stop = target.text.length - 1;\n      linkRange.url = node.url;\n      target.ranges.push(linkRange);\n      if (node.image[node.image.length - 1] == \" \") {\n        target.text += \" \";\n        node.trailingWhitespace = \" \";\n      } else {\n        node.trailingWhitespace = \"\";\n      }\n    }\n    function onTagEntry(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      if (!target) {\n        return;\n      }\n      let match = tagPattern.exec(node.image);\n      let tag = match[1] || match[2];\n      const settings = $.getSettings(request);\n      node.tag = tag;\n      if (!settings.removeTagsFromText) {\n        let tagRange = { type: \"tag\", start: target.text.length };\n        node.text = node.image;\n        target.text += node.text;\n        tagRange.stop = target.text.length - 1;\n        tagRange.tag = node.tag;\n        target.ranges.push(tagRange);\n      }\n      target.tags = target.tags || [];\n      let tags = target.tags;\n      if (target.tags.indexOf(tag) == -1) {\n        tags.push(tag);\n      }\n      if (response.tags.indexOf(tag) == -1) {\n        response.tags.push(tag);\n      }\n    }\n    function onBoldEntry() {\n      const target = currentHeading ? currentHeading : currentStatement;\n      if (!target) {\n        return;\n      }\n      let boldRange = { type: \"bold\", start: target.text.length };\n      rangesStack.push(boldRange);\n      target.ranges.push(boldRange);\n    }\n    function onBoldExit(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      if (!target) {\n        return;\n      }\n      let boldEnd = _.last(node.children);\n      if (boldEnd.image[boldEnd.image.length - 1] == \" \") {\n        target.text += \" \";\n        node.trailingWhitespace = \" \";\n      } else {\n        node.trailingWhitespace = \"\";\n      }\n      let range = _.last(rangesStack);\n      range.stop = target.text.length - 1;\n      rangesStack.pop();\n    }\n    function onItalicEntry() {\n      const target = currentHeading ? currentHeading : currentStatement;\n      if (!target) {\n        return;\n      }\n      let italicRange = { type: \"italic\", start: target.text.length };\n      rangesStack.push(italicRange);\n      target.ranges.push(italicRange);\n    }\n    function onItalicExit(request, response, node) {\n      const target = currentHeading ? currentHeading : currentStatement;\n      if (!target) {\n        return;\n      }\n      let italicEnd = _.last(node.children);\n      if (italicEnd.image[italicEnd.image.length - 1] == \" \") {\n        target.text += \" \";\n        node.trailingWhitespace = \" \";\n      } else {\n        node.trailingWhitespace = \"\";\n      }\n      let range = _.last(rangesStack);\n      range.stop = target.text.length - 1;\n      rangesStack.pop();\n    }\n\n    function onRelationExit(request, response, node) {\n      let relation = node.relation;\n      let contentNode = node.children[1];\n      let content = contentNode.argument || contentNode.statement;\n      let target = getRelationTarget(response, content);\n      if (relation) {\n        if (relation.from) {\n          relation.to = target;\n        } else {\n          relation.from = target;\n        }\n        let relationExists = false;\n        for (let existingRelation of relation.from.relations) {\n          if (\n            relation.to == existingRelation.to &&\n            relation.type == existingRelation.type\n          ) {\n            relationExists = true;\n            break;\n          } else if (\n            relation.type == \"contradictory\" &&\n            relation.type == existingRelation.type &&\n            relation.from == existingRelation.to &&\n            relation.to == existingRelation.from\n          ) {\n            relationExists = true;\n            break;\n          }\n        }\n        if (!relationExists) {\n          response.relations.push(relation);\n          relation.from.relations.push(relation);\n          relation.to.relations.push(relation);\n        }\n      }\n    }\n    function onIncomingSupportEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"support\", node);\n      currentRelation.from = target;\n      node.relation = currentRelation;\n    }\n    function onIncomingAttackEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"attack\");\n      currentRelation.from = target;\n      node.relation = currentRelation;\n    }\n    function onOutgoingSupportEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"support\");\n      currentRelation.to = target;\n      node.relation = currentRelation;\n    }\n    function onOutgoingAttackEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"attack\");\n      currentRelation.to = target;\n      node.relation = currentRelation;\n    }\n    function onContradictionEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"contradictory\");\n      currentRelation.from = target;\n      node.relation = currentRelation;\n    }\n    function onIncomingUndercutEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"undercut\");\n      currentRelation.from = target;\n      node.relation = currentRelation;\n    }\n    function onOutgoingUndercutEntry(request, response, node) {\n      let target = _.last(parentsStack);\n      currentRelation = new Relation(\"undercut\");\n      currentRelation.to = target;\n      node.relation = currentRelation;\n    }\n\n    function onRelationsEntry(request, response) {\n      parentsStack.push(\n        getRelationTarget(response, currentStatementOrArgument)\n      );\n    }\n    function getRelationTarget(response, statementOrArgument) {\n      let target = statementOrArgument;\n      if (statementOrArgument instanceof Statement) {\n        if (!statementOrArgument.title)\n          statementOrArgument.title = getUniqueTitle();\n        target = getEquivalenceClass(response, statementOrArgument.title);\n      }\n      return target;\n    }\n    function onRelationsExit() {\n      currentRelation = null;\n      parentsStack.pop();\n    }\n\n    function onArgumentEntry(request, response, node, parentNode, childIndex) {\n      let argument = null;\n      if (childIndex > 0) {\n        let precedingSibling = parentNode.children[childIndex - 1];\n        if (\n          precedingSibling.name == \"argumentReference\" ||\n          precedingSibling.name == \"argumentDefinition\"\n        ) {\n          argument = precedingSibling.argument;\n        } else if (tokenMatcher(precedingSibling, ArgdownLexer.Emptyline)) {\n          precedingSibling = parentNode.children[childIndex - 2];\n          if (\n            precedingSibling.name == \"argumentReference\" ||\n            precedingSibling.name == \"argumentDefinition\"\n          ) {\n            argument = precedingSibling.argument;\n          }\n        }\n      }\n      if (!argument) {\n        argument = updateArgument(response);\n      }\n      if (currentSection) {\n        argument.section = currentSection;\n      }\n      //if there is a previous reconstruction, overwrite it\n      if (argument.pcs.length > 0) {\n        //TODO: throw error\n        argument.pcs = [];\n      }\n      node.argument = argument;\n      currentArgumentReconstruction = argument;\n    }\n    function onArgumentExit(request, response, node) {\n      const argument = node.argument;\n      argument.startLine = node.startLine;\n      argument.startColumn = node.startColumn;\n      argument.endLine = node.endLine;\n      argument.endColumn = node.endColumn;\n      currentStatement = null;\n      currentArgument = null;\n      currentArgumentReconstruction = null;\n    }\n    function onArgumentStatementExit(\n      request,\n      response,\n      node,\n      parentNode,\n      childIndex\n    ) {\n      if (node.children.length > 1) {\n        //first node is ArgdownLexer.ArgumentStatementStart\n        let statementNode = node.children[1];\n        let statement = statementNode.statement;\n        let ec = getEquivalenceClass(response, statement.title);\n        statement.role = \"premise\";\n        if (childIndex > 0) {\n          let precedingSibling = parentNode.children[childIndex - 1];\n          if (precedingSibling.name == \"inference\") {\n            statement.role = \"conclusion\";\n            ec.isUsedAsConclusion = true;\n            statement.inference = precedingSibling.inference;\n          }\n        }\n        if (statement.role == \"premise\") {\n          ec.isUsedAsPremise = true;\n        }\n        currentArgumentReconstruction.pcs.push(statement);\n        node.statement = statement;\n        node.statementNr = currentArgumentReconstruction.pcs.length;\n      }\n    }\n    function onInferenceEntry(request, response, node) {\n      currentInference = {\n        inferenceRules: [],\n        metaData: {},\n        startLine: node.startLine,\n        startColumn: node.startColumn,\n        endLine: node.endLine,\n        endColumn: node.endColumn\n      };\n      node.inference = currentInference;\n    }\n    function onInferenceRulesExit(request, response, node) {\n      for (let child of node.children) {\n        if (child.name == \"freestyleText\") {\n          currentInference.inferenceRules.push(child.text.trim());\n        }\n      }\n    }\n    function onMetadataStatementExit(request, response, node) {\n      let key = node.children[0].text;\n      let value = null;\n      if (node.children.length == 2) {\n        value = node.children[1].text;\n      } else {\n        value = [];\n        for (let i = 1; i < node.children.length; i++) {\n          value.push(node.children[i].text);\n        }\n      }\n      currentInference.metaData[key] = value;\n    }\n    function onHeadingEntry(request, response, node) {\n      currentHeading = node;\n      currentHeading.text = \"\";\n      currentHeading.ranges = [];\n    }\n    function onHeadingExit(request, response, node) {\n      let headingStart = node.children[0];\n      currentHeading.level = headingStart.image.length - 1; //number of # - whitespace\n      sectionCounter++;\n      let sectionId = \"s\" + sectionCounter;\n      let newSection = new Section(\n        sectionId,\n        currentHeading.level,\n        currentHeading.text,\n        currentHeading.ranges,\n        currentHeading.tags\n      );\n      newSection.startLine = node.startLine;\n      newSection.startColumn = node.startColumn;\n      newSection.heading = currentHeading;\n\n      if (newSection.level > 1 && currentSection) {\n        let parentSection = currentSection;\n        while (\n          parentSection.parent &&\n          parentSection.level >= newSection.level\n        ) {\n          parentSection = parentSection.parent;\n        }\n        parentSection.children.push(newSection);\n        newSection.parent = parentSection;\n      } else {\n        response.sections.push(newSection);\n      }\n      currentSection = newSection;\n      currentHeading = null;\n    }\n\n    this.argdownListeners = {\n      argdownEntry: onArgdownEntry,\n      headingEntry: onHeadingEntry,\n      headingExit: onHeadingExit,\n      statementEntry: onStatementEntry,\n      statementExit: onStatementExit,\n      argumentEntry: onArgumentEntry,\n      argumentExist: onArgumentExit,\n      argumentStatementExit: onArgumentStatementExit,\n      inferenceEntry: onInferenceEntry,\n      inferenceRulesExit: onInferenceRulesExit,\n      metadataStatementExit: onMetadataStatementExit,\n      StatementDefinitionEntry: onStatementDefinitionEntry,\n      // StatementDefinitionByNumberEntry : onStatementDefinitionByNumberEntry,\n      StatementReferenceEntry: onStatementReferenceEntry,\n      // StatementReferenceByNumberEntry : onStatementReferenceByNumberEntry,\n      StatementMentionExit: onStatementMentionExit,\n      // StatementMentionByNumberExit : onStatementMentionByNumberExit,\n      ArgumentDefinitionEntry: onArgumentDefinitionEntry,\n      ArgumentReferenceEntry: onArgumentReferenceEntry,\n      ArgumentMentionExit: onArgumentMentionExit,\n      argumentDefinitionExit: onArgumentDefinitionExit,\n      argumentReferenceExit: onArgumentReferenceExit,\n      incomingSupportEntry: onIncomingSupportEntry,\n      incomingSupportExit: onRelationExit,\n      incomingAttackEntry: onIncomingAttackEntry,\n      incomingAttackExit: onRelationExit,\n      outgoingSupportEntry: onOutgoingSupportEntry,\n      outgoingSupportExit: onRelationExit,\n      outgoingAttackEntry: onOutgoingAttackEntry,\n      outgoingAttackExit: onRelationExit,\n      contradictionEntry: onContradictionEntry,\n      contradictionExit: onRelationExit,\n      outgoingUndercutEntry: onOutgoingUndercutEntry,\n      outgoingUndercutExit: onRelationExit,\n      incomingUndercutEntry: onIncomingUndercutEntry,\n      incomingUndercutExit: onRelationExit,\n      relationsEntry: onRelationsEntry,\n      relationsExit: onRelationsExit,\n      freestyleTextEntry: onFreestyleTextEntry,\n      italicEntry: onItalicEntry,\n      italicExit: onItalicExit,\n      boldEntry: onBoldEntry,\n      boldExit: onBoldExit,\n      LinkEntry: onLinkEntry,\n      TagEntry: onTagEntry\n    };\n  }\n  logRelations(response) {\n    for (let statementKey of Object.keys(response.statements)) {\n      let statement = response.statements[statementKey];\n      for (let relation of statement.relations) {\n        if (relation.from == statement) {\n          console.log(\n            \"Relation from: \" +\n              relation.from.title +\n              \" to: \" +\n              relation.to.title +\n              \" type: \" +\n              relation.type\n          );\n        }\n      }\n    }\n    for (let argumentKey of Object.keys(response.arguments)) {\n      let argument = response.arguments[argumentKey];\n      for (let relation of argument.relations) {\n        if (relation.from == argument) {\n          console.log(\n            \"Relation from: \" +\n              relation.from.title +\n              \" to: \" +\n              relation.to.title +\n              \" type: \" +\n              relation.type\n          );\n        }\n      }\n    }\n  }\n}\nmodule.exports = {\n  ModelPlugin: ModelPlugin,\n  RelationObjectTypes: RelationObjectTypes\n};\n"]}