{"version":3,"sources":["../../../src/plugins/MapMaker.js"],"names":["MapMaker","name","data","map","makeMap","nodes","relations","nodeCount","statementNodes","argumentNodes","statementKeys","Object","keys","statements","statementKey","equivalenceClass","length","isUsedAsThesis","isUsedInArgument","id","node","type","title","push","relation","from","argumentKeys","arguments","statementRoles","argumentKey","argument","pcs","statement","roles","premiseIn","conclusionIn","role","froms","tos","fromNode","toNode","to","module","exports"],"mappings":"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","file":"MapMaker.js","sourcesContent":["import {Argument} from '../model/Argument.js';\n\nclass MapMaker{\n  constructor(){\n    this.name = \"MapMaker\";\n  }\n  run(data){\n    data.map = this.makeMap(data);\n    return data;\n  }\n  makeMap(data){\n    let map = {nodes: [], relations: []};\n    let nodeCount = 0;\n    let relations = [];\n    let statementNodes = {};\n    let argumentNodes = {};\n\n    //find all statement classes that should be inserted as nodes\n    let statementKeys = Object.keys(data.statements);\n    for(let statementKey of statementKeys){\n      let equivalenceClass = data.statements[statementKey];\n      if(equivalenceClass.relations.length > 0 && (equivalenceClass.isUsedAsThesis || !equivalenceClass.isUsedInArgument)){\n        let id = \"n\"+nodeCount;\n        nodeCount++;\n        let node = {type:\"statement\", title:statementKey, id:id};\n        statementNodes[statementKey] = node;\n        map.nodes.push(node)\n\n        if(!equivalenceClass.isUsedInArgument){ //if the statement is used in an argument, the relations get added in the next round\n          //add all relations outgoing from this statement class, if it is not added by an argument\n          for(let relation of equivalenceClass.relations){\n            if(relation.from == equivalenceClass){\n              relations.push(relation);\n            }\n          }\n        }\n      }\n    }\n\n    let argumentKeys = Object.keys(data.arguments);\n    let statementRoles = {}; //a dictionary mapping statement titles to {premiseIn:[nodeId], conclusionIn:[nodeId]} objects\n\n    for(let argumentKey of argumentKeys){\n      let argument = data.arguments[argumentKey];\n      let id = \"n\"+nodeCount;\n      nodeCount++;\n      let node = {type:\"argument\", title:argument.title, id:id};\n      argumentNodes[argumentKey] = node;\n      map.nodes.push(node);\n      for(let relation of argument.relations){\n        if(relation.from == argument){\n          relations.push(relation);\n        }\n      }\n      for(let statement of argument.pcs){\n        let roles = statementRoles[statement.title];\n        if(!roles){\n          roles = {premiseIn:[], conclusionIn:[]};\n          statementRoles[statement.title] = roles;\n        }\n        if(statement.role == \"premise\"){\n          roles.premiseIn.push(argumentNodes[argumentKey]);\n        }else if(statement.role == \"conclusion\"){\n          roles.conclusionIn.push(argumentNodes[argumentKey]);\n        }\n        let equivalenceClass = data.statements[statement.title];\n        for(let relation of equivalenceClass.relations){\n          if(statement.role == \"conclusion\" && relation.from == equivalenceClass){\n            relations.push(relation);\n          }\n        }\n      }\n    }\n\n    for(let relation of relations){\n      let froms = [];\n      let tos = [];\n\n      let fromNode;\n      if(relation.from instanceof Argument){\n        fromNode = argumentNodes[relation.from.title];\n      }else{\n        fromNode = statementNodes[relation.from.title];\n      }\n      if(!fromNode){ //fromNode has to be a statement\n        let roles = statementRoles[relation.from.title];\n        froms = roles.conclusionIn;\n      }else{\n        froms.push(fromNode);\n      }\n\n      let toNode;\n      if(relation.to instanceof Argument){\n        toNode = argumentNodes[relation.to.title];\n      }else{\n        toNode = statementNodes[relation.to.title];\n      }\n      if(!toNode){ //fromNode has to be a statement\n        let roles = statementRoles[relation.to.title];\n        tos = roles.premiseIn;\n      }else{\n        tos.push(toNode);\n      }\n\n      for(let from of froms){\n        for(let to of tos){\n          map.relations.push({from:from, to:to, type:relation.type});\n        }\n      }\n    }\n    return map;\n  }\n}\nmodule.exports = {\n  MapMaker: MapMaker\n}\n"]}