{"version":3,"sources":["../../src/ArgdownParser.js"],"names":["ArgdownParser","input","lexer","tokens","$","argdown","RULE","atLeastOne","AT_LEAST_ONE_SEP","SEP","Emptyline","DEF","OR","ALT","SUBRULE","heading","statement","argument","argumentDefinition","argumentReference","orderedList","unorderedList","name","children","values","push","CONSUME","HeadingStart","AT_LEAST_ONE","ArgumentMention","StatementMention","freestyleText","inferentialStep","concat","SUBRULE1","argumentStatement","inference","SUBRULE2","ArgumentStatementStart","InferenceStart","OPTION1","inferenceRules","OPTION2","metadata","InferenceEnd","AT_LEAST_ONE_SEP1","ListDelimiter","MetadataStart","MetadataStatementEnd","metadataStatement","MetadataEnd","Colon","list","Indent","orderedListItem","Dedent","unorderedListItem","UnorderedListItem","OrderedListItem","ArgumentReference","OPTION","relations","argumentDescription","ArgumentDefinition","statementContent","StatementReference","StatementDefinition","incomingSupport","incomingAttack","outgoingSupport","outgoingAttack","IncomingSupport","IncomingAttack","OutgoingSupport","OutgoingAttack","bold","UnderscoreBoldStart","UnderscoreBoldEnd","AsteriskBoldStart","AsteriskBoldEnd","italic","UnderscoreItalicStart","SUBRULE3","UnderscoreItalicEnd","AsteriskItalicStart","SUBRULE4","AsteriskItalicEnd","Link","Freestyle","UnusedControlChar","performSelfAnalysis","value","console","log","logAstRecursively","JSON","stringify","pre","str","undefined","constructor","length","nextPre","child","Parser","module","exports"],"mappings":"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","file":"ArgdownParser.js","sourcesContent":["'use strict';\n\nimport chevrotain, {\n    Parser,\n    Token\n} from 'chevrotain';\nimport {ArgdownLexer} from './ArgdownLexer.js';\n\nclass ArgdownParser extends chevrotain.Parser {\n\n    constructor(input, lexer) {\n        super(input, lexer.tokens);\n        let $ = this;\n\n        $.argdown = $.RULE(\"argdown\", () => {\n            let atLeastOne = $.AT_LEAST_ONE_SEP({\n                SEP: lexer.Emptyline,\n                DEF: () => $.OR([{\n                    ALT: () => $.SUBRULE($.heading)\n                }, {\n                    ALT: () => $.SUBRULE($.statement)\n                },  {\n                    ALT: () => $.SUBRULE($.argument)\n                },  {\n                    ALT: () => $.SUBRULE($.argumentDefinition)\n                },  {\n                    ALT: () => $.SUBRULE($.argumentReference)\n                }, {\n                    ALT: () => $.SUBRULE($.orderedList)\n                }, {\n                    ALT: () => $.SUBRULE($.unorderedList)\n                }])\n            });\n            return {\n                name: 'argdown',\n                children: atLeastOne.values\n            };\n        });\n\n        $.heading = $.RULE(\"heading\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.HeadingStart));\n            $.AT_LEAST_ONE({\n              DEF:()=>$.OR({\n                DEF:[\n                  {\n                      ALT: () => children.push($.CONSUME(lexer.ArgumentMention))\n                  }, {\n                      ALT: () => children.push($.CONSUME(lexer.StatementMention))\n                  }, {\n                      ALT: () => children.push($.SUBRULE($.freestyleText))\n                  }\n                ]\n              })\n            });\n\n            return {\n                name: \"heading\",\n                children: children\n            };\n        });\n        /*\n         * An argument consists of at least one inferential step.\n         * Note that the inferential steps are not atomic self-contained elements within the argument.\n         * An inferential step can use and depend on statements from other inferential steps.\n         * Inferential steps are only used to ascertain that the basic syntax of arguments is maintained:\n         * There can not be inferences without premises or conclusions.\n         * Isolated inferential steps are thus of no further use when working with Argdown data and should be ignored.\n         * Instead, always work with the complete argument.\n         */\n        $.argument = $.RULE(\"argument\", () => {\n            let children = [];\n            let atLeastOne = ($.AT_LEAST_ONE(() => children.push($.SUBRULE($.inferentialStep))));\n            children.concat(atLeastOne.values);\n            return {\n                name: \"argument\",\n                children: children\n            };\n        });\n\n        /*\n         * One inferential step in an argument consisting of at least one premise, an inference and a conclusion.\n         * Do not use this when traversing the AST. Instead, always work with the whole argument.\n         * For further information, see $.argument.\n         */\n        $.inferentialStep = $.RULE(\"inferentialStep\", () => {\n            let children = [];\n            $.AT_LEAST_ONE(() => children.push($.SUBRULE1($.argumentStatement)));\n            children.push($.SUBRULE($.inference));\n            children.push($.SUBRULE2($.argumentStatement));\n            return {\n                name: \"inferentialStep\",\n                children: children\n            };\n        });\n        $.argumentStatement = $.RULE(\"argumentStatement\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.ArgumentStatementStart));\n            children.push($.SUBRULE($.statement));\n            return {\n                name: \"argumentStatement\",\n                children: children\n            };\n        });\n        $.inference = $.RULE(\"inference\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.InferenceStart));\n            $.OPTION1(() => {\n                children.push($.SUBRULE($.inferenceRules));\n            });\n            $.OPTION2(() => {\n                children.push($.SUBRULE($.metadata));\n            });\n            children.push($.CONSUME(lexer.InferenceEnd));\n            return {\n                name: \"inference\",\n                children: children\n            };\n        });\n        $.inferenceRules = $.RULE(\"inferenceRules\", () => {\n            let children = [];\n            $.AT_LEAST_ONE_SEP1({\n                SEP: lexer.ListDelimiter,\n                DEF: () => children.push($.SUBRULE($.freestyleText))\n            });\n            return {\n                name: \"inferenceRules\",\n                children: children\n            };\n        });\n        $.metadata = $.RULE(\"metadata\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.MetadataStart));\n            $.AT_LEAST_ONE_SEP({\n                SEP: lexer.MetadataStatementEnd,\n                DEF: () => children.push($.SUBRULE($.metadataStatement))\n            });\n            children.push($.CONSUME(lexer.MetadataEnd));\n            return {\n                name: \"metadata\",\n                children: children\n            };\n        });\n        $.metadataStatement = $.RULE(\"metadataStatement\", () => {\n            let children = [];\n            children.push($.SUBRULE1($.freestyleText));\n            $.CONSUME(lexer.Colon);\n            $.AT_LEAST_ONE_SEP({\n                SEP: lexer.ListDelimiter,\n                DEF: () => children.push($.SUBRULE2($.freestyleText))\n            });\n            return {\n                name: \"metadataStatement\",\n                children: children\n            };\n        });\n\n        $.list = $.RULE(\"orderedList\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.Indent));\n            $.AT_LEAST_ONE(() => children.push($.SUBRULE($.orderedListItem)));\n            children.push($.CONSUME(lexer.Dedent));\n            return {\n                name: 'orderedList',\n                children: children\n            };\n        });\n        $.list = $.RULE(\"unorderedList\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.Indent));\n            $.AT_LEAST_ONE(() => children.push($.SUBRULE($.unorderedListItem)));\n            children.push($.CONSUME(lexer.Dedent));\n            return {\n                name: 'unorderedList',\n                children: children\n            };\n        });\n\n        $.unorderedListItem = $.RULE(\"unorderedListItem\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.UnorderedListItem));\n            children.push($.SUBRULE($.statement));\n            return {\n                name: \"unorderedListItem\",\n                children: children\n            };\n        });\n        $.orderedListItem = $.RULE(\"orderedListItem\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.OrderedListItem));\n            children.push($.SUBRULE($.statement));\n            return {\n                name: \"orderedListItem\",\n                children: children\n            };\n        });\n\n        $.argumentReference = $.RULE(\"argumentReference\", ()=>{\n          let children = [];\n          children.push($.CONSUME(lexer.ArgumentReference));\n          $.OPTION(() => {\n              children.push($.SUBRULE($.relations))\n          });\n          return {\n              name: 'argumentReference',\n              children: children\n          };\n        });\n\n        $.argumentDescription = $.RULE(\"argumentDefinition\", () =>{\n          let children = [];\n          children.push($.CONSUME(lexer.ArgumentDefinition));\n          children.push($.SUBRULE2($.statementContent));\n          $.OPTION1(() => {\n              children.push($.SUBRULE($.relations))\n          });\n          return {\n              name: 'argumentDefinition',\n              children: children\n          };\n        });\n\n        $.statement = $.RULE(\"statement\", () => {\n            let children = [];\n            children[0] = $.OR([{\n                ALT: () => $.SUBRULE1($.statementContent)\n            }, {\n                ALT: () => $.CONSUME(lexer.StatementReference)\n            }, {\n                ALT: () => {\n                    let children = [];\n                    children.push($.CONSUME(lexer.StatementDefinition));\n                    children.push($.SUBRULE2($.statementContent));\n                    return {\n                        name: \"statementDefinition\",\n                        children: children\n                    };\n                }\n              }]);\n            $.OPTION(() => {\n                children.push($.SUBRULE($.relations))\n            });\n            return {\n                name: 'statement',\n                children: children\n            };\n        });\n\n        $.relations = $.RULE(\"relations\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.Indent));\n            let atLeastOne = $.AT_LEAST_ONE(() => $.OR([{\n                ALT: () => $.SUBRULE($.incomingSupport)\n            }, {\n                ALT: () => $.SUBRULE($.incomingAttack)\n            }, {\n                ALT: () => $.SUBRULE($.outgoingSupport)\n            }, {\n                ALT: () => $.SUBRULE($.outgoingAttack)\n            }]));\n            children = children.concat(atLeastOne);\n            children.push($.CONSUME(lexer.Dedent));\n            return {\n                name: 'relations',\n                children: children\n            };\n        });\n\n        $.incomingSupport = $.RULE(\"incomingSupport\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.IncomingSupport));\n            $.OR({\n              DEF : [\n                {ALT: ()=> children.push($.SUBRULE($.statement))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentDefinition))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentReference))}\n              ]\n            });\n\n            return {\n                name: 'incomingSupport',\n                children: children\n            };\n        });\n        $.incomingAttack = $.RULE(\"incomingAttack\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.IncomingAttack));\n            $.OR({\n              DEF : [\n                {ALT: ()=> children.push($.SUBRULE($.statement))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentDefinition))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentReference))}\n              ]\n            });\n            return {\n                name: 'incomingAttack',\n                children: children\n            };\n        });\n        $.outgoingSupport = $.RULE(\"outgoingSupport\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.OutgoingSupport));\n            $.OR({\n              DEF : [\n                {ALT: ()=> children.push($.SUBRULE($.statement))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentDefinition))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentReference))}\n              ]\n            });\n            return {\n                name: 'outgoingSupport',\n                children: children\n            };\n        });\n        $.outgoingAttack = $.RULE(\"outgoingAttack\", () => {\n            let children = [];\n            children.push($.CONSUME(lexer.OutgoingAttack));\n            $.OR({\n              DEF : [\n                {ALT: ()=> children.push($.SUBRULE($.statement))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentDefinition))},\n                {ALT: ()=> children.push($.SUBRULE($.argumentReference))}\n              ]\n            });\n            return {\n                name: 'outgoingAttack',\n                children: children\n            };\n        });\n        $.bold = $.RULE(\"bold\",()=>{\n          let children = [];\n          $.OR([{\n              ALT: () => {\n                  children.push($.CONSUME(lexer.UnderscoreBoldStart));\n                  children.push($.SUBRULE1($.statementContent));\n                  children.push($.CONSUME(lexer.UnderscoreBoldEnd));\n              }\n          }, {\n              ALT: () => {\n                  children.push($.CONSUME(lexer.AsteriskBoldStart));\n                  children.push($.SUBRULE2($.statementContent));\n                  children.push($.CONSUME(lexer.AsteriskBoldEnd));\n              }\n          }]);\n          return {name:'bold', children:children};\n        });\n        $.italic = $.RULE(\"italic\",()=>{\n          let children = [];\n          $.OR([{\n              ALT: () => {\n                  children.push($.CONSUME(lexer.UnderscoreItalicStart));\n                  children.push($.SUBRULE3($.statementContent));\n                  children.push($.CONSUME(lexer.UnderscoreItalicEnd));\n              }\n          }, {\n              ALT: () => {\n                  children.push($.CONSUME(lexer.AsteriskItalicStart));\n                  children.push($.SUBRULE4($.statementContent));\n                  children.push($.CONSUME(lexer.AsteriskItalicEnd));\n              }\n          }]);\n          return {name:'italic', children:children};\n        });\n        $.statementContent = $.RULE(\"statementContent\", () => {\n            let children = [];\n            $.AT_LEAST_ONE(() => $.OR([{\n                ALT: () => children.push($.SUBRULE($.freestyleText))\n            }, {\n                ALT: () => children.push($.CONSUME(lexer.Link))\n            }, {\n                ALT: () => children.push($.SUBRULE($.bold))\n            }, {\n                ALT: () => children.push($.SUBRULE($.italic))\n            }, {\n                ALT: () => children.push($.CONSUME(lexer.ArgumentMention))\n            }, {\n                ALT: () => children.push($.CONSUME(lexer.StatementMention))\n            }]));\n            return {\n                name: 'statementContent',\n                children: children\n            };\n        });\n\n        $.freestyleText = $.RULE(\"freestyleText\", () => {\n            let children = [];\n            $.AT_LEAST_ONE(() => $.OR([{\n                ALT: () => children.push($.CONSUME(lexer.Freestyle))\n            }, {\n                ALT: () => children.push($.CONSUME(lexer.UnusedControlChar))\n            }]));\n            return {\n                name: \"freestyleText\",\n                children: children\n            };\n        });\n        // very important to call this after all the rules have been defined.\n        // otherwise the parser may not work correctly as it will lack information\n        // derived during the self analysis phase.\n        Parser.performSelfAnalysis(this);\n    }\n\n    logAst(value) {\n        console.log(this.logAstRecursively(value, \"\", \"\"));\n    }\n    logAstAsJson(value) {\n        console.log(JSON.stringify(value, null, 2));\n    }\n    logAstRecursively(value, pre, str) {\n        if (value === undefined) {\n            str += \"undefined\";\n            return str;\n        } else if (value instanceof Token) {\n            str += value.constructor.name;\n            return str;\n        }\n        str += value.name;\n        if (value.children && value.children.length > 0) {\n            let nextPre = pre + \" |\";\n            for (let child of value.children) {\n                str += \"\\n\" + nextPre + \"__\";\n                str = this.logAstRecursively(child, nextPre, str);\n            }\n            str += \"\\n\" + pre;\n        }\n        return str;\n    }\n\n}\n\nmodule.exports = {\n    ArgdownParser: new ArgdownParser(null, ArgdownLexer)\n}\n"]}