{"version":3,"sources":["../../src/ArgdownParser.js"],"names":["lexer","ArgdownParser","input","tokens","$","statements","RULE","many","MANY_SEP","Emptyline","SUBRULE","statement","name","children","values","relations","push","CONSUME","Indent","manyResult","MANY","OR","ALT","incomingSupport","incomingAttack","outgoingSupport","outgoingAttack","concat","Dedent","IncomingSupport","IncomingAttack","OutgoingSupport","OutgoingAttack","SUBRULE1","statementContent","StatementReference","StatementDefinition","SUBRULE2","OPTION","Freestyle","performSelfAnalysis","Parser","module","exports"],"mappings":"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","file":"ArgdownParser.js","sourcesContent":["'use strict';\n\nimport chevrotain,{Parser} from 'chevrotain';\nimport * as lexer from './ArgdownLexer.js';\n\nclass ArgdownParser extends chevrotain.Parser {\n\n    constructor(input) {\n        super(input, lexer.tokens);\n\n    let $ = this;\n\n    $.statements = $.RULE(\"statements\", ()=>{\n      let many = $.MANY_SEP(lexer.Emptyline,()=>{\n        return $.SUBRULE($.statement);\n      });\n      return {name: 'statements',\n          children: many.values\n      };\n    });\n\n    $.relations = $.RULE(\"relations\", ()=>{\n      let children = [];\n      children.push($.CONSUME(lexer.Indent));\n      let manyResult = $.MANY(() =>$.OR([\n            {ALT: () => $.SUBRULE($.incomingSupport)},\n            {ALT: () => $.SUBRULE($.incomingAttack)},\n            {ALT: () => $.SUBRULE($.outgoingSupport)},\n            {ALT: () => $.SUBRULE($.outgoingAttack)}\n        ]));\n      children = children.concat(manyResult);\n      children.push($.CONSUME(lexer.Dedent));\n      return {name:'relations', children: children};\n    });\n\n    $.incomingSupport = $.RULE(\"incomingSupport\", ()=>{\n      let children = [];\n      children.push($.CONSUME(lexer.IncomingSupport));\n      children.push($.SUBRULE($.statement));\n      return {name:'incomingSupport', children: children};\n    });\n    $.incomingAttack = $.RULE(\"incomingAttack\", ()=>{\n      let children = [];\n      children.push($.CONSUME(lexer.IncomingAttack));\n      children.push($.SUBRULE($.statement));\n      return {name:'incomingAttack', children: children};\n    });\n    $.outgoingSupport = $.RULE(\"outgoingSupport\", ()=>{\n      let children = [];\n      children.push($.CONSUME(lexer.OutgoingSupport));\n      children.push($.SUBRULE($.statement));\n      return {name:'outgoingSupport', children: children};\n    });\n    $.outgoingAttack = $.RULE(\"outgoingAttack\", ()=>{\n      let children = [];\n      children.push($.CONSUME(lexer.OutgoingAttack));\n      children.push($.SUBRULE($.statement));\n      return {name:'outgoingAttack', children: children};\n    });\n\n    $.statement = $.RULE(\"statement\", ()=>{\n      let children = [];\n      children[0] = $.OR([\n        {ALT: () => $.SUBRULE1($.statementContent)},\n        {ALT: () => $.CONSUME(lexer.StatementReference)},\n        {ALT: () => {\n          let children = [];\n          children.push($.CONSUME(lexer.StatementDefinition));\n          children.push($.SUBRULE2($.statementContent));\n          return children;\n        }}\n      ]);\n      $.OPTION(()=>{children.push($.SUBRULE($.relations))});\n      return {name:'statement', children: children};\n    });\n\n    $.statementContent = $.RULE(\"statementContent\", ()=>{\n      let children = $.MANY(()=>$.CONSUME(lexer.Freestyle));\n      return {name:'statementContent', children: children};\n    });\n    // very important to call this after all the rules have been defined.\n    // otherwise the parser may not work correctly as it will lack information\n    // derived during the self analysis phase.\n    Parser.performSelfAnalysis(this);\n  }\n\n\n\n}\n\nmodule.exports = {\n  ArgdownParser: ArgdownParser\n}\n"]}