{"version":3,"sources":["../../src/utils.js"],"names":["mdurl","require","punycode","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","HTML_REPLACEMENTS","replaceUnsafeChar","ch","escapeHtml","str","test","replace","BAD_PROTO_WITHOUT_FILE_RE","BAD_PROTO_RE","GOOD_DATA_RE","validateLink","url","allowFile","trim","toLowerCase","proto_re","RECODE_HOSTNAME_FOR","normalizeLink","parsed","parse","hostname","protocol","indexOf","toASCII","er","encode","format","normalizeLinkText","toUnicode","decode","stringToHtmlId","id","stringToClassName","getHtmlId","type","title","htmlIdsSet","originalId","i","exports"],"mappings":"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","file":"utils.js","sourcesContent":["var mdurl        = require('mdurl');\nvar punycode     = require('punycode');\n\n// taken from: https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n  return str;\n}\n\n// taken from https://github.com/markdown-it/markdown-it/blob/master/lib/index.js\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// This validator can prohibit more than really needed to prevent XSS. It's a\n// tradeoff to keep code simple and to be secure by default.\n//\n// If you need different setup - override validator method as you wish. Or\n// replace it with dummy function and use external sanitizer.\n//\n\nvar BAD_PROTO_WITHOUT_FILE_RE = /^(vbscript|javascript|data):/;\nvar BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;\nvar GOOD_DATA_RE = /^data:image\\/(gif|png|jpeg|webp);/;\n\nfunction validateLink(url, allowFile) {\n  // url should be normalized at this point, and existing entities are decoded\n  var str = url.trim().toLowerCase();\n  var proto_re = allowFile? BAD_PROTO_WITHOUT_FILE_RE : BAD_PROTO_RE;\n\n  return proto_re.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nvar RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];\n\nfunction normalizeLink(url) {\n  var parsed = mdurl.parse(url, true);\n\n  if (parsed.hostname) {\n    // Encode hostnames in urls like:\n    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n    //\n    // We don't encode unknown schemas, because it's likely that we encode\n    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n    //\n    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n      try {\n        parsed.hostname = punycode.toASCII(parsed.hostname);\n      } catch (er) { /**/ }\n    }\n  }\n\n  return mdurl.encode(mdurl.format(parsed));\n}\n\nfunction normalizeLinkText(url) {\n    var parsed = mdurl.parse(url, true);\n  \n    if (parsed.hostname) {\n      // Encode hostnames in urls like:\n      // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`\n      //\n      // We don't encode unknown schemas, because it's likely that we encode\n      // something we shouldn't (e.g. `skype:name` treated as `skype:host`)\n      //\n      if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {\n        try {\n          parsed.hostname = punycode.toUnicode(parsed.hostname);\n        } catch (er) { /**/ }\n      }\n    }\n  \n    return mdurl.decode(mdurl.format(parsed));\n  }\n\n////////////////////////////////////////////////////////////////////////////////////\n// ARGDOWN Utils\n\nfunction stringToHtmlId(str) {\n    let id = str;\n    id = id.toLowerCase();\n    id = id.replace(/ä/g, \"ae\");\n    id = id.replace(/ö/g, \"oe\");\n    id = id.replace(/ü/g, \"ue\");\n    id = id.replace(/ß/g, \"ss\");\n    id = id.replace(/\\s/g, \"-\");\n    id = id.replace(/[^a-z0-9\\-]/g, \"\");\n    return id;\n}\nconst stringToClassName = stringToHtmlId;\n\n/// Returns a html id of the form \"type-title\". \n/// If htmlIdsSet is not null, creates an id that is not already a member of the set.\n/// Example: If \"statement-s1\" is already a member of the set, it will return \"statement-s1-occurrence-2\".\n/// Note that you still have to add the new id to the set yourself if you want to avoid duplicates.\nfunction getHtmlId(type, title, htmlIdsSet) {\n    let id = type + \"-\" + title;\n    id = stringToHtmlId(id);\n    if (htmlIdsSet) {\n        let originalId = id;\n        let i = 1;\n        while (htmlIdsSet[id]) {\n            i++;\n            id = originalId + \"-occurrence-\" + i;\n        }\n    }\n    return id;\n}\n\nexports.escapeHtml = escapeHtml;\nexports.validateLink = validateLink;\nexports.normalizeLink = normalizeLink;\nexports.normalizeLinkText = normalizeLinkText;\nexports.getHtmlId = getHtmlId;\nexports.stringToHtmlId = stringToHtmlId;\nexports.stringToClassName = stringToClassName;"]}