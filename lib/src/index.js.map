{"version":3,"sources":["../../src/index.js"],"names":["chevrotain","_","createToken","Lexer","getStartOffset","whiteSpaceRegExp","indentStack","lastTextMatched","isStartOfLine","text","matchedTokens","groups","noTokensMatchedYet","isEmpty","newLines","nl","noNewLinesMatchedYet","lastTokenIsEmptyline","last","Emptyline","matchIndentBase","type","isFirstLine","length","match","currIndentLevel","undefined","isZeroIndent","exec","lastIndentLevel","push","image","offset","getEndOffset","line","getEndLine","column","getEndColumn","pop","Outdent","matchIndent","partialRight","matchOutdent","matchRelation","pattern","Indent","matchIncomingSupport","matchIncomingAttack","matchOutgoingSupport","matchOutgoingAttack","IncomingSupport","name","IncomingAttack","OutgoingSupport","OutgoingAttack","Spaces","group","SKIPPED","Newline","Char","customPatternLexer","module","exports","tokenize","lexResult","lastToken","tokens","lastOffset","lastLine","lastColumn","errors","Error"],"mappings":"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","file":"index.js","sourcesContent":["'use strict';\n\nimport * as chevrotain from 'chevrotain';\nimport * as _ from 'lodash';\n\nconst createToken = chevrotain.createToken;\nconst Lexer = chevrotain.Lexer;\nconst getStartOffset = chevrotain.getStartOffset;\n\nconst whiteSpaceRegExp = /^[' '{2}\\t]+/;\n\n// State required for matching the indentations\nlet indentStack = [0];\nlet lastTextMatched;\n\nfunction isStartOfLine(text, matchedTokens, groups){\n  const noTokensMatchedYet = _.isEmpty(matchedTokens);\n  const newLines = groups.nl;\n  const noNewLinesMatchedYet = _.isEmpty(newLines);\n  const lastTokenIsEmptyline = _.last(matchedTokens) instanceof Emptyline;\n  return noTokensMatchedYet ||\n      lastTokenIsEmptyline ||\n      // Both newlines and other Tokens have been matched AND the last matched Token is a newline\n      (!noTokensMatchedYet && !noNewLinesMatchedYet && getStartOffset(_.last(newLines)) > getStartOffset(_.last(matchedTokens)));\n\n}\n\nfunction matchIndentBase(text, matchedTokens, groups, type) {\n    // indentation can only be matched at the start of a line.\n    if (isStartOfLine(text, matchedTokens, groups)) {\n        const isFirstLine = matchedTokens.length == 0 && groups.nl.length == 0;\n        let match;\n        let currIndentLevel = undefined;\n        let isZeroIndent = text.length > 0 && text[0] !== \" \";\n        if (isZeroIndent) {\n            // Matching zero spaces Outdent would not consume any chars, thus it would cause an infinite loop.\n            // This check prevents matching a sequence of zero spaces outdents.\n            if (lastTextMatched !== text) {\n                currIndentLevel = 0;\n                match = [\"\"];\n                lastTextMatched = text;\n            }\n        }\n        // possible non-empty indentation\n        else {\n            match = whiteSpaceRegExp.exec(text);\n            if (match !== null) {\n                currIndentLevel = match[0].length;\n            }\n        }\n\n        if (currIndentLevel !== undefined) {\n            let lastIndentLevel = _.last(indentStack);\n            if (currIndentLevel > lastIndentLevel && type === \"indent\") {\n                indentStack.push(currIndentLevel);\n                return match;\n            } else if (currIndentLevel < lastIndentLevel && type === \"outdent\") {\n                //if we need more than one outdent token, add all but the last one\n                if (indentStack.length > 2) {\n                    const image = \"\";\n                    const offset = chevrotain.getEndOffset(_.last(matchedTokens)) + 1;\n                    const line = (!isFirstLine) ? chevrotain.getEndLine(_.last(matchedTokens)) : chevrotain.getEndLine(_.last(matchedTokens)) + 1;\n                    const column = chevrotain.getEndColumn(_.last(matchedTokens)) + 1;\n                    while (indentStack.length > 2 &&\n                        //stop before the last Outdent\n                        indentStack[indentStack.length - 2] > currIndentLevel) {\n                        indentStack.pop();\n                        matchedTokens.push(new Outdent(image, offset, line, column));\n                    }\n                }\n                indentStack.pop();\n                return match;\n            } else {\n                // same indent, this should be lexed as simple whitespace and ignored\n                return null;\n            }\n        } else {\n            // indentation cannot be matched without at least one space character.\n            return null;\n        }\n    } else {\n        // indentation cannot be matched under other circumstances\n        return null;\n    }\n}\n\n// customize matchIndentBase to create separate functions of Indent and Outdent.\nlet matchIndent = _.partialRight(matchIndentBase, \"indent\");\nlet matchOutdent = _.partialRight(matchIndentBase, \"outdent\");\n\nfunction matchRelation(text, matchedTokens, groups, pattern){\n  if (isStartOfLine(text, matchedTokens, groups) || _.last(matchedTokens) instanceof Indent) {\n    return pattern.exec(text);\n  }\n  return null;\n}\n\nlet matchIncomingSupport = _.partialRight(matchRelation, /^'\\+>'/);\nlet matchIncomingAttack = _.partialRight(matchRelation, /^'->'/);\nlet matchOutgoingSupport = _.partialRight(matchRelation, /^<?'\\+'/);\nlet matchOutgoingAttack = _.partialRight(matchRelation, /^<?'\\-'/);\n\nlet IncomingSupport = createToken({\n    name: \"IncomingSupport\",\n    pattern: matchIncomingSupport\n});\n\nlet IncomingAttack = createToken({\n    name: \"IncomingAttack\",\n    pattern: matchIncomingAttack\n});\n\nlet OutgoingSupport = createToken({\n    name: \"OutgoingSupport\",\n    pattern: matchOutgoingSupport\n});\n\nlet OutgoingAttack = createToken({\n    name: \"OutgoingAttack\",\n    pattern: matchOutgoingAttack\n});\n\n\nlet Spaces = createToken({\n    name: \"Spaces\",\n    pattern: / +/,\n    group: Lexer.SKIPPED\n});\n\nlet Emptyline = createToken({\n    name: \"Emptyline\",\n    pattern: /(\\n\\r|\\n|\\r){2,}/\n});\n\n// newlines are not skipped, by setting their group to \"nl\" they are saved in the lexer result\n// and thus we can check before creating an indentation token that the last token matched was a newline.\nlet Newline = createToken({\n    name: \"Newline\",\n    pattern: /\\n\\r|\\n|\\r/,\n    group: \"nl\"\n});\n\n// define the indentation tokens using custom token patterns\nlet Indent = createToken({\n    name: \"Indent\",\n    pattern: matchIndent\n});\nlet Outdent = createToken({\n    name: \"Outdent\",\n    pattern: matchOutdent\n});\n\nlet Char = createToken({\n  name: \"Char\",\n  pattern: /./\n});\n\nlet customPatternLexer = new Lexer(\n    [\n        Emptyline,\n        Newline,\n        // indentation tokens must appear before Spaces, otherwise all indentation will always be consumed as spaces.\n        // Outdent must appear before Indent for handling zero spaces outdents.\n        Outdent,\n        Indent,\n        IncomingSupport,\n        IncomingAttack,\n        OutgoingSupport,\n        OutgoingAttack,\n        Spaces,\n        Char\n    ]);\n\nmodule.exports = {\n\n    // for testing purposes\n    Emptyline: Emptyline,\n    Newline: Newline,\n    Indent: Indent,\n    Outdent: Outdent,\n    Spaces: Spaces,\n    IncomingSupport: IncomingSupport,\n    IncomingAttack: IncomingAttack,\n    OutgoingSupport: OutgoingSupport,\n    OutgoingAttack: OutgoingAttack,\n    Char: Char,\n\n\n    tokenize: function(text) {\n\n        // have to reset the indent stack between processing of different text inputs\n        indentStack = [0];\n        lastTextMatched = undefined;\n\n        let lexResult = customPatternLexer.tokenize(text);\n\n        const lastToken = _.last(lexResult.tokens);\n        const lastOffset = chevrotain.getEndOffset(lastToken);\n        const lastLine = chevrotain.getEndLine(lastToken);\n        const lastColumn = chevrotain.getEndColumn(lastToken);\n\n        //add remaining Outdents\n        while (indentStack.length > 1) {\n            lexResult.tokens.push(new Outdent(\"\", lastOffset, lastLine, lastColumn));\n            indentStack.pop();\n        }\n\n        if (lexResult.errors.length > 0) {\n            throw new Error(\"sad sad panda lexing errors detected\");\n        }\n        return lexResult;\n    }\n};\n"]}