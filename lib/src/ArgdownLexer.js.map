{"version":3,"sources":["../../src/ArgdownLexer.js"],"names":["chevrotain","_","createToken","createTokenInstance","tokenMatcher","getTokenConstructor","ArgdownLexer","indentStack","rangesStack","matchedTokens","matchedTokensIsEmpty","isEmpty","last","currentLine","endLine","Emptyline","length","lastToken","tokens","startOffset","endOffset","startLine","startColumn","endColumn","push","Dedent","pop","groups","indentStr","currIndentLevel","lastIndentLevel","image","getCurrentLine","nl","indentToken","Indent","dedentToken","$","matchRelation","text","offset","pattern","remainingText","substr","startsWithNewline","exec","match","emitIndentOrDedent","matchIncomingSupport","partialRight","matchIncomingAttack","matchOutgoingSupport","matchOutgoingAttack","matchContradiction","matchIncomingUndercut","matchOutgoingUndercut","IncomingSupport","name","IncomingAttack","OutgoingSupport","OutgoingAttack","Contradiction","IncomingUndercut","OutgoingUndercut","inferenceStartPattern","matchInferenceStart","emitRemainingDedentTokens","InferenceStart","push_mode","Colon","ListDelimiter","MetadataStatementEnd","MetadataStart","MetadataEnd","InferenceEnd","pop_mode","matchListItem","afterEmptyline","orderedListItemPattern","matchOrderedListItem","OrderedListItem","unorderedListItemPattern","matchUnorderedListItem","UnorderedListItem","emptylinePattern","matchEmptyline","Lexer","NA","StatementDefinition","StatementReference","StatementMention","statementNumberPattern","matchStatementNumber","StatementNumber","ArgumentDefinition","ArgumentReference","ArgumentMention","headingPattern","matchHeadingStart","HeadingStart","matchBoldOrItalicStart","rangeType","matchBoldOrItalicEnd","lastRange","skipped","SKIPPED","lastSkipped","lastMatched","getEndOffset","matchAsteriskBoldStart","matchAsteriskBoldEnd","matchUnderscoreBoldStart","matchUnderscoreBoldEnd","matchAsteriskItalicStart","matchAsteriskItalicEnd","matchUnderscoreItalicStart","matchUnderscoreItalicEnd","AsteriskBoldStart","AsteriskBoldEnd","UnderscoreBoldStart","UnderscoreBoldEnd","AsteriskItalicStart","AsteriskItalicEnd","UnderscoreItalicStart","UnderscoreItalicEnd","Comment","group","Link","Tag","Newline","Spaces","EscapedChar","Freestyle","UnusedControlChar","lexerConfig","modes","defaultMode","_lexer","str","token","tokenName","init","lexResult","tokenize","errors","Error","module","exports"],"mappings":"AAAA;;;;AAEA;;IAAYA,U;;AACZ;;IAAYC,C;;;;;;AAEZ,IAAMC,cAAcF,WAAWE,WAA/B;AACA,IAAMC,sBAAsBH,WAAWG,mBAAvC;AACA,IAAMC,eAAeJ,WAAWI,YAAhC;AACA,IAAMC,sBAAsBL,WAAWK,mBAAvC;;IAEMC,Y;;;+BACK;AACH;AACA,iBAAKC,WAAL,GAAmB,CAAC,CAAD,CAAnB;AACA;AACA,iBAAKC,WAAL,GAAmB,EAAnB;AACH;;;uCACcC,a,EAAe;AAC1B,gBAAMC,uBAAuBT,EAAEU,OAAF,CAAUF,aAAV,CAA7B;AACA,gBAAIC,oBAAJ,EACI,OAAO,CAAP;;AAEJ,gBAAIE,OAAOX,EAAEW,IAAF,CAAOH,aAAP,CAAX;AACA,gBAAII,cAAeD,IAAD,GAAQA,KAAKE,OAAb,GAAuB,CAAzC;AACA,gBAAIF,QAAQZ,WAAWI,YAAX,CAAwBQ,IAAxB,EAA8B,KAAKG,SAAnC,CAAZ,EACIF;AACJ,mBAAOA,WAAP;AACH;;;kDAEyBJ,a,EAAe;AACrC,gBAAI,KAAKF,WAAL,CAAiBS,MAAjB,IAA2B,CAA/B,EACI;AACJ,gBAAMC,YAAYhB,EAAEW,IAAF,CAAOH,cAAcS,MAArB,CAAlB;AACA,gBAAMC,cAAeF,SAAD,GAAcA,UAAUG,SAAxB,GAAoC,CAAxD;AACA,gBAAMA,YAAYD,WAAlB;AACA,gBAAME,YAAaJ,SAAD,GAAcA,UAAUH,OAAxB,GAAkC,CAApD;AACA,gBAAMA,UAAUO,SAAhB;AACA,gBAAMC,cAAeL,SAAD,GAAcA,UAAUM,SAAxB,GAAoC,CAAxD;AACA,gBAAMA,YAAYD,WAAlB;;AAEA;AACA,mBAAO,KAAKf,WAAL,CAAiBS,MAAjB,GAA0B,CAAjC,EAAoC;AAChCP,8BAAce,IAAd,CAAmBrB,oBAAoB,KAAKsB,MAAzB,EAAiC,EAAjC,EAAqCN,WAArC,EAAkDC,SAAlD,EAA6DC,SAA7D,EAAwEP,OAAxE,EAAiFQ,WAAjF,EAA8FC,SAA9F,CAAnB;AACA,qBAAKhB,WAAL,CAAiBmB,GAAjB;AACH;AACJ;;;2CAEkBjB,a,EAAekB,M,EAAQC,S,EAAW;AACjD,gBAAMC,kBAAkBD,UAAUZ,MAAlC;AACA,gBAAMc,kBAAkB7B,EAAEW,IAAF,CAAO,KAAKL,WAAZ,CAAxB;AACA,gBAAMwB,QAAQ,EAAd;AACA,gBAAMnB,OAAOX,EAAEW,IAAF,CAAOH,aAAP,CAAb;AACA,gBAAMU,cAAeP,IAAD,GAASA,KAAKQ,SAAL,GAAiB,CAA1B,GAA8B,CAAlD;AACA,gBAAMA,YAAYD,WAAlB;AACA,gBAAME,YAAY,KAAKW,cAAL,CAAoBvB,aAApB,EAAmCkB,OAAOM,EAA1C,CAAlB;AACA,gBAAMnB,UAAUO,SAAhB;AACA,gBAAMC,cAAeV,IAAD,GAASA,KAAKW,SAAL,GAAiB,CAA1B,GAA8B,CAAlD;AACA,gBAAMA,YAAYD,WAAlB;AACA,gBAAIO,kBAAkBC,eAAtB,EAAuC;AACnC,qBAAKvB,WAAL,CAAiBiB,IAAjB,CAAsBK,eAAtB;AACA,oBAAIK,cAAc/B,oBAAoB,KAAKgC,MAAzB,EAAiCJ,KAAjC,EAAwCZ,WAAxC,EAAqDC,SAArD,EAAgEC,SAAhE,EAA2EP,OAA3E,EAAoFQ,WAApF,EAAiGC,SAAjG,CAAlB;AACAd,8BAAce,IAAd,CAAmBU,WAAnB;AACH,aAJD,MAIO,IAAIL,kBAAkBC,eAAtB,EAAuC;AAC1C,uBAAO,KAAKvB,WAAL,CAAiBS,MAAjB,GAA0B,CAA1B,IAA+Ba,kBAAkB5B,EAAEW,IAAF,CAAO,KAAKL,WAAZ,CAAxD,EAAkF;AAC9E,yBAAKA,WAAL,CAAiBmB,GAAjB;AACA,wBAAIU,cAAcjC,oBAAoB,KAAKsB,MAAzB,EAAiCM,KAAjC,EAAwCZ,WAAxC,EAAqDC,SAArD,EAAgEC,SAAhE,EAA2EP,OAA3E,EAAoFQ,WAApF,EAAiGC,SAAjG,CAAlB;AACAd,kCAAce,IAAd,CAAmBY,WAAnB;AACH;AACJ;AACJ;;;AAED,4BAAc;AAAA;;AACV,YAAIC,IAAI,IAAR;AACAA,UAAEnB,MAAF,GAAW,EAAX,CAFU,CAEK;;AAEf,iBAASoB,aAAT,CAAuBC,IAAvB,EAA6BC,MAA7B,EAAqC/B,aAArC,EAAoDkB,MAApD,EAA4Dc,OAA5D,EAAqE;AACjE,gBAAIC,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAII,oBAAoB,kBAAkBC,IAAlB,CAAuBH,aAAvB,KAAyC,IAAjE;AACA,gBAAIzC,EAAEU,OAAF,CAAUF,aAAV,KAA4BmC,iBAAhC,EAAmD;AAC/C,oBAAIE,QAAQL,QAAQI,IAAR,CAAaH,aAAb,CAAZ;AACA,oBAAII,UAAU,IAAV,IAAkBA,MAAM9B,MAAN,IAAgB,CAAtC,EAAyC;AACrC,wBAAIY,YAAYkB,MAAM,CAAN,CAAhB;AACAT,sBAAEU,kBAAF,CAAqBtC,aAArB,EAAoCkB,MAApC,EAA4CC,SAA5C;AACA,2BAAOkB,KAAP;AACH;AACJ;AACD,mBAAO,IAAP;AACH;AACD;AACA,YAAIE,uBAAuB/C,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,iCAA9B,CAA3B;AACA,YAAIY,sBAAsBjD,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,gCAA9B,CAA1B;AACA,YAAIa,uBAAuBlD,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,kCAA9B,CAA3B;AACA,YAAIc,sBAAsBnD,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,iCAA9B,CAA1B;AACA,YAAIe,qBAAqBpD,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,gCAA9B,CAAzB;AACA,YAAIgB,wBAAwBrD,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,gCAA9B,CAA5B;AACA,YAAIiB,wBAAwBtD,EAAEgD,YAAF,CAAeX,aAAf,EAA8B,gCAA9B,CAA5B;;AAEAD,UAAEmB,eAAF,GAAoBtD,YAAY;AAC5BuD,kBAAM,iBADsB;AAE5BhB,qBAASO;AAFmB,SAAZ,CAApB;AAIAX,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEmB,eAAhB;;AAEAnB,UAAEqB,cAAF,GAAmBxD,YAAY;AAC3BuD,kBAAM,gBADqB;AAE3BhB,qBAASS;AAFkB,SAAZ,CAAnB;AAIAb,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEqB,cAAhB;;AAEArB,UAAEsB,eAAF,GAAoBzD,YAAY;AAC5BuD,kBAAM,iBADsB;AAE5BhB,qBAASU;AAFmB,SAAZ,CAApB;AAIAd,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEsB,eAAhB;;AAEAtB,UAAEuB,cAAF,GAAmB1D,YAAY;AAC3BuD,kBAAM,gBADqB;AAE3BhB,qBAASW;AAFkB,SAAZ,CAAnB;AAIAf,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEuB,cAAhB;;AAEAvB,UAAEwB,aAAF,GAAkB3D,YAAY;AAC1BuD,kBAAM,eADoB;AAE1BhB,qBAASY;AAFiB,SAAZ,CAAlB;AAIAhB,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEwB,aAAhB;AACAxB,UAAEyB,gBAAF,GAAqB5D,YAAY;AAC7BuD,kBAAM,kBADuB;AAE7BhB,qBAASa;AAFoB,SAAZ,CAArB;AAIAjB,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEyB,gBAAhB;AACAzB,UAAE0B,gBAAF,GAAqB7D,YAAY;AAC7BuD,kBAAM,kBADuB;AAE7BhB,qBAASc;AAFoB,SAAZ,CAArB;AAIAlB,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE0B,gBAAhB;;AAEA,YAAMC,wBAAwB,4BAA9B;;AAEA,iBAASC,mBAAT,CAA6B1B,IAA7B,EAAmCC,MAAnC,EAA2C/B,aAA3C,EAA0D;AACtD,gBAAIiC,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAII,oBAAoB,gBAAgBC,IAAhB,CAAqBH,aAArB,KAAuC,IAA/D;AACA,gBAAIzC,EAAEU,OAAF,CAAUF,aAAV,KAA4BmC,iBAAhC,EAAmD;AAC/C,oBAAIE,QAAQkB,sBAAsBnB,IAAtB,CAA2BH,aAA3B,CAAZ;AACA,oBAAGI,SAAS,IAAZ,EAAiB;AACfT,sBAAE6B,yBAAF,CAA4BzD,aAA5B;AACA,2BAAOqC,KAAP;AACD;AACJ;AACD,mBAAO,IAAP;AACH;AACDT,UAAE8B,cAAF,GAAmBjE,YAAY;AAC3BuD,kBAAM,gBADqB;AAE3BhB,qBAASwB,mBAFkB;AAG3BG,uBAAW;AAHgB,SAAZ,CAAnB;AAKA/B,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE8B,cAAhB;;AAEA9B,UAAEgC,KAAF,GAAUnE,YAAY;AAClBuD,kBAAM,OADY;AAElBhB,qBAAS;AAFS,SAAZ,CAAV;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEgC,KAAhB;AACAhC,UAAEiC,aAAF,GAAkBpE,YAAY;AAC1BuD,kBAAM,eADoB;AAE1BhB,qBAAS;AAFiB,SAAZ,CAAlB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEiC,aAAhB;AACAjC,UAAEkC,oBAAF,GAAyBrE,YAAY;AACjCuD,kBAAM,sBAD2B;AAEjChB,qBAAS;AAFwB,SAAZ,CAAzB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEkC,oBAAhB;AACAlC,UAAEmC,aAAF,GAAkBtE,YAAY;AAC1BuD,kBAAM,eADoB;AAE1BhB,qBAAS;AAFiB,SAAZ,CAAlB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEmC,aAAhB;AACAnC,UAAEoC,WAAF,GAAgBvE,YAAY;AACxBuD,kBAAM,aADkB;AAExBhB,qBAAS;AAFe,SAAZ,CAAhB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEoC,WAAhB;;AAEApC,UAAEqC,YAAF,GAAiBxE,YAAY;AACzBuD,kBAAM,cADmB;AAEzBhB,qBAAS,OAFgB;AAGzBkC,sBAAU;AAHe,SAAZ,CAAjB;AAKAtC,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEqC,YAAhB;;AAEA,iBAASE,aAAT,CAAuBrC,IAAvB,EAA6BC,MAA7B,EAAqC/B,aAArC,EAAoDkB,MAApD,EAA4Dc,OAA5D,EAAqE;AACjE,gBAAIC,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAII,oBAAoB,gBAAgBC,IAAhB,CAAqBH,aAArB,KAAuC,IAA/D;AACA,gBAAI9B,OAAOX,EAAEW,IAAF,CAAOH,aAAP,CAAX;AACA,gBAAIoE,iBAAiBjE,QAAQR,aAAaQ,IAAb,EAAmByB,EAAEtB,SAArB,CAA7B;AACA,gBAAId,EAAEU,OAAF,CAAUF,aAAV,KAA4BoE,cAA5B,IAA8CjC,iBAAlD,EAAqE;AACjE,oBAAIE,QAAQL,QAAQI,IAAR,CAAaH,aAAb,CAAZ;AACA,oBAAII,UAAU,IAAd,EAAoB;AAChB,wBAAIlB,YAAYkB,MAAM,CAAN,CAAhB;AACAT,sBAAEU,kBAAF,CAAqBtC,aAArB,EAAoCkB,MAApC,EAA4CC,SAA5C;AACA,2BAAOkB,KAAP;AACH;AACJ;AACD,mBAAO,IAAP;AACH;;AAED,YAAMgC,yBAAyB,uCAA/B;AACA,YAAIC,uBAAuB9E,EAAEgD,YAAF,CAAe2B,aAAf,EAA8BE,sBAA9B,CAA3B;;AAEAzC,UAAE2C,eAAF,GAAoB9E,YAAY;AAC5BuD,kBAAM,iBADsB;AAE5BhB,qBAASsC;AAFmB,SAAZ,CAApB;AAIA1C,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE2C,eAAhB;AACA;AACA,YAAMC,2BAA2B,oCAAjC,CAjJU,CAiJ6D;AACvE,YAAIC,yBAAyBjF,EAAEgD,YAAF,CAAe2B,aAAf,EAA8BK,wBAA9B,CAA7B;;AAEA5C,UAAE8C,iBAAF,GAAsBjF,YAAY;AAC9BuD,kBAAM,mBADwB;AAE9BhB,qBAASyC;AAFqB,SAAZ,CAAtB;AAIA7C,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE8C,iBAAhB;;AAEA;AACA;AACA,YAAMC,mBAAmB,kCAAzB,CA5JU,CA4JmD;AAC7D,iBAASC,cAAT,CAAwB9C,IAAxB,EAA8BC,MAA9B,EAAsC/B,aAAtC,EAAqD;AACjD,gBAAIiC,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAI5B,OAAOX,EAAEW,IAAF,CAAOH,aAAP,CAAX;AACA;AACA,gBAAIG,QAAQR,aAAaQ,IAAb,EAAmByB,EAAEtB,SAArB,CAAZ,EACI,OAAO,IAAP;AACJ,gBAAI+B,QAAQsC,iBAAiBvC,IAAjB,CAAsBH,aAAtB,CAAZ;AACA,gBAAII,UAAU,IAAV,IAAkBA,MAAM,CAAN,EAAS9B,MAAT,GAAkB0B,cAAc1B,MAAtD,EAA8D;AAAE;AAC5DqB,kBAAE6B,yBAAF,CAA4BzD,aAA5B;AACA;AACA,uBAAOqC,KAAP;AACH;AACD,mBAAO,IAAP;AACH;AACDT,UAAEtB,SAAF,GAAcb,YAAY;AACtBuD,kBAAM,WADgB;AAEtBhB,qBAAS4C;AAFa,SAAZ,CAAd;AAIAhD,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEtB,SAAhB;;AAEA;AACAsB,UAAEF,MAAF,GAAWjC,YAAY;AACnBuD,kBAAM,QADa;AAEnBhB,qBAASzC,WAAWsF,KAAX,CAAiBC;AAFP,SAAZ,CAAX;AAIAlD,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEF,MAAhB;;AAEAE,UAAEZ,MAAF,GAAWvB,YAAY;AACnBuD,kBAAM,QADa;AAEnBhB,qBAASzC,WAAWsF,KAAX,CAAiBC;AAFP,SAAZ,CAAX;AAIAlD,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEZ,MAAhB;;AAEAY,UAAEmD,mBAAF,GAAwBtF,YAAY;AAChCuD,kBAAM,qBAD0B;AAEhChB,qBAAS;AAFuB,SAAZ,CAAxB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEmD,mBAAhB;;AAEA;AACA;AACA;AACA;AACA;;AAEAnD,UAAEoD,kBAAF,GAAuBvF,YAAY;AAC/BuD,kBAAM,oBADyB;AAE/BhB,qBAAS;AAFsB,SAAZ,CAAvB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEoD,kBAAhB;;AAEA;AACA;AACA;AACA;AACA;;;AAGApD,UAAEqD,gBAAF,GAAqBxF,YAAY;AAC/BuD,kBAAM,kBADyB;AAE/BhB,qBAAS;AAFsB,SAAZ,CAArB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEqD,gBAAhB;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAMC,yBAAyB,iCAA/B;AACA,iBAASC,oBAAT,CAA8BrD,IAA9B,EAAoCC,MAApC,EAA4C/B,aAA5C,EAA2D;AACvD,gBAAIiC,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAI5B,OAAOX,EAAEW,IAAF,CAAOH,aAAP,CAAX;AACA,gBAAImC,oBAAoB,kBAAkBC,IAAlB,CAAuBH,aAAvB,KAAyC,IAAjE;AACA,gBAAImC,iBAAiBjE,QAAQR,aAAaQ,IAAb,EAAmByB,EAAEtB,SAArB,CAA7B;;AAEA;AACA,gBAAId,EAAEU,OAAF,CAAUF,aAAV,KAA4BoE,cAA5B,IAA8CjC,iBAAlD,EAAqE;AACjE,oBAAIE,QAAQ6C,uBAAuB9C,IAAvB,CAA4BH,aAA5B,CAAZ;AACA,oBAAII,UAAU,IAAd,EAAoB;AAChBT,sBAAE6B,yBAAF,CAA4BzD,aAA5B;AACA,2BAAOqC,KAAP;AACH;AACJ;AACD,mBAAO,IAAP;AACH;AACDT,UAAEwD,eAAF,GAAoB3F,YAAY;AAC5BuD,kBAAM,iBADsB;AAE5BhB,qBAASmD;AAFmB,SAAZ,CAApB;AAIAvD,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEwD,eAAhB;;AAEAxD,UAAEyD,kBAAF,GAAuB5F,YAAY;AAC/BuD,kBAAM,oBADyB;AAE/BhB,qBAAS;AAFsB,SAAZ,CAAvB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEyD,kBAAhB;;AAEAzD,UAAE0D,iBAAF,GAAsB7F,YAAY;AAC9BuD,kBAAM,mBADwB;AAE9BhB,qBAAS;AAFqB,SAAZ,CAAtB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE0D,iBAAhB;;AAEA1D,UAAE2D,eAAF,GAAoB9F,YAAY;AAC9BuD,kBAAM,iBADwB;AAE9BhB,qBAAS;AAFqB,SAAZ,CAApB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE2D,eAAhB;;AAEA,YAAMC,iBAAiB,OAAvB;AACA,iBAASC,iBAAT,CAA2B3D,IAA3B,EAAiCC,MAAjC,EAAyC/B,aAAzC,EAAwD;AACpD,gBAAIiC,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAI5B,OAAOX,EAAEW,IAAF,CAAOH,aAAP,CAAX;AACA,gBAAIoE,iBAAiBjE,QAAQR,aAAaQ,IAAb,EAAmByB,EAAEtB,SAArB,CAA7B;;AAEA,gBAAI,CAACH,IAAD,IAASiE,cAAb,EAA6B;AACzB,uBAAOoB,eAAepD,IAAf,CAAoBH,aAApB,CAAP;AACH;AACD,mBAAO,IAAP;AAEH;AACDL,UAAE8D,YAAF,GAAiBjG,YAAY;AACzBuD,kBAAM,cADmB;AAEzBhB,qBAASyD;AAFgB,SAAZ,CAAjB;AAIA7D,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE8D,YAAhB;;AAEA;AACA,iBAASC,sBAAT,CAAgC7D,IAAhC,EAAsCC,MAAtC,EAA8C/B,aAA9C,EAA6DkB,MAA7D,EAAqEc,OAArE,EAA8E4D,SAA9E,EAAyF;AACrF,gBAAI3D,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAIM,QAAQL,QAAQI,IAAR,CAAaH,aAAb,CAAZ;AACA,gBAAII,SAAS,IAAb,EAAmB;AACfT,kBAAE7B,WAAF,CAAcgB,IAAd,CAAmB6E,SAAnB;AACH;AACD,mBAAOvD,KAAP;AACH;;AAED,iBAASwD,oBAAT,CAA8B/D,IAA9B,EAAoCC,MAApC,EAA4C/B,aAA5C,EAA2DkB,MAA3D,EAAmEc,OAAnE,EAA4E4D,SAA5E,EAAuF;AACnF,gBAAIE,YAAYtG,EAAEW,IAAF,CAAOyB,EAAE7B,WAAT,CAAhB;AACA,gBAAI+F,aAAaF,SAAjB,EACI,OAAO,IAAP;AACJ;AACA,gBAAIG,UAAU7E,OAAO3B,WAAWsF,KAAX,CAAiBmB,OAAxB,CAAd;AACA,gBAAIC,cAAczG,EAAEW,IAAF,CAAO4F,OAAP,CAAlB;AACA,gBAAIG,cAAc1G,EAAEW,IAAF,CAAOH,aAAP,CAAlB;AACA,gBAAI,CAACkG,WAAD,IACCD,eAAe1G,WAAW4G,YAAX,CAAwBF,WAAxB,IAAuC1G,WAAW4G,YAAX,CAAwBD,WAAxB,CAD3D,EACkG;AAC9F,uBAAO,IAAP;AACH;AACD,gBAAIjE,gBAAgBH,KAAKI,MAAL,CAAYH,MAAZ,CAApB;AACA,gBAAIM,QAAQL,QAAQI,IAAR,CAAaH,aAAb,CAAZ;;AAEA,gBAAII,SAAS,IAAb,EAAmB;AACfT,kBAAE7B,WAAF,CAAckB,GAAd;AACH;;AAED,mBAAOoB,KAAP;AACH;AACD,YAAI+D,yBAAyB5G,EAAEgD,YAAF,CAAemD,sBAAf,EAAuC,aAAvC,EAAsD,cAAtD,CAA7B;AACA,YAAIU,uBAAuB7G,EAAEgD,YAAF,CAAeqD,oBAAf,EAAqC,wDAArC,EAA+F,cAA/F,CAA3B;;AAEA,YAAIS,2BAA2B9G,EAAEgD,YAAF,CAAemD,sBAAf,EAAuC,WAAvC,EAAoD,gBAApD,CAA/B;AACA,YAAIY,yBAAyB/G,EAAEgD,YAAF,CAAeqD,oBAAf,EAAqC,sDAArC,EAA6F,gBAA7F,CAA7B;;AAEA,YAAIW,2BAA2BhH,EAAEgD,YAAF,CAAemD,sBAAf,EAAuC,WAAvC,EAAoD,gBAApD,CAA/B;AACA,YAAIc,yBAAyBjH,EAAEgD,YAAF,CAAeqD,oBAAf,EAAqC,sDAArC,EAA6F,gBAA7F,CAA7B;;AAEA,YAAIa,6BAA6BlH,EAAEgD,YAAF,CAAemD,sBAAf,EAAuC,WAAvC,EAAoD,kBAApD,CAAjC;AACA,YAAIgB,2BAA2BnH,EAAEgD,YAAF,CAAeqD,oBAAf,EAAqC,sDAArC,EAA6F,kBAA7F,CAA/B;;AAGAjE,UAAEgF,iBAAF,GAAsBnH,YAAY;AAC9BuD,kBAAM,mBADwB;AAE9BhB,qBAASoE;AAFqB,SAAZ,CAAtB;AAIAxE,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEgF,iBAAhB;;AAEAhF,UAAEiF,eAAF,GAAoBpH,YAAY;AAC5BuD,kBAAM,iBADsB;AAE5BhB,qBAASqE;AAFmB,SAAZ,CAApB;AAIAzE,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEiF,eAAhB;;AAEAjF,UAAEkF,mBAAF,GAAwBrH,YAAY;AAChCuD,kBAAM,qBAD0B;AAEhChB,qBAASsE;AAFuB,SAAZ,CAAxB;AAIA1E,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEkF,mBAAhB;;AAEAlF,UAAEmF,iBAAF,GAAsBtH,YAAY;AAC9BuD,kBAAM,mBADwB;AAE9BhB,qBAASuE;AAFqB,SAAZ,CAAtB;AAIA3E,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEmF,iBAAhB;;AAEAnF,UAAEoF,mBAAF,GAAwBvH,YAAY;AAChCuD,kBAAM,qBAD0B;AAEhChB,qBAASwE;AAFuB,SAAZ,CAAxB;AAIA5E,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEoF,mBAAhB;;AAEApF,UAAEqF,iBAAF,GAAsBxH,YAAY;AAC9BuD,kBAAM,mBADwB;AAE9BhB,qBAASyE;AAFqB,SAAZ,CAAtB;AAIA7E,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEqF,iBAAhB;;AAEArF,UAAEsF,qBAAF,GAA0BzH,YAAY;AAClCuD,kBAAM,uBAD4B;AAElChB,qBAAS0E;AAFyB,SAAZ,CAA1B;AAIA9E,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEsF,qBAAhB;;AAEAtF,UAAEuF,mBAAF,GAAwB1H,YAAY;AAChCuD,kBAAM,qBAD0B;AAEhChB,qBAAS2E;AAFuB,SAAZ,CAAxB;AAIA/E,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEuF,mBAAhB;;AAEAvF,UAAEwF,OAAF,GAAY3H,YAAY;AACpBuD,kBAAM,SADc;AAEpBhB,qBAAS,8EAFW;AAGpBqF,mBAAO9H,WAAWsF,KAAX,CAAiBmB;AAHJ,SAAZ,CAAZ;AAKApE,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEwF,OAAhB;;AAEAxF,UAAE0F,IAAF,GAAS7H,YAAY;AACjBuD,kBAAM,MADW;AAEjBhB,qBAAS;AAFQ,SAAZ,CAAT;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE0F,IAAhB;;AAEA1F,UAAE2F,GAAF,GAAQ9H,YAAY;AAClBuD,kBAAM,KADY;AAElBhB,qBAAS;AAFS,SAAZ,CAAR;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE2F,GAAhB;;AAEA3F,UAAE4F,OAAF,GAAY/H,YAAY;AACpBuD,kBAAM,SADc;AAEpBhB,qBAAS,gBAFW;AAGpBqF,mBAAO9H,WAAWsF,KAAX,CAAiBmB;AAHJ,SAAZ,CAAZ;AAKApE,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE4F,OAAhB;;AAEA5F,UAAE6F,MAAF,GAAWhI,YAAY;AACnBuD,kBAAM,QADa;AAEnBhB,qBAAS,SAFU;AAGnBqF,mBAAO9H,WAAWsF,KAAX,CAAiBmB;AAHL,SAAZ,CAAX;AAKApE,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE6F,MAAhB;;AAEA7F,UAAE8F,WAAF,GAAgBjI,YAAY;AACxBuD,kBAAM,aADkB;AAExBhB,qBAAS;AAFe,SAAZ,CAAhB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE8F,WAAhB;;AAEA;AACA9F,UAAE+F,SAAF,GAAclI,YAAY;AACtBuD,kBAAM,WADgB;AAEtBhB,qBAAS;AAFa,SAAZ,CAAd;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAE+F,SAAhB;;AAEA;AACA;AACA;AACA;AACA/F,UAAEgG,iBAAF,GAAsBnI,YAAY;AAC9BuD,kBAAM,mBADwB;AAE9BhB,qBAAS;AAFqB,SAAZ,CAAtB;AAIAJ,UAAEnB,MAAF,CAASM,IAAT,CAAca,EAAEgG,iBAAhB;;AAEA,YAAIC,cAAc;AACdC,mBAAO;AACH,gCAAgB,CACZlG,EAAEwF,OADU,EAEZxF,EAAE8F,WAFU,EAEG;AACf9F,kBAAEtB,SAHU;AAIZ;AACA;AACAsB,kBAAEZ,MANU,EAOZY,EAAEF,MAPU,EAQZE,EAAE8B,cARU,EAQM;AAClB9B,kBAAEmB,eATU,EAUZnB,EAAEqB,cAVU,EAWZrB,EAAEsB,eAXU,EAYZtB,EAAEuB,cAZU,EAaZvB,EAAEwB,aAbU,EAcZxB,EAAEyB,gBAdU,EAeZzB,EAAE0B,gBAfU,EAgBZ1B,EAAE8D,YAhBU;AAiBZ;AACA9D,kBAAEwD,eAlBU,EAmBZxD,EAAE2C,eAnBU,EAoBZ3C,EAAE8C,iBApBU;AAqBZ;AACA9C,kBAAEiF,eAtBU,EAsBO;AACnBjF,kBAAEmF,iBAvBU,EAuBS;AACrBnF,kBAAEqF,iBAxBU,EAyBZrF,EAAEuF,mBAzBU;AA0BZ;AACAvF,kBAAEgF,iBA3BU,EA2BS;AACrBhF,kBAAEkF,mBA5BU,EA4BW;AACvBlF,kBAAEoF,mBA7BU,EA8BZpF,EAAEsF,qBA9BU,EA+BZtF,EAAE0F,IA/BU,EA+BJ;AACR1F,kBAAE2F,GAhCU;AAiCZ;AACA;AACA;AACA3F,kBAAEmD,mBApCU,EAqCZnD,EAAEoD,kBArCU,EAsCZpD,EAAEqD,gBAtCU,EAuCZrD,EAAEyD,kBAvCU,EAwCZzD,EAAE0D,iBAxCU,EAyCZ1D,EAAE2D,eAzCU,EA0CZ3D,EAAE4F,OA1CU,EA2CZ5F,EAAE6F,MA3CU,EA4CZ7F,EAAE+F,SA5CU,EA6CZ/F,EAAEgG,iBA7CU,CADb;AAgDH,kCAAkB,CACdhG,EAAEwF,OADY,EAEdxF,EAAEqC,YAFY,EAGdrC,EAAEmC,aAHY,EAIdnC,EAAEoC,WAJY,EAKdpC,EAAEkC,oBALY,EAMdlC,EAAEiC,aANY,EAOdjC,EAAEgC,KAPY,EAQdhC,EAAE4F,OARY,EASd5F,EAAE6F,MATY,EAUd7F,EAAE+F,SAVY,EAWd/F,EAAEgG,iBAXY;AAhDf,aADO;;AAgEdG,yBAAa;AAhEC,SAAlB;;AAmEA,aAAKC,MAAL,GAAc,IAAIzI,WAAWsF,KAAf,CAAqBgD,WAArB,CAAd;AAEH;;;;uCACcpH,M,EAAQ;AACrB,gBAAIwH,MAAM,EAAV;AADqB;AAAA;AAAA;;AAAA;AAErB,qCAAkBxH,MAAlB,8HAA0B;AAAA,wBAAjByH,KAAiB;;AACtBD,2BAAOrI,oBAAoBsI,KAApB,EAA2BC,SAA3B,GAAuC,GAAvC,GAA6CD,MAAM5G,KAAnD,GAA0D,IAAjE;AACH;AAJoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKrB,mBAAO2G,GAAP;AACD;;;iCACQnG,I,EAAM;AACX,iBAAKsG,IAAL;;AAEA,gBAAIC,YAAY,KAAKL,MAAL,CAAYM,QAAZ,CAAqBxG,IAArB,CAAhB;AACA,gBAAIuG,UAAUE,MAAV,CAAiBhI,MAAjB,GAA0B,CAA9B,EAAiC;AAC7B,sBAAM,IAAIiI,KAAJ,CAAU,sCAAV,CAAN;AACH;;AAED;AACA,gBAAG7I,aAAaH,EAAEW,IAAF,CAAOkI,UAAU5H,MAAjB,CAAb,EAAuC,KAAKH,SAA5C,CAAH,EAA0D;AACxD+H,0BAAU5H,MAAV,CAAiBQ,GAAjB;AACD;;AAED,iBAAKwC,yBAAL,CAA+B4E,UAAU5H,MAAzC;;AAEA,mBAAO4H,SAAP;AACH;;;;;;AAGLI,OAAOC,OAAP,GAAiB;AACb7I,kBAAc,IAAIA,YAAJ;AADD,CAAjB","file":"ArgdownLexer.js","sourcesContent":["'use strict';\n\nimport * as chevrotain from 'chevrotain';\nimport * as _ from 'lodash';\n\nconst createToken = chevrotain.createToken;\nconst createTokenInstance = chevrotain.createTokenInstance;\nconst tokenMatcher = chevrotain.tokenMatcher;\nconst getTokenConstructor = chevrotain.getTokenConstructor;\n\nclass ArgdownLexer {\n    init() {\n        // State required for matching the indentations\n        this.indentStack = [0];\n        // State require for matching bold and italic ranges in the right order\n        this.rangesStack = [];\n    }\n    getCurrentLine(matchedTokens) {\n        const matchedTokensIsEmpty = _.isEmpty(matchedTokens);\n        if (matchedTokensIsEmpty)\n            return 0;\n\n        let last = _.last(matchedTokens);\n        let currentLine = (last)? last.endLine : 0;\n        if (last && chevrotain.tokenMatcher(last, this.Emptyline))\n            currentLine++;\n        return currentLine;\n    }\n\n    emitRemainingDedentTokens(matchedTokens) {\n        if (this.indentStack.length <= 1)\n            return;\n        const lastToken = _.last(matchedTokens.tokens);\n        const startOffset = (lastToken) ? lastToken.endOffset : 0;\n        const endOffset = startOffset;\n        const startLine = (lastToken) ? lastToken.endLine : 0;\n        const endLine = startLine;\n        const startColumn = (lastToken) ? lastToken.endColumn : 0;\n        const endColumn = startColumn;\n\n        //add remaining Dedents\n        while (this.indentStack.length > 1) {\n            matchedTokens.push(createTokenInstance(this.Dedent, \"\", startOffset, endOffset, startLine, endLine, startColumn, endColumn));\n            this.indentStack.pop();\n        }\n    }\n\n    emitIndentOrDedent(matchedTokens, groups, indentStr) {\n        const currIndentLevel = indentStr.length;\n        const lastIndentLevel = _.last(this.indentStack);\n        const image = \"\";\n        const last = _.last(matchedTokens);\n        const startOffset = (last) ? last.endOffset + 1 : 0;\n        const endOffset = startOffset;\n        const startLine = this.getCurrentLine(matchedTokens, groups.nl);\n        const endLine = startLine;\n        const startColumn = (last) ? last.endColumn + 1 : 0;\n        const endColumn = startColumn;\n        if (currIndentLevel > lastIndentLevel) {\n            this.indentStack.push(currIndentLevel);\n            let indentToken = createTokenInstance(this.Indent, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn);\n            matchedTokens.push(indentToken);\n        } else if (currIndentLevel < lastIndentLevel) {\n            while (this.indentStack.length > 1 && currIndentLevel < _.last(this.indentStack)) {\n                this.indentStack.pop();\n                let dedentToken = createTokenInstance(this.Dedent, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn);\n                matchedTokens.push(dedentToken);\n            }\n        }\n    }\n\n    constructor() {\n        let $ = this;\n        $.tokens = []; //token list for the parser\n\n        function matchRelation(text, offset, matchedTokens, groups, pattern) {\n            let remainingText = text.substr(offset);\n            let startsWithNewline = /^(?:\\r\\n|\\n|\\r)/.exec(remainingText) != null;\n            if (_.isEmpty(matchedTokens) || startsWithNewline) {\n                let match = pattern.exec(remainingText);\n                if (match !== null && match.length == 3) {\n                    let indentStr = match[1];\n                    $.emitIndentOrDedent(matchedTokens, groups, indentStr);\n                    return match;\n                }\n            }\n            return null;\n        }\n        //relations start at BOF or after a newline, optionally followed by indentation (spaces or tabs)\n        let matchIncomingSupport = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(\\+>)/);\n        let matchIncomingAttack = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(->)/);\n        let matchOutgoingSupport = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(<?\\+)/);\n        let matchOutgoingAttack = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(<?-)/);\n        let matchContradiction = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(><)/);\n        let matchIncomingUndercut = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(_>)/);\n        let matchOutgoingUndercut = _.partialRight(matchRelation, /^(?:\\r\\n|\\n|\\r)?([' '\\t]*)(<_)/);\n\n        $.IncomingSupport = createToken({\n            name: \"IncomingSupport\",\n            pattern: matchIncomingSupport\n        });\n        $.tokens.push($.IncomingSupport);\n\n        $.IncomingAttack = createToken({\n            name: \"IncomingAttack\",\n            pattern: matchIncomingAttack\n        });\n        $.tokens.push($.IncomingAttack);\n\n        $.OutgoingSupport = createToken({\n            name: \"OutgoingSupport\",\n            pattern: matchOutgoingSupport\n        });\n        $.tokens.push($.OutgoingSupport);\n\n        $.OutgoingAttack = createToken({\n            name: \"OutgoingAttack\",\n            pattern: matchOutgoingAttack\n        });\n        $.tokens.push($.OutgoingAttack);\n\n        $.Contradiction = createToken({\n            name: \"Contradiction\",\n            pattern: matchContradiction\n        });\n        $.tokens.push($.Contradiction);\n        $.IncomingUndercut = createToken({\n            name: \"IncomingUndercut\",\n            pattern: matchIncomingUndercut\n        });\n        $.tokens.push($.IncomingUndercut);\n        $.OutgoingUndercut = createToken({\n            name: \"OutgoingUndercut\",\n            pattern: matchOutgoingUndercut\n        });\n        $.tokens.push($.OutgoingUndercut);\n\n        const inferenceStartPattern = /^[\\r\\n|\\n|\\r]?[' '\\t]*-{2}/;\n\n        function matchInferenceStart(text, offset, matchedTokens) {\n            let remainingText = text.substr(offset);\n            let startsWithNewline = /^[\\r\\n|\\n|\\r]/.exec(remainingText) != null;\n            if (_.isEmpty(matchedTokens) || startsWithNewline) {\n                let match = inferenceStartPattern.exec(remainingText);\n                if(match != null){\n                  $.emitRemainingDedentTokens(matchedTokens);\n                  return match;\n                }\n            }\n            return null;\n        }\n        $.InferenceStart = createToken({\n            name: \"InferenceStart\",\n            pattern: matchInferenceStart,\n            push_mode: \"inference_mode\"\n        });\n        $.tokens.push($.InferenceStart);\n\n        $.Colon = createToken({\n            name: \"Colon\",\n            pattern: /:/\n        });\n        $.tokens.push($.Colon);\n        $.ListDelimiter = createToken({\n            name: \"ListDelimiter\",\n            pattern: /,/\n        });\n        $.tokens.push($.ListDelimiter);\n        $.MetadataStatementEnd = createToken({\n            name: \"MetadataStatementEnd\",\n            pattern: /;/\n        });\n        $.tokens.push($.MetadataStatementEnd);\n        $.MetadataStart = createToken({\n            name: \"MetadataStart\",\n            pattern: /\\(/\n        });\n        $.tokens.push($.MetadataStart);\n        $.MetadataEnd = createToken({\n            name: \"MetadataEnd\",\n            pattern: /\\)/\n        });\n        $.tokens.push($.MetadataEnd);\n\n        $.InferenceEnd = createToken({\n            name: \"InferenceEnd\",\n            pattern: /-{2,}/,\n            pop_mode: true\n        });\n        $.tokens.push($.InferenceEnd);\n\n        function matchListItem(text, offset, matchedTokens, groups, pattern) {\n            let remainingText = text.substr(offset);\n            let startsWithNewline = /^[\\r\\n|\\n|\\r]/.exec(remainingText) != null;\n            let last = _.last(matchedTokens);\n            let afterEmptyline = last && tokenMatcher(last, $.Emptyline);\n            if (_.isEmpty(matchedTokens) || afterEmptyline || startsWithNewline) {\n                let match = pattern.exec(remainingText);\n                if (match !== null) {\n                    let indentStr = match[1];\n                    $.emitIndentOrDedent(matchedTokens, groups, indentStr);\n                    return match;\n                }\n            }\n            return null;\n        }\n\n        const orderedListItemPattern = /^(?:\\r\\n|\\n|\\r)?([' '\\t]+)\\d+\\.(?=\\s)/;\n        let matchOrderedListItem = _.partialRight(matchListItem, orderedListItemPattern);\n\n        $.OrderedListItem = createToken({\n            name: \"OrderedListItem\",\n            pattern: matchOrderedListItem\n        });\n        $.tokens.push($.OrderedListItem);\n        //whitespace + * + whitespace (to distinguish list items from bold and italic ranges)\n        const unorderedListItemPattern = /^(?:\\r\\n|\\n|\\r)?([' '\\t]+)\\*(?=\\s)/; //Newline +\n        let matchUnorderedListItem = _.partialRight(matchListItem, unorderedListItemPattern);\n\n        $.UnorderedListItem = createToken({\n            name: \"UnorderedListItem\",\n            pattern: matchUnorderedListItem\n        });\n        $.tokens.push($.UnorderedListItem);\n\n        //This does not work with \\r\\n|\\n||r as a simple CRLF linebreak will be interpreted as an Emptyline\n        //Instead we drop the last alternative (\\r?\\n would work as well)\n        const emptylinePattern = /^((?:\\r\\n|\\n)[ \\t]*(?:\\r\\n|\\n)+)/; //two or more linebreaks\n        function matchEmptyline(text, offset, matchedTokens) {\n            let remainingText = text.substr(offset);\n            let last = _.last(matchedTokens);\n            //ignore Emptylines after first one (relevant for Emptylines after ignored comments)\n            if (last && tokenMatcher(last, $.Emptyline))\n                return null;\n            let match = emptylinePattern.exec(remainingText);\n            if (match !== null && match[0].length < remainingText.length) { //ignore trailing linebreaks\n                $.emitRemainingDedentTokens(matchedTokens);\n                //TODO: emitRemainingRanges (to be more resistant against unclosed bold and italic ranges)\n                return match;\n            }\n            return null;\n        }\n        $.Emptyline = createToken({\n            name: \"Emptyline\",\n            pattern: matchEmptyline\n        });\n        $.tokens.push($.Emptyline);\n\n        //Indent and Dedent are never matched with their own patterns, instead they get matched in the relations custom patterns\n        $.Indent = createToken({\n            name: \"Indent\",\n            pattern: chevrotain.Lexer.NA\n        });\n        $.tokens.push($.Indent);\n\n        $.Dedent = createToken({\n            name: \"Dedent\",\n            pattern: chevrotain.Lexer.NA\n        });\n        $.tokens.push($.Dedent);\n\n        $.StatementDefinition = createToken({\n            name: \"StatementDefinition\",\n            pattern: /\\[.+?\\]\\:/\n        });\n        $.tokens.push($.StatementDefinition);\n\n        // $.StatementDefinitionByNumber = createToken({\n        //     name: \"StatementDefinitionByNumber\",\n        //     pattern: /\\<(.+?)\\>\\((\\d+)\\)\\:/\n        // });\n        // $.tokens.push($.StatementDefinitionByNumber);\n\n        $.StatementReference = createToken({\n            name: \"StatementReference\",\n            pattern: /\\[.+?\\]/\n        });\n        $.tokens.push($.StatementReference);\n\n        // $.StatementReferenceByNumber = createToken({\n        //     name: \"StatementReferenceByNumber\",\n        //     pattern: /\\<(.+?)\\>\\(\\d+\\)/\n        // });\n        // $.tokens.push($.StatementReferenceByNumber);\n\n\n        $.StatementMention = createToken({\n          name: \"StatementMention\",\n          pattern: /\\@\\[.+?\\][ \\t]?/\n        });\n        $.tokens.push($.StatementMention);\n\n        // $.StatementMentionByNumber = createToken({\n        //     name: \"StatementMentionByNumber\",\n        //     pattern: /\\@\\<(.+?)\\>\\(\\d+\\)/\n        // });\n        // $.tokens.push($.StatementMentionByNumber);\n\n        const statementNumberPattern = /^(?:\\r\\n|\\n|\\r)?[' '\\t]*\\(\\d+\\)/;\n        function matchStatementNumber(text, offset, matchedTokens) {\n            let remainingText = text.substr(offset);\n            var last = _.last(matchedTokens);\n            let startsWithNewline = /^(?:\\r\\n|\\n|\\r)/.exec(remainingText) != null;\n            let afterEmptyline = last && tokenMatcher(last, $.Emptyline);\n\n            //Statement in argument reconstruction:\n            if (_.isEmpty(matchedTokens) || afterEmptyline || startsWithNewline) {\n                let match = statementNumberPattern.exec(remainingText);\n                if (match !== null) {\n                    $.emitRemainingDedentTokens(matchedTokens);\n                    return match;\n                }\n            }\n            return null;\n        }\n        $.StatementNumber = createToken({\n            name: \"StatementNumber\",\n            pattern: matchStatementNumber\n        });\n        $.tokens.push($.StatementNumber);\n\n        $.ArgumentDefinition = createToken({\n            name: \"ArgumentDefinition\",\n            pattern: /\\<.+?\\>\\:/\n        });\n        $.tokens.push($.ArgumentDefinition);\n\n        $.ArgumentReference = createToken({\n            name: \"ArgumentReference\",\n            pattern: /\\<.+?\\>/\n        });\n        $.tokens.push($.ArgumentReference);\n\n        $.ArgumentMention = createToken({\n          name: \"ArgumentMention\",\n          pattern: /\\@\\<.+?\\>[ \\t]?/\n        });\n        $.tokens.push($.ArgumentMention);\n\n        const headingPattern = /^(#+)/;\n        function matchHeadingStart(text, offset, matchedTokens) {\n            let remainingText = text.substr(offset);\n            let last = _.last(matchedTokens);\n            let afterEmptyline = last && tokenMatcher(last, $.Emptyline);\n\n            if (!last || afterEmptyline) {\n                return headingPattern.exec(remainingText);\n            }\n            return null;\n\n        }\n        $.HeadingStart = createToken({\n            name: \"HeadingStart\",\n            pattern: matchHeadingStart\n        });\n        $.tokens.push($.HeadingStart);\n\n        //BOLD and ITALIC ranges\n        function matchBoldOrItalicStart(text, offset, matchedTokens, groups, pattern, rangeType) {\n            let remainingText = text.substr(offset);\n            let match = pattern.exec(remainingText);\n            if (match != null) {\n                $.rangesStack.push(rangeType);\n            }\n            return match;\n        }\n\n        function matchBoldOrItalicEnd(text, offset, matchedTokens, groups, pattern, rangeType) {\n            let lastRange = _.last($.rangesStack);\n            if (lastRange != rangeType)\n                return null;\n            //first check if the last match was skipped Whitespace\n            let skipped = groups[chevrotain.Lexer.SKIPPED];\n            let lastSkipped = _.last(skipped);\n            let lastMatched = _.last(matchedTokens);\n            if (!lastMatched ||\n                (lastSkipped && chevrotain.getEndOffset(lastSkipped) > chevrotain.getEndOffset(lastMatched))) {\n                return null;\n            }\n            let remainingText = text.substr(offset);\n            let match = pattern.exec(remainingText);\n\n            if (match != null) {\n                $.rangesStack.pop();\n            }\n\n            return match;\n        }\n        let matchAsteriskBoldStart = _.partialRight(matchBoldOrItalicStart, /^\\*\\*(?!\\s)/, \"AsteriskBold\");\n        let matchAsteriskBoldEnd = _.partialRight(matchBoldOrItalicEnd, /^\\*\\*(?:[ \\t]|(?=\\n|\\r|\\)|\\}|\\_|\\.|,|!|\\?|;|:|-|\\*|$))/, \"AsteriskBold\");\n\n        let matchUnderscoreBoldStart = _.partialRight(matchBoldOrItalicStart, /^__(?!\\s)/, \"UnderscoreBold\");\n        let matchUnderscoreBoldEnd = _.partialRight(matchBoldOrItalicEnd, /^__(?:[ \\t]|(?=\\n|\\r|\\)|\\}|\\_|\\.|,|!|\\?|;|:|-|\\*|$))/, \"UnderscoreBold\");\n\n        let matchAsteriskItalicStart = _.partialRight(matchBoldOrItalicStart, /^\\*(?!\\s)/, \"AsteriskItalic\");\n        let matchAsteriskItalicEnd = _.partialRight(matchBoldOrItalicEnd, /^\\*(?:[ \\t]|(?=\\n|\\r|\\)|\\}|\\_|\\.|,|!|\\?|;|:|-|\\*|$))/, \"AsteriskItalic\");\n\n        let matchUnderscoreItalicStart = _.partialRight(matchBoldOrItalicStart, /^\\_(?!\\s)/, \"UnderscoreItalic\");\n        let matchUnderscoreItalicEnd = _.partialRight(matchBoldOrItalicEnd, /^\\_(?:[ \\t]|(?=\\n|\\r|\\)|\\}|\\_|\\.|,|!|\\?|;|:|-|\\*|$))/, \"UnderscoreItalic\");\n\n\n        $.AsteriskBoldStart = createToken({\n            name: \"AsteriskBoldStart\",\n            pattern: matchAsteriskBoldStart\n        });\n        $.tokens.push($.AsteriskBoldStart);\n\n        $.AsteriskBoldEnd = createToken({\n            name: \"AsteriskBoldEnd\",\n            pattern: matchAsteriskBoldEnd\n        });\n        $.tokens.push($.AsteriskBoldEnd);\n\n        $.UnderscoreBoldStart = createToken({\n            name: \"UnderscoreBoldStart\",\n            pattern: matchUnderscoreBoldStart\n        });\n        $.tokens.push($.UnderscoreBoldStart);\n\n        $.UnderscoreBoldEnd = createToken({\n            name: \"UnderscoreBoldEnd\",\n            pattern: matchUnderscoreBoldEnd\n        });\n        $.tokens.push($.UnderscoreBoldEnd);\n\n        $.AsteriskItalicStart = createToken({\n            name: \"AsteriskItalicStart\",\n            pattern: matchAsteriskItalicStart\n        });\n        $.tokens.push($.AsteriskItalicStart);\n\n        $.AsteriskItalicEnd = createToken({\n            name: \"AsteriskItalicEnd\",\n            pattern: matchAsteriskItalicEnd\n        });\n        $.tokens.push($.AsteriskItalicEnd);\n\n        $.UnderscoreItalicStart = createToken({\n            name: \"UnderscoreItalicStart\",\n            pattern: matchUnderscoreItalicStart\n        });\n        $.tokens.push($.UnderscoreItalicStart);\n\n        $.UnderscoreItalicEnd = createToken({\n            name: \"UnderscoreItalicEnd\",\n            pattern: matchUnderscoreItalicEnd\n        });\n        $.tokens.push($.UnderscoreItalicEnd);\n\n        $.Comment = createToken({\n            name: \"Comment\",\n            pattern: /(?:<!--(?:.|\\n|\\r)*?-->)|(?:\\/\\*(?:.|\\n|\\r)*?\\*\\/)|(?:\\/\\/.*?(?=\\r\\n|\\n|\\r))/,\n            group: chevrotain.Lexer.SKIPPED\n        });\n        $.tokens.push($.Comment);\n\n        $.Link = createToken({\n            name: \"Link\",\n            pattern: /\\[[^\\]]+?\\]\\([^\\)]+?\\)[ \\t]?/\n        });\n        $.tokens.push($.Link);\n        \n        $.Tag = createToken({\n          name: \"Tag\",\n          pattern: /#(?:\\([^\\)]+\\)|[a-zA-z0-9-\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+)[ \\t]?/\n        });\n        $.tokens.push($.Tag);\n\n        $.Newline = createToken({\n            name: \"Newline\",\n            pattern: /(?:\\r\\n|\\n|\\r)/,\n            group: chevrotain.Lexer.SKIPPED\n        });\n        $.tokens.push($.Newline);\n\n        $.Spaces = createToken({\n            name: \"Spaces\",\n            pattern: /( |\\t)+/,\n            group: chevrotain.Lexer.SKIPPED\n        });\n        $.tokens.push($.Spaces);\n\n        $.EscapedChar = createToken({\n            name: \"EscapedChar\",\n            pattern: /\\\\.(?: )*/\n        });\n        $.tokens.push($.EscapedChar);\n\n        //The rest of the text that is free of any Argdown syntax\n        $.Freestyle = createToken({\n            name: \"Freestyle\",\n            pattern: /[^\\\\\\@\\#\\*\\_\\[\\]\\,\\:\\;\\<\\/\\>\\-\\r\\n\\(\\)]+/\n        });\n        $.tokens.push($.Freestyle);\n\n        //Freestyle text needs to be \"cut up\" by these control characters so that the other rules get a chance to succeed.\n        //Otherwise, every line would simply be lexed as a single Freestyle token.\n        //If these chars are not consumed by other rules, they are lexed as \"useless\" UnusedControlChars. The parser then has to combine Freestyle and UnusedControlChar tokens back together to get \"normal text\" token sequences.\n        //Note that some \"meaningful\" characters (like +) are not listed here, as they are only meaningful after a linebreak and freestyle text already gets \"cut up\" by each line break.\n        $.UnusedControlChar = createToken({\n            name: \"UnusedControlChar\",\n            pattern: /[\\@\\#\\*\\_\\[\\]\\,\\:\\;\\<\\/\\>\\-\\(\\)][ \\t]?/\n        });\n        $.tokens.push($.UnusedControlChar);\n\n        let lexerConfig = {\n            modes: {\n                \"default_mode\": [\n                    $.Comment,\n                    $.EscapedChar, //must come first after $.Comment\n                    $.Emptyline,\n                    // Relation tokens must appear before Spaces, otherwise all indentation will always be consumed as spaces.\n                    // Dedent must appear before Indent for handling zero spaces dedents.\n                    $.Dedent,\n                    $.Indent,\n                    $.InferenceStart, //needs to be lexed before OutgoingAttack (- vs --)\n                    $.IncomingSupport,\n                    $.IncomingAttack,\n                    $.OutgoingSupport,\n                    $.OutgoingAttack,\n                    $.Contradiction,\n                    $.IncomingUndercut,\n                    $.OutgoingUndercut,\n                    $.HeadingStart,\n                    //$.ArgumentStatementStart,\n                    $.StatementNumber,\n                    $.OrderedListItem,\n                    $.UnorderedListItem,\n                    //The ends of Bold and italic ranges need to be lexed before the starts\n                    $.AsteriskBoldEnd, //BoldEnd needs to be lexed before ItalicEnd (** vs *)\n                    $.UnderscoreBoldEnd, //BoldEnd needs to be lexed before ItalicEnd (__ vs _)\n                    $.AsteriskItalicEnd,\n                    $.UnderscoreItalicEnd,\n                    //The starts of Bold and italic ranges need to be lexed after the ends\n                    $.AsteriskBoldStart, //BoldStart needs to be lexed before ItalicStart (** vs *)\n                    $.UnderscoreBoldStart, //BoldStart needs to be lexed before ItalicStart (__ vs _)\n                    $.AsteriskItalicStart,\n                    $.UnderscoreItalicStart,\n                    $.Link, //needs to be lexed before StatementReference\n                    $.Tag,\n                    // $.StatementDefinitionByNumber, // needs to be lexed before ArgumentReference\n                    // $.StatementReferenceByNumber, // needs to be lexed before ArgumentReference\n                    // $.StatementMentionByNumber, // needs to be lexed before ArgumentReference\n                    $.StatementDefinition,\n                    $.StatementReference,\n                    $.StatementMention,\n                    $.ArgumentDefinition,\n                    $.ArgumentReference,\n                    $.ArgumentMention,\n                    $.Newline,\n                    $.Spaces,\n                    $.Freestyle,\n                    $.UnusedControlChar\n                ],\n                \"inference_mode\": [\n                    $.Comment,\n                    $.InferenceEnd,\n                    $.MetadataStart,\n                    $.MetadataEnd,\n                    $.MetadataStatementEnd,\n                    $.ListDelimiter,\n                    $.Colon,\n                    $.Newline,\n                    $.Spaces,\n                    $.Freestyle,\n                    $.UnusedControlChar\n                ]\n            },\n\n            defaultMode: \"default_mode\"\n        };\n\n        this._lexer = new chevrotain.Lexer(lexerConfig);\n\n    }\n    tokensToString(tokens) {\n      let str = \"\";\n      for (let token of tokens) {\n          str += getTokenConstructor(token).tokenName + \" \" + token.image +\"\\n\";\n      }\n      return str;\n    }\n    tokenize(text) {\n        this.init();\n\n        let lexResult = this._lexer.tokenize(text);\n        if (lexResult.errors.length > 0) {\n            throw new Error(\"sad sad panda lexing errors detected\");\n        }\n        \n        //remove trailing Emptyline (parser cannot cope with it)\n        if(tokenMatcher(_.last(lexResult.tokens), this.Emptyline)){\n          lexResult.tokens.pop();\n        }\n\n        this.emitRemainingDedentTokens(lexResult.tokens);\n\n        return lexResult;\n    }\n}\n\nmodule.exports = {\n    ArgdownLexer: new ArgdownLexer()\n};\n"]}