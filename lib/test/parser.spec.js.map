{"version":3,"sources":["../../test/parser.spec.ts"],"names":["walker","ArgdownTreeWalker","describe","it","source","lexResult","parser","input","tokens","argdown","errors","to","be","empty","fs","readFileSync","exist","ast","children","startLine","equal","pcsTail","name","tokenType","tokenName","statements","on","request","response","node","walk","Logger"],"mappings":"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","sourcesContent":["//import { before, after, describe, it } from 'mocha';\nimport { expect } from \"chai\";\nimport fs from \"fs\";\nimport { tokenize, parser, ArgdownTreeWalker } from \"../src/index\";\nimport { Logger } from \"../src/index\";\n\nconst walker = new ArgdownTreeWalker();\n\ndescribe(\"Parser\", function() {\n  it(\"can parse argdown with leading and trailing emptylines\", function() {\n    let source = \"\\n\\n\\n\\n\\nHallo World!\\n\\n\\n<!-- Comment -->\\n\\n\";\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse complex argdown file\", function() {\n    let source = fs.readFileSync(\"./test/veggie_debate.argdown\", \"utf8\");\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse argument definitions and references\", function() {\n    let source = fs.readFileSync(\"./test/parser-arguments.argdown\", \"utf8\");\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can return errors\", function() {\n    let source = \"Text <Title>:\\n\\n+ text\";\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    //console.log(parser.errors[0]);\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.exist;\n  });\n  it(\"can escape characters\", function() {\n    let source = \"<Title>: text \\\\[text\\\\]\";\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can add line numbers\", function() {\n    let source = `# Heading\n\nStatement\n\n[Statement Definition]: Bla\n    + support relation\n    - attack relation\n    +> incoming support\n    -> incoming attack\n\n[Statement Reference] \n  >< Contradiction\n\n<Argument Definition>: Bla\n\n<Argument Reference>\n\n(1) A\n(2) B\n----\n(3) C\n\n 1. A\n 2. B\n\n * A\n * B\n`;\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    let ast = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n    //console.log(parser.astToJsonString(ast));\n    expect(ast.children[0].startLine).to.equal(1); // Heading\n    expect(ast.children[1].startLine).to.equal(3); // Statement\n    expect(ast.children[2].startLine).to.equal(5); // Statement Definition\n    expect(ast.children[2].children[1].children[1].startLine).to.equal(6); // Outgoing Support\n    expect(ast.children[2].children[1].children[2].startLine).to.equal(7); // Outgoing Attack\n    expect(ast.children[2].children[1].children[3].startLine).to.equal(8); // Incoming Support\n    expect(ast.children[2].children[1].children[4].startLine).to.equal(9); // Incoming Attack\n    expect(ast.children[3].startLine).to.equal(11); // Statement Reference\n    expect(ast.children[3].children[1].children[2].startLine).to.equal(12); // Contradiction\n    expect(ast.children[4].startLine).to.equal(14); // Argument Definition\n    expect(ast.children[5].startLine).to.equal(16); // Argument Reference\n    expect(ast.children[6].children[0].startLine).to.equal(18); // Argument Statement 1\n    expect(ast.children[6].children[1].children[0].startLine).to.equal(19); // Argument Statement 2\n    expect(ast.children[6].children[1].children[1].startLine).to.equal(20); // Inference\n    expect(ast.children[6].children[1].children[2].startLine).to.equal(21); // Argument Statement 3\n    expect(ast.children[7].children[1].startLine).to.equal(23); // Ordered List item 1\n    expect(ast.children[7].children[2].startLine).to.equal(24); // Ordered List item 2\n    expect(ast.children[8].children[1].startLine).to.equal(26); // Unordered List item 1\n    expect(ast.children[8].children[2].startLine).to.equal(27); // Unordered List item 2\n  });\n  // it(\"can return custom NoViableAltMessage\", function () {\n  //   let source = `asdda\n  // + adas [sdsd] sadd`;\n  //   let lexResult = tokenize(source);\n  //   parser.input = lexResult.tokens;\n  //   let parseResult = parser.argdown();\n  //   console.log(parser.errors[0]);\n  // });\n  it(\"can escape characters\", function() {\n    let source = \"<Title>: text \\\\[text\\\\]\";\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse inference relations\", function() {\n    let source = `\n    (1) A\n    (2) B\n    ----\n      <_ C\n    (3) D\n`;\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    let ast = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n    //console.log(parser.astToString(ast));\n    const pcsTail = ast.children[0].children[1];\n    expect(pcsTail.children[1]).to.exist; // inference\n    expect(pcsTail.children[1].name).to.equal(\"inference\");\n    expect(pcsTail.children[1].children[2]).to.exist; // relations\n    expect(pcsTail.children[1].children[2].name).to.equal(\"relations\"); // relations\n    expect(pcsTail.children[1].children[2].children[0].tokenType.tokenName).to.equal(\"Indent\");\n    expect(pcsTail.children[1].children[2].children[1].name).to.equal(\"outgoingUndercut\");\n  });\n});\n\ndescribe(\"ArgdownTreeWalker\", function() {\n  it(\"can walk\", function() {\n    let source = \"Hallo Welt!\";\n    let lexResult = tokenize(source);\n    parser.input = lexResult.tokens;\n    let ast = parser.argdown();\n    let statements = 0;\n    walker.on(\"statementEntry\", (request, response, node) => {\n      statements++;\n      expect(node.name).to.equal(\"statement\");\n    });\n    walker.walk({}, { ast: ast }, new Logger());\n    expect(statements).to.equal(1);\n  });\n});\n"],"file":"parser.spec.js"}