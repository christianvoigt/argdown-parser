{"version":3,"sources":["../../test/parser.spec.js"],"names":["lexer","parser","walker","describe","it","source","lexResult","tokenize","input","tokens","parseResult","argdown","errors","to","be","empty","readFileSync","exit","statements","on","node","name","equal","walk"],"mappings":";;AACA;;AACA;;;;AACA;;;;AAEA,IAAMA,2BAAN,C,CALA;;AAMA,IAAMC,6BAAN;AACA,IAAMC,SAAS,8BAAf;;AAEAC,SAAS,QAAT,EAAmB,YAAW;AAC5BC,KAAG,wDAAH,EAA6D,YAAU;AACrE,QAAIC,SAAS,kCAAb;AACA,QAAIC,YAAYN,MAAMO,QAAN,CAAeF,MAAf,CAAhB;AACAJ,WAAOO,KAAP,GAAeF,UAAUG,MAAzB;AACA,QAAIC,cAAcT,OAAOU,OAAP,EAAlB;AACA,sBAAOL,UAAUM,MAAjB,EAAyBC,EAAzB,CAA4BC,EAA5B,CAA+BC,KAA/B;AACA,sBAAOd,OAAOW,MAAd,EAAsBC,EAAtB,CAAyBC,EAAzB,CAA4BC,KAA5B;AACD,GAPD;AAQAX,KAAG,gCAAH,EAAqC,YAAU;AAC7C,QAAIC,SAAS,aAAGW,YAAH,CAAgB,8BAAhB,EAAgD,MAAhD,CAAb;AACA,QAAIV,YAAYN,MAAMO,QAAN,CAAeF,MAAf,CAAhB;AACAJ,WAAOO,KAAP,GAAeF,UAAUG,MAAzB;AACA,QAAIC,cAAcT,OAAOU,OAAP,EAAlB;AACA,sBAAOL,UAAUM,MAAjB,EAAyBC,EAAzB,CAA4BC,EAA5B,CAA+BC,KAA/B;AACA,sBAAOd,OAAOW,MAAd,EAAsBC,EAAtB,CAAyBC,EAAzB,CAA4BC,KAA5B;AACD,GAPD;AAQAX,KAAG,+CAAH,EAAoD,YAAU;AAC5D,QAAIC,SAAS,aAAGW,YAAH,CAAgB,iCAAhB,EAAmD,MAAnD,CAAb;AACA,QAAIV,YAAYN,MAAMO,QAAN,CAAeF,MAAf,CAAhB;AACAJ,WAAOO,KAAP,GAAeF,UAAUG,MAAzB;AACA,QAAIC,cAAcT,OAAOU,OAAP,EAAlB;AACA,sBAAOL,UAAUM,MAAjB,EAAyBC,EAAzB,CAA4BC,EAA5B,CAA+BC,KAA/B;AACA,sBAAOd,OAAOW,MAAd,EAAsBC,EAAtB,CAAyBC,EAAzB,CAA4BC,KAA5B;AACD,GAPD;AAQAX,KAAG,mBAAH,EAAwB,YAAU;AAChC,QAAIC,SAAS,yBAAb;AACA,QAAIC,YAAYN,MAAMO,QAAN,CAAeF,MAAf,CAAhB;AACAJ,WAAOO,KAAP,GAAeF,UAAUG,MAAzB;AACA,QAAIC,cAAcT,OAAOU,OAAP,EAAlB;AACA,sBAAOL,UAAUM,MAAjB,EAAyBC,EAAzB,CAA4BC,EAA5B,CAA+BC,KAA/B;AACA,sBAAOd,OAAOW,MAAd,EAAsBC,EAAtB,CAAyBI,IAAzB;AACD,GAPD;AAQD,CAjCD;;AAmCAd,SAAS,mBAAT,EAA8B,YAAW;AACvCC,KAAG,UAAH,EAAe,YAAU;AACvB,QAAIC,SAAS,aAAb;AACA,QAAIC,YAAYN,MAAMO,QAAN,CAAeF,MAAf,CAAhB;AACAJ,WAAOO,KAAP,GAAeF,UAAUG,MAAzB;AACA,QAAIC,cAAcT,OAAOU,OAAP,EAAlB;AACA,QAAIO,aAAa,CAAjB;AACAhB,WAAOiB,EAAP,CAAU,gBAAV,EAA2B,UAACC,IAAD,EAAQ;AAACF,mBAAc,kBAAOE,KAAKC,IAAZ,EAAkBR,EAAlB,CAAqBS,KAArB,CAA2B,WAA3B;AAAyC,KAA3F;AACApB,WAAOqB,IAAP,CAAYb,WAAZ;AACA,sBAAOQ,UAAP,EAAmBL,EAAnB,CAAsBS,KAAtB,CAA4B,CAA5B;AACD,GATD;AAUD,CAXD","file":"parser.spec.js","sourcesContent":["//import { before, after, describe, it } from 'mocha';\nimport { expect } from 'chai';\nimport fs from 'fs';\nimport {ArgdownLexer, ArgdownParser, ArgdownTreeWalker} from '../src/index.js';\n\nconst lexer = ArgdownLexer;\nconst parser = ArgdownParser;\nconst walker = new ArgdownTreeWalker();\n\ndescribe(\"Parser\", function() {\n  it(\"can parse argdown with leading and trailing emptylines\", function(){\n    let source = \"\\n\\n\\n\\n\\nHallo World!\\n\\n\\n\\n\\n\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let parseResult = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse complex argdown file\", function(){\n    let source = fs.readFileSync(\"./test/veggie_debate.argdown\", 'utf8');\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let parseResult = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse argument definitions and references\", function(){\n    let source = fs.readFileSync(\"./test/parser-arguments.argdown\", 'utf8');\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let parseResult = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can return errors\", function(){\n    let source = \"Text <Title>:\\n\\n+ text\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let parseResult = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.exit;\n  });\n});\n\ndescribe(\"ArgdownTreeWalker\", function() {\n  it(\"can walk\", function(){\n    let source = \"Hallo Welt!\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let parseResult = parser.argdown();\n    let statements = 0;\n    walker.on('statementEntry',(node)=>{statements++; expect(node.name).to.equal('statement');});\n    walker.walk(parseResult);\n    expect(statements).to.equal(1);\n  });\n});\n"]}