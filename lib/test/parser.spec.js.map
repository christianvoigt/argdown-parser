{"version":3,"sources":["../../test/parser.spec.js"],"names":["lexer","parser","walker","describe","it","source","lexResult","tokenize","input","tokens","argdown","errors","to","be","empty","readFileSync","exist","ast","children","startLine","equal","statements","on","request","response","node","name","walk"],"mappings":"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","file":"parser.spec.js","sourcesContent":["//import { before, after, describe, it } from 'mocha';\nimport { expect } from 'chai';\nimport fs from 'fs';\nimport {ArgdownLexer, ArgdownParser, ArgdownTreeWalker} from '../src/index.js';\n\nconst lexer = ArgdownLexer;\nconst parser = ArgdownParser;\nconst walker = new ArgdownTreeWalker();\n\ndescribe(\"Parser\", function() {\n  it(\"can parse argdown with leading and trailing emptylines\", function(){\n    let source = \"\\n\\n\\n\\n\\nHallo World!\\n\\n\\n<!-- Comment -->\\n\\n\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse complex argdown file\", function(){\n    let source = fs.readFileSync(\"./test/veggie_debate.argdown\", 'utf8');\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can parse argument definitions and references\", function(){\n    let source = fs.readFileSync(\"./test/parser-arguments.argdown\", 'utf8');\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can return errors\", function(){\n    let source = \"Text <Title>:\\n\\n+ text\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    //console.log(parser.errors[0]);\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.exist;\n  });\n  it(\"can escape characters\", function () {\n    let source = \"<Title>: text \\\\[text\\\\]\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n  });\n  it(\"can add line numbers\", function () {\n    let source = `# Heading\n\nStatement\n\n[Statement Definition]: Bla\n    + support relation\n    - attack relation\n    +> incoming support\n    -> incoming attack\n\n[Statement Reference] \n  >< Contradiction\n\n<Argument Definition>: Bla\n\n<Argument Reference>\n\n(1) A\n(2) B\n----\n(3) C\n\n 1. A\n 2. B\n\n * A\n * B\n`;\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let ast = parser.argdown();\n    expect(lexResult.errors).to.be.empty;\n    expect(parser.errors).to.be.empty;\n    //console.log(parser.astToJsonString(ast));\n    expect(ast.children[0].startLine).to.equal(1); // Heading\n    expect(ast.children[1].startLine).to.equal(3); // Statement\n    expect(ast.children[2].startLine).to.equal(5); // Statement Definition\n    expect(ast.children[2].children[1].children[1].startLine).to.equal(6); // Outgoing Support\n    expect(ast.children[2].children[1].children[2].startLine).to.equal(7); // Outgoing Attack\n    expect(ast.children[2].children[1].children[3].startLine).to.equal(8); // Incoming Support\n    expect(ast.children[2].children[1].children[4].startLine).to.equal(9); // Incoming Attack\n    expect(ast.children[3].startLine).to.equal(11); // Statement Reference\n    expect(ast.children[3].children[1].children[2].startLine).to.equal(12); // Contradiction\n    expect(ast.children[4].startLine).to.equal(14); // Argument Definition\n    expect(ast.children[5].startLine).to.equal(16); // Argument Reference\n    expect(ast.children[6].children[0].startLine).to.equal(18); // Argument Statement 1\n    expect(ast.children[6].children[1].children[0].startLine).to.equal(19); // Argument Statement 2\n    expect(ast.children[6].children[1].children[1].startLine).to.equal(20); // Inference\n    expect(ast.children[6].children[1].children[2].startLine).to.equal(21); // Argument Statement 3\n    expect(ast.children[7].children[1].startLine).to.equal(23); // Ordered List item 1\n    expect(ast.children[7].children[2].startLine).to.equal(24); // Ordered List item 2\n    expect(ast.children[8].children[1].startLine).to.equal(26); // Unordered List item 1\n    expect(ast.children[8].children[2].startLine).to.equal(27); // Unordered List item 2\n  });\n  // it(\"can return custom NoViableAltMessage\", function () {\n  //   let source = `asdda\n  // + adas [sdsd] sadd`;\n  //   let lexResult = lexer.tokenize(source);\n  //   parser.input = lexResult.tokens;\n  //   let parseResult = parser.argdown();\n  //   console.log(parser.errors[0]);\n  // });\n});\n\ndescribe(\"ArgdownTreeWalker\", function() {\n  it(\"can walk\", function(){\n    let source = \"Hallo Welt!\";\n    let lexResult = lexer.tokenize(source);\n    parser.input = lexResult.tokens;\n    let ast = parser.argdown();\n    let statements = 0;\n    walker.on('statementEntry',(request, response, node)=>{statements++; expect(node.name).to.equal('statement');});\n    walker.walk({}, {ast: ast});\n    expect(statements).to.equal(1);\n  });\n});\n"]}