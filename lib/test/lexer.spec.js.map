{"version":3,"sources":["../../test/lexer.spec.js"],"names":["i","currentTokens","expectToken","tokenType","to","be","true","startTest","tokens","lexer","describe","it","source","readFileSync","result","tokenize","OutgoingSupport","OutgoingAttack","IncomingSupport","IncomingAttack","Contradiction","IncomingUndercut","OutgoingUndercut","Freestyle","Emptyline","HeadingStart","ArgumentMention","StatementMention","UnusedControlChar","Indent","UnorderedListItem","OrderedListItem","Dedent","StatementNumber","InferenceStart","ListDelimiter","MetadataStart","Colon","MetadataStatementEnd","MetadataEnd","InferenceEnd","UnderscoreBoldStart","UnderscoreBoldEnd","UnderscoreItalicStart","UnderscoreItalicEnd","AsteriskBoldStart","AsteriskBoldEnd","AsteriskItalicStart","AsteriskItalicEnd","StatementReference","StatementDefinition","ArgumentReference","ArgumentDefinition","Link","Tag","length","equal","EscapedChar"],"mappings":"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","file":"lexer.spec.js","sourcesContent":["//import { before, after, describe, it } from 'mocha';\nimport { expect } from 'chai';\nimport fs from 'fs';\nimport { ArgdownLexer } from '../src/ArgdownLexer.js';\nimport { tokenMatcher } from 'chevrotain';\n\nlet i = 0;\nlet currentTokens = null;\nfunction expectToken(tokenType) {\n  //expect(currentTokens[i]).to.be.an.instanceof(tokenType);\n  expect(tokenMatcher(currentTokens[i], tokenType)).to.be.true;\n  i++;\n}\nfunction startTest(tokens) {\n  currentTokens = tokens;\n  i = 0;\n}\nconst lexer = ArgdownLexer;\n\n\ndescribe(\"Lexer\", function () {\n  it(\"recognizes incoming and outgoing relations\", function () {\n    let source = fs.readFileSync(\"./test/lexer-relations.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.IncomingSupport);\n    expectToken(lexer.IncomingAttack);\n    expectToken(lexer.Contradiction);\n    expectToken(lexer.IncomingUndercut);\n    expectToken(lexer.OutgoingUndercut);\n  });\n  it(\"can distinguish between Emptyline and Newline\", function () {\n    let source = fs.readFileSync(\"./test/lexer-emptyline.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can lex mentions\", function () {\n    let source = fs.readFileSync(\"./test/lexer-mentions.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.HeadingStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ArgumentMention);\n    expectToken(lexer.StatementMention);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.ArgumentMention);\n    expectToken(lexer.StatementMention);\n  });\n  it(\"can lex headings\", function () {\n    let source = fs.readFileSync(\"./test/lexer-heading.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.HeadingStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.HeadingStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can lex ordered and unordered lists\", function () {\n    let source = fs.readFileSync(\"./test/lexer-lists.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Indent);\n    expectToken(lexer.UnorderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.UnorderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.UnorderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n  });\n  it(\"can lex an argument reconstruction\", function () {\n    let source = fs.readFileSync(\"./test/lexer-argument.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.StatementNumber);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.StatementNumber);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.InferenceStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ListDelimiter);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.MetadataStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Colon);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ListDelimiter);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.MetadataStatementEnd);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Colon);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ListDelimiter);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.MetadataEnd);\n    expectToken(lexer.InferenceEnd);\n    expectToken(lexer.StatementNumber);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can dedent on Emptyline\", function () {\n    let source = fs.readFileSync(\"./test/lexer-emptyline-dedent.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can ignore Newlines in relations\", function () {\n    let source = fs.readFileSync(\"./test/lexer-linebreak.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n  });\n  it(\"can lex bold and italic text\", function () {\n    let source = fs.readFileSync(\"./test/lexer-italic-bold.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    // console.log(lexer.tokensToString(result.tokens));\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.AsteriskBoldEnd);\n\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.UnderscoreBoldEnd);\n\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.UnusedControlChar);    \n  });\n  it(\"can lex complex indentation\", function () {\n    let source = fs.readFileSync(\"./test/lexer-indentation.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.IncomingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.IncomingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n\n  });\n  it(\"can recognize argument and statement references and definitions\", function () {\n    let source = fs.readFileSync(\"./test/lexer-definitions-references.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.StatementReference);\n    expectToken(lexer.StatementDefinition);\n    expectToken(lexer.ArgumentReference);\n    expectToken(lexer.ArgumentDefinition);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can ignore comments\", function () {\n    let source = fs.readFileSync(\"./test/lexer-comment.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can recognize links and tags\", function () {\n    let source = fs.readFileSync(\"./test/lexer-links-and-tags.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    expectToken(lexer.StatementDefinition);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.Link);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Tag);\n    expectToken(lexer.Tag);\n    expectToken(lexer.Tag);\n  });\n  it(\"can ignore trailing Emptyline before comment\", function () {\n    let source = fs.readFileSync(\"./test/lexer-trailing-emptyline.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expect(result.tokens.length).to.equal(3);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.StatementDefinition);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can lex Windows line endings\", function () {\n    let source = fs.readFileSync(\"./test/lexer-windows-line-endings.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n  });\n  it(\"can lex escaped chars\", function () {\n    let source = fs.readFileSync(\"./test/lexer-escaped-chars.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);  \n  });  \n  // it(\"can lex statement references, definitions and mentions by number\", function () {\n  //   let source = fs.readFileSync(\"./test/lexer-statements-by-number.argdown\", 'utf8');\n  //   const result = lexer.tokenize(source);\n  //   startTest(result.tokens);\n  //   console.log(lexer.tokensToString(result.tokens));\n  //   //expect(result.tokens.length).to.equal(5);\n  //   expectToken(lexer.StatementDefinitionByNumber);\n  //   expectToken(lexer.Freestyle);\n  //   expectToken(lexer.StatementReferenceByNumber);\n  //   expectToken(lexer.StatementMentionByNumber);\n  //   // expectToken(lexer.Dedent);\n  // });\n\n});\n"]}