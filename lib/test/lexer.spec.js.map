{"version":3,"sources":["../../test/lexer.spec.js"],"names":["i","currentTokens","expectToken","tokenType","to","be","true","startTest","tokens","lexer","describe","it","source","readFileSync","result","tokenize","OutgoingSupport","OutgoingAttack","IncomingSupport","IncomingAttack","Contradiction","IncomingUndercut","OutgoingUndercut","Freestyle","Emptyline","HeadingStart","ArgumentMention","StatementMention","UnusedControlChar","Indent","UnorderedListItem","OrderedListItem","Dedent","StatementNumber","InferenceStart","ListDelimiter","MetadataStart","Colon","MetadataStatementEnd","MetadataEnd","InferenceEnd","UnderscoreBoldStart","UnderscoreBoldEnd","UnderscoreItalicStart","UnderscoreItalicEnd","AsteriskBoldStart","AsteriskBoldEnd","AsteriskItalicStart","AsteriskItalicEnd","StatementReference","StatementDefinition","ArgumentReference","ArgumentDefinition","Link","Tag","length","equal","EscapedChar","expectTokenLocation"],"mappings":"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","file":"lexer.spec.js","sourcesContent":["//import { before, after, describe, it } from 'mocha';\nimport { expect } from 'chai';\nimport fs from 'fs';\nimport { ArgdownLexer } from '../src/ArgdownLexer.js';\nimport { tokenMatcher } from 'chevrotain';\n\nlet i = 0;\nlet currentTokens = null;\nfunction expectToken(tokenType) {\n  //expect(currentTokens[i]).to.be.an.instanceof(tokenType);\n  expect(tokenMatcher(currentTokens[i], tokenType)).to.be.true;\n  i++;\n}\nfunction startTest(tokens) {\n  currentTokens = tokens;\n  i = 0;\n}\nconst lexer = ArgdownLexer;\n\n\ndescribe(\"Lexer\", function () {\n  it(\"recognizes incoming and outgoing relations\", function () {\n    let source = fs.readFileSync(\"./test/lexer-relations.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.IncomingSupport);\n    expectToken(lexer.IncomingAttack);\n    expectToken(lexer.Contradiction);\n    expectToken(lexer.IncomingUndercut);\n    expectToken(lexer.OutgoingUndercut);\n  });\n  it(\"can distinguish between Emptyline and Newline\", function () {\n    let source = fs.readFileSync(\"./test/lexer-emptyline.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can lex mentions\", function () {\n    let source = fs.readFileSync(\"./test/lexer-mentions.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.HeadingStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ArgumentMention);\n    expectToken(lexer.StatementMention);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.ArgumentMention);\n    expectToken(lexer.StatementMention);\n  });\n  it(\"can lex headings\", function () {\n    let source = fs.readFileSync(\"./test/lexer-heading.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.HeadingStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.HeadingStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can lex ordered and unordered lists\", function () {\n    let source = fs.readFileSync(\"./test/lexer-lists.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Indent);\n    expectToken(lexer.UnorderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.UnorderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.OrderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.UnorderedListItem);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n  });\n  it(\"can lex an argument reconstruction\", function () {\n    let source = fs.readFileSync(\"./test/lexer-argument.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.StatementNumber);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.StatementNumber);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.InferenceStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ListDelimiter);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.MetadataStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Colon);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ListDelimiter);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.MetadataStatementEnd);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Colon);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.ListDelimiter);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.MetadataEnd);\n    expectToken(lexer.InferenceEnd);\n    expectToken(lexer.StatementNumber);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can dedent on Emptyline\", function () {\n    let source = fs.readFileSync(\"./test/lexer-emptyline-dedent.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can ignore Newlines in relations\", function () {\n    let source = fs.readFileSync(\"./test/lexer-linebreak.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n  });\n  it(\"can lex bold and italic text\", function () {\n    let source = fs.readFileSync(\"./test/lexer-italic-bold.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    // console.log(lexer.tokensToString(result.tokens));\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.AsteriskBoldEnd);\n\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.UnderscoreBoldEnd);\n\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreItalicStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreItalicEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.AsteriskBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.AsteriskBoldEnd);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.UnderscoreBoldStart);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnderscoreBoldEnd);\n    expectToken(lexer.UnusedControlChar);    \n  });\n  it(\"can lex complex indentation\", function () {\n    let source = fs.readFileSync(\"./test/lexer-indentation.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.IncomingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.Dedent);\n    expectToken(lexer.IncomingAttack);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n\n  });\n  it(\"can recognize argument and statement references and definitions\", function () {\n    let source = fs.readFileSync(\"./test/lexer-definitions-references.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.StatementReference);\n    expectToken(lexer.StatementDefinition);\n    expectToken(lexer.ArgumentReference);\n    expectToken(lexer.ArgumentDefinition);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can ignore comments\", function () {\n    let source = fs.readFileSync(\"./test/lexer-comment.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can recognize links and tags\", function () {\n    let source = fs.readFileSync(\"./test/lexer-links-and-tags.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    expectToken(lexer.StatementDefinition);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.UnusedControlChar);\n    expectToken(lexer.Link);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Tag);\n    expectToken(lexer.Tag);\n    expectToken(lexer.Tag);\n  });\n  it(\"can ignore trailing Emptyline before comment\", function () {\n    let source = fs.readFileSync(\"./test/lexer-trailing-emptyline.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    expect(result.tokens.length).to.equal(3);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.StatementDefinition);\n    expectToken(lexer.Freestyle);\n  });\n  it(\"can parse Windows line endings\", function () {\n    let source = fs.readFileSync(\"./test/lexer-windows-line-endings.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n  });\n  it(\"can lex escaped chars\", function () {\n    let source = fs.readFileSync(\"./test/lexer-escaped-chars.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.EscapedChar);\n    expectToken(lexer.Freestyle);  \n  });  \n  it(\"can save correct token location data\", function () {\n    let source = fs.readFileSync(\"./test/lexer-token-locations.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokenLocationsToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectTokenLocation(0, 0, 1, 1, 1, 1);\n    expectTokenLocation(2, 2, 2, 2, 1, 1); //offset = 2 because of ignored line break\n    expectTokenLocation(4, 5, 3, 3, 1, 2);\n    expectTokenLocation(6, 6, 3, 3, 3, 3);\n    expectTokenLocation(7, 11, 3, 3, 4, 8); //@[A]\n    expectTokenLocation(12, 12, 3, 3, 9, 9); //ItalicStart\n    expectTokenLocation(13, 13, 3, 3, 10, 10);\n    expectTokenLocation(14, 14, 3, 3, 11, 11); //ItalicEnd\n    expectTokenLocation(15, 16, 3, 4, 12, 1); //Emptyline\n    expectTokenLocation(17, 20, 5, 5, 1, 4); //<B>:\n    expectTokenLocation(22, 22, 5, 5, 6, 6); //skipped whitespace at offset 21\n    expectTokenLocation(24, 27, 6, 6, 1, 4); // Indent (4 spaces)\n    expectTokenLocation(23, 28, 5, 6, 7, 5); // + (including linebreak and 4 spaces for indentation)\n    expectTokenLocation(30, 30, 6, 6, 7, 7); \n    expectTokenLocation(32, 39, 7, 7, 1, 8); // Indent (8 spaces)\n    expectTokenLocation(31, 41, 6, 7, 8, 10); // -> including linebreak and spaces\n    expectTokenLocation(43, 43, 7, 7, 12, 12); // skipped whitespace at offset 42\n    expectTokenLocation(44, 44, 8, 8, 1, 1); // Dedent is always at next line at column 1\n    expectTokenLocation(44, 44, 8, 8, 1, 1); // Dedent is always at next line at column 1\n  });\n  it(\"can save correct token location data if first line is empty\", function () {\n    let source = fs.readFileSync(\"./test/lexer-token-locations-first-line-empty.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokenLocationsToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectTokenLocation(1, 1, 2, 2, 1, 1); //First newline skipped\n    expectTokenLocation(3, 3, 3, 3, 1, 1); //Second newline skipped\n  });  \n  it(\"can lex relation after empty line\", function () {\n    let source = fs.readFileSync(\"./test/lexer-relation-after-emptyline.argdown\", 'utf8');\n    const result = lexer.tokenize(source);\n    startTest(result.tokens);\n    //console.log(lexer.tokensToString(result.tokens));\n    //expect(result.tokens.length).to.equal(5);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Emptyline);\n    expectToken(lexer.Indent);\n    expectToken(lexer.OutgoingSupport);\n    expectToken(lexer.Freestyle);\n    expectToken(lexer.Dedent);\n  }); \n  // it(\"can lex statement references, definitions and mentions by number\", function () {\n  //   let source = fs.readFileSync(\"./test/lexer-statements-by-number.argdown\", 'utf8');\n  //   const result = lexer.tokenize(source);\n  //   startTest(result.tokens);\n  //   console.log(lexer.tokensToString(result.tokens));\n  //   //expect(result.tokens.length).to.equal(5);\n  //   expectToken(lexer.StatementDefinitionByNumber);\n  //   expectToken(lexer.Freestyle);\n  //   expectToken(lexer.StatementReferenceByNumber);\n  //   expectToken(lexer.StatementMentionByNumber);\n  //   // expectToken(lexer.Dedent);\n  // });\n\n});\n"]}