{"version":3,"sources":["../../test/MapPlugin.spec.ts"],"names":["app","ArgdownApplication","parserPlugin","ParserPlugin","addPlugin","modelPlugin","ModelPlugin","mapPlugin","MapPlugin","statementSelectionMode","StatementSelectionMode","ALL","describe","it","source","request","process","input","map","WITH_TITLE","excludeDisconnected","result","run","mapResponse","nodes","length","to","equal","title","labelTitle","labelText","TOP_LEVEL","logLevel","edges","WITH_RELATIONS","relationType","equals","RelationType","ATTACK","from","SUPPORT","section2","children","section3","d","statements"],"mappings":"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","sourcesContent":["import { expect } from \"chai\";\nimport {\n  ArgdownApplication,\n  ParserPlugin,\n  ModelPlugin,\n  MapPlugin,\n  IMapResponse,\n  IMapRequest,\n  IGroupMapNode,\n  RelationType,\n  StatementSelectionMode\n} from \"../src/index\";\nimport { toJSON } from \"../src/model/toJSON\";\n\nconst app = new ArgdownApplication();\nconst parserPlugin = new ParserPlugin();\napp.addPlugin(parserPlugin, \"parse-input\");\nconst modelPlugin = new ModelPlugin();\napp.addPlugin(modelPlugin, \"build-model\");\nconst mapPlugin = new MapPlugin({ statementSelectionMode: StatementSelectionMode.ALL });\napp.addPlugin(mapPlugin, \"make-map\");\n\ndescribe(\"MapPlugin\", function() {\n  it(\"selects statement with title if statementSelectionMode is 'with-title'\", function() {\n    let source = `\n        [S1]: test\n            - [S2]: test\n\n        Another Statement\n\n        <A1>: Test\n\n        (1) A\n        (2) B\n        ----\n        (3) [S2]\n    `;\n    const request: IMapRequest = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: StatementSelectionMode.WITH_TITLE,\n        excludeDisconnected: false\n      }\n    };\n    let result: IMapResponse = app.run(request);\n    // console.log(toJSON(result.map!, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.arguments);\n    const mapResponse = <IMapResponse>result;\n    expect(mapResponse.map!.nodes.length).to.equal(3);\n    expect(mapResponse.map!.nodes[0].title).to.equal(\"S1\");\n    expect(mapResponse.map!.nodes[0].labelTitle).to.equal(\"S1\");\n    expect(mapResponse.map!.nodes[0].labelText).to.equal(\"test\");\n    expect(mapResponse.map!.nodes[1].title).to.equal(\"S2\");\n    expect(mapResponse.map!.nodes[2].title).to.equal(\"A1\");\n  });\n  it(\"selects top-level statement if statementSelectionMode is 'top-level'\", function() {\n    let source = `\n        [S1]: test\n            - [S2]: test\n\n        <A>: Test\n\n        (1) A\n        (2) B\n        ----\n        (3) [S2]\n    `;\n    const request: IMapRequest = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: StatementSelectionMode.TOP_LEVEL,\n        excludeDisconnected: false\n      },\n      logLevel: \"error\"\n    };\n    let result: IMapResponse = app.run(request);\n    // console.log(toJSON(result.map!, null, 2));\n    // console.log(toJSON(result.statements!, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.arguments);\n    const mapResponse = <IMapResponse>result;\n    expect(mapResponse.map!.nodes.length).to.equal(2);\n    expect(mapResponse.map!.nodes[0].title).to.equal(\"S1\");\n  });\n  it(\"can create map from one statement and two argument definitions\", function() {\n    let source = `\n    <Argument 1>\n      + [Statement 1]: Hello World!\n          + <Argument 2>: Description\n    `;\n    let result = app.run({\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source\n    });\n    //console.log(JSON.stringify(result.map, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.arguments);\n    const mapResponse = <IMapResponse>result;\n    expect(mapResponse.map!.nodes.length).to.equal(3);\n    expect(mapResponse.map!.nodes[0].title).to.equal(\"Statement 1\");\n    expect(mapResponse.map!.nodes[1].title).to.equal(\"Argument 1\");\n    expect(mapResponse.map!.nodes[2].title).to.equal(\"Argument 2\");\n    expect(mapResponse.map!.edges.length).to.equal(2);\n  });\n  it(\"can create a map from two argument reconstructions\", function() {\n    let source = `<Argument 1>\n\n(1)[Statement 1]: A\n(2)[Statement 2]: B\n----\n(3)[Statement 3]: C\n\n<Argument 2>\n\n(1)[Statement 4]: A\n(2)[Statement 5]: B\n----\n(3)[Statement 6]: C\n    ->[Statement 1]`;\n    let request: IMapRequest = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: StatementSelectionMode.WITH_RELATIONS\n      }\n    };\n    let result = <IMapResponse>app.run(request);\n    //console.log(toJSON(result.map!, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.map.edges);\n\n    expect(result.map!.nodes.length).to.equal(4);\n    expect(result.map!.edges.length).to.equal(3);\n\n    expect(result.map!.edges[0].relationType).to.equals(RelationType.ATTACK);\n    expect(result.map!.edges[0].from.title).to.equals(\"Statement 6\");\n    expect(result.map!.edges[0].to.title).to.equals(\"Statement 1\");\n\n    expect(result.map!.edges[1].relationType).to.equals(RelationType.SUPPORT);\n    expect(result.map!.edges[1].from.title).to.equals(\"Argument 2\");\n    expect(result.map!.edges[1].to.title).to.equals(\"Statement 6\");\n\n    expect(result.map!.edges[2].relationType).to.equals(RelationType.SUPPORT);\n    expect(result.map!.edges[2].from.title).to.equals(\"Statement 1\");\n    expect(result.map!.edges[2].to.title).to.equals(\"Argument 1\");\n  });\n  it(\"adds arguments a, b and support to map if a's conclusion is b's premise \", function() {\n    let source = `<Argument 1>\n\n(1)[Statement 1]: A\n(2)[Statement 2]: B\n----\n(3)[Statement 3]: C\n\n<Argument 2>\n\n(1)[Statement 3]: A\n(2)[Statement 4]: B\n----\n(3)[Statement 5]: C`;\n    let request = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: \"statement-trees\"\n      }\n    };\n    let result = <IMapResponse>app.run(request);\n    // console.log(JSON.stringify(result.map, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.map.edges);\n\n    expect(result.map!.nodes.length).to.equal(2);\n    expect(result.map!.edges.length).to.equal(1);\n\n    expect(result.map!.edges[0].relationType).to.equals(RelationType.SUPPORT);\n    expect(result.map!.edges[0].from.title).to.equals(\"Argument 1\");\n    expect(result.map!.edges[0].to.title).to.equals(\"Argument 2\");\n  });\n  it(\"selects argument if premises or conclusions are selected as statement nodes\", function() {\n    let source = `<!--Hier wird das Argument nicht richtig gezeichnet.-->\n\n[ZT]: ZT\n\n[T1]: T1\n\n<Argument 1>: Argument 1.\n\n(1) [T1]\n(2) P2\n-- Inference rule --\n(3) [ZT]`;\n    let request: IMapRequest = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: StatementSelectionMode.WITH_TITLE\n      }\n    };\n    let result = <IMapResponse>app.run(request);\n\n    expect(result.map!.nodes.length).to.equal(3);\n    expect(result.map!.edges.length).to.equal(2);\n  });\n  it(\"adds attack edges if statement is contradictory to premise\", function() {\n    let source = `\n[T1]: T1\n\n[T2]: T2\n\n(1) P1\n  >< [T1]\n(2) P2\n----\n(3) C1 \n  >< [T2]`;\n    let request = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: StatementSelectionMode.TOP_LEVEL\n      }\n    };\n    let result = <IMapResponse>app.run(request);\n    expect(result.map!.nodes.length).to.equal(3);\n    expect(result.map!.edges.length).to.equal(2);\n  });\n  it(\"does not add duplicate arrows for contradictions\", function() {\n    let source = `<A>\n\n(1) A\n----\n(2) [T1]: C\n  >< [T2]: B\n\n`;\n    let request = {\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: {\n        statementSelectionMode: StatementSelectionMode.WITH_RELATIONS\n      }\n    };\n    let result = <IMapResponse>app.run(request);\n    //console.log(toJSON(result.map!, null, 2));\n    expect(result.map!.edges.length).to.equal(3);\n    expect(result.map!.nodes.length).to.equal(3);\n  });\n  it(\"can create groups from sections\", function() {\n    let source = `\n# Section 1\n  \n  [A]: text\n    + [B]\n  \n## Section 2\n  \n  [B]: text\n    - <C>\n  \n### Section 3\n  \n  <C>: text\n  \n  `;\n    let result = <IMapResponse>app.run({\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source\n    });\n    //console.log(toJSON(result.map!, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.arguments);\n\n    expect(result.map!.nodes.length).to.equal(2);\n    expect(result.map!.nodes[0].title).to.equal(\"A\");\n    expect(result.map!.nodes[1].title).to.equal(\"Section 2\");\n    expect(result.map!.edges.length).to.equal(2);\n\n    let section2 = <IGroupMapNode>result.map!.nodes[1];\n    expect(section2.children!.length).to.equal(2);\n    expect(section2.children![0].title).to.equal(\"B\");\n\n    let section3 = <IGroupMapNode>section2.children![1];\n    expect(section3.title).to.equal(\"Section 3\");\n    expect(section3.children!.length).to.equal(1);\n    expect(section3.children![0].title).to.equal(\"C\");\n  });\n  it(\"can create groups with only other groups as children\", function() {\n    let source = `\n# Section 1\n\n## Section 2\n\n### Section 3\n\n<A>: text\n      - <B>: text\n  \n  `;\n    let result = <IMapResponse>app.run(<IMapRequest>{\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      map: { statementSelectionMode: StatementSelectionMode.ALL }\n    });\n    //console.log(toJSON(result.map!.nodes, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    //console.log(result.arguments);\n\n    expect(result.map!.nodes.length).to.equal(1);\n    expect(result.map!.nodes[0].title).to.equal(\"Section 2\");\n\n    let section2 = <IGroupMapNode>result.map!.nodes[0];\n    expect(section2.children!.length).to.equal(1);\n    expect(section2.children![0].title).to.equal(\"Section 3\");\n\n    let section3 = <IGroupMapNode>section2.children![0];\n    expect(section3.title).to.equal(\"Section 3\");\n    expect(section3.children!.length).to.equal(2);\n    expect(section3.children![0].title).to.equal(\"A\");\n    expect(section3.children![1].title).to.equal(\"B\");\n  });\n  it(\"can create edges from undercuts\", function() {\n    let source = `\n<A>: text\n    <_ [B]: text\n\n<C>\n\n(1) text\n(2) text\n----\n    <_ [D]: text\n(3) text\n\n<E>\n\n(1) text\n(2) text\n----\n(3) text\n    <_ <Z>\n  `;\n    let result = <IMapResponse>app.run(<IMapRequest>{\n      process: [\"parse-input\", \"build-model\", \"make-map\"],\n      input: source,\n      logLevel: \"error\",\n      map: { statementSelectionMode: StatementSelectionMode.WITH_RELATIONS }\n    });\n    //console.log(toJSON(result.relations!, null, 2));\n    //app.parser.logAst(result.ast);\n    //preprocessor.logRelations(result);\n    const d = result.statements![\"D\"];\n    // for (let relation of d.relations!) {\n    //   console.log(relation.toString());\n    // }\n    // for (let relation of result.relations!) {\n    //   console.log(relation.toString());\n    // }\n    // for (let edge of result.map!.edges) {\n    //   console.log(edge.toString());\n    // }\n    expect(result.map!.edges.length).to.equal(3);\n    // expect(result.map!.nodes[0].title).to.equal(\"Section 2\");\n\n    // let section2 = result.map!.nodes[0];\n    // expect(section2.children!.length).to.equal(1);\n    // expect(section2.children![0].title).to.equal(\"Section 3\");\n\n    // let section3 = section2.children![0];\n    // expect(section3.title).to.equal(\"Section 3\");\n    // expect(section3.children!.length).to.equal(2);\n    // expect(section3.children![0].title).to.equal(\"A\");\n    // expect(section3.children![1].title).to.equal(\"B\");\n  });\n});\n"],"file":"MapPlugin.spec.js"}