{"version":3,"sources":["../src/RuleNames.ts"],"names":["RuleNames"],"mappings":";;;;;;;AAAA;;;;;;IAMYA,S;;;WAAAA,S;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;AAAAA,W;GAAAA,S,yBAAAA,S","sourcesContent":["/**\n * The names of the Argdown syntax rules.\n * The parser plugin returns an abstract syntax tree in [[IArgdownResponse.ast]] in which each node is either an [[IRuleNode]] with one of these names or an [[ITokenNode]].\n * These names can be used to register [[IArgdownPlugin.ruleListeners]]:\n * You can register listeners for each `[RuleName.SOME_RULE + \"Entry\"]` or `[RuleName.SOME_RULE + \"Exit\"]`.\n */\nexport enum RuleNames {\n  ARGDOWN = \"argdown\",\n  HEADING = \"heading\",\n  PCS = \"pcs\",\n  PCS_TAIL = \"pcsTail\",\n  ARGUMENT_STATEMENT = \"argumentStatement\",\n  INFERENCE = \"inference\",\n  INFERENCE_RULES = \"inferenceRules\",\n  ORDERED_LIST = \"orderedList\",\n  UNORDERED_LIST = \"unorderedList\",\n  ORDERED_LIST_ITEM = \"orderedListItem\",\n  UNORDERED_LIST_ITEM = \"unorderedListItem\",\n  ARGUMENT_REFERENCE = \"argumentReference\",\n  ARGUMENT_DEFINITION = \"argumentDefinition\",\n  STATEMENT_REFERENCE = \"statementReference\",\n  STATEMENT = \"statement\",\n  STATEMENT_CONTENT = \"statementContent\",\n  STATEMENT_DEFINITION = \"statementDefinition\",\n  RELATIONS = \"relations\",\n  INCOMING_ATTACK = \"incomingAttack\",\n  INCOMING_SUPPORT = \"incomingSupport\",\n  INCOMING_UNDERCUT = \"incomingUndercut\",\n  CONTRADICTION = \"contradiction\",\n  OUTGOING_ATTACK = \"outgoingAttack\",\n  OUTGOING_SUPPORT = \"outgoingSupport\",\n  OUTGOING_UNDERCUT = \"outgoingUndercut\",\n  BOLD = \"bold\",\n  ITALIC = \"italic\",\n  FREESTYLE_TEXT = \"freestyleText\"\n}\n"],"file":"RuleNames.js"}