{"version":3,"sources":["../src/ArgdownApplication.ts"],"names":["ArgdownApplication","logger","Logger","processors","_","isFunction","log","setLevel","plugin","processorId","processor","plugins","walker","push","tokenListeners","ruleListeners","ArgdownTreeWalker","Object","keys","key","addListener","index","indexOf","removeListener","splice","name","getPlugins","removePlugin","request","response","process","resp","logLevel","isArray","isString","processes","isEmpty","exceptions","cancelProcessor","prepare","e","ast","walk","run","newResponse","isObject","logExceptions","undefined","exception","msg","stack","message","ArgdownPluginError"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;;AAIA;;AACA;;AAKA;;;;;;;;;;;;AARA;;AAqBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA+EaA,kB;;;AAGX;;;;AAIA,8BAAYC,MAAZ,EAAqC;AAAA;;AAAA,wCANe,EAMf;;AAAA,oCALZ,IAAIC,cAAJ,EAKY;;AACnC,SAAKC,UAAL,GAAkB,EAAlB;;AACA,QAAIF,UAAUG,EAAEC,UAAF,CAAaJ,OAAOK,GAApB,CAAV,IAAsCF,EAAEC,UAAF,CAAaJ,OAAOM,QAApB,CAA1C,EAAyE;AACvE,WAAKN,MAAL,GAAcA,MAAd;AACD;AACF;AACD;;;;;;;;;;;8BAOUO,M,EAAwBC,W,EAAsB;AACtD,UAAI,CAACA,WAAL,EAAkB;AAChBA,sBAAc,SAAd;AACD;;AAED,UAAIC,YAAY,KAAKP,UAAL,CAAgBM,WAAhB,CAAhB;;AACA,UAAI,CAACC,SAAL,EAAgB;AACdA,oBAAY;AAAEC,mBAAS,EAAX;AAAeC,kBAAQ;AAAvB,SAAZ;AACA,aAAKT,UAAL,CAAgBM,WAAhB,IAA+BC,SAA/B;AACD;;AAEDA,gBAAUC,OAAV,CAAkBE,IAAlB,CAAuBL,MAAvB;;AACA,UAAIA,OAAOM,cAAP,IAAyBN,OAAOO,aAApC,EAAmD;AACjD,YAAI,CAACL,UAAUE,MAAf,EAAuB;AACrBF,oBAAUE,MAAV,GAAmB,IAAII,oCAAJ,EAAnB;AACD;;AACD,YAAIR,OAAOM,cAAX,EAA2B;AAAA,qBACTG,OAAOC,IAAP,CAAYV,OAAOM,cAAnB,CADS;;AACzB,mDAAoD;AAA/C,gBAAIK,cAAJ;AACHT,sBAAUE,MAAV,CAAiBQ,WAAjB,CAA6BD,GAA7B,EAAkCX,OAAOM,cAAP,CAAsBK,GAAtB,CAAlC;AACD;AACF;;AACD,YAAIX,OAAOO,aAAX,EAA0B;AAAA,sBACRE,OAAOC,IAAP,CAAYV,OAAOO,aAAnB,CADQ;;AACxB,uDAAmD;AAA9C,gBAAII,iBAAJ;AACHT,sBAAUE,MAAV,CAAiBQ,WAAjB,CAA6BD,IAA7B,EAAkCX,OAAOO,aAAP,CAAqBI,IAArB,CAAlC;AACD;AACF;AACF;AACF;AACD;;;;;;;;;iCAMaX,M,EAAwBC,W,EAAqB;AACxD,UAAI,CAACA,WAAL,EAAkB;AAChBA,sBAAc,SAAd;AACD;;AAED,UAAIC,YAAY,KAAKP,UAAL,CAAgBM,WAAhB,CAAhB;;AACA,UAAI,CAACC,SAAL,EAAgB;AACd;AACD;;AAED,UAAIW,QAAQX,UAAUC,OAAV,CAAkBW,OAAlB,CAA0Bd,MAA1B,CAAZ;;AACA,UAAIa,QAAQ,CAAC,CAAb,EAAgB;AACd,YAAIb,OAAOM,cAAP,IAAyBJ,UAAUE,MAAvC,EAA+C;AAAA,sBAC7BK,OAAOC,IAAP,CAAYV,OAAOM,cAAnB,CAD6B;;AAC7C,uDAAoD;AAA/C,gBAAIK,gBAAJ;AACHT,sBAAUE,MAAV,CAAiBW,cAAjB,CAAgCJ,GAAhC,EAAqCX,OAAOM,cAAP,CAAsBK,GAAtB,CAArC;AACD;AACF;;AACD,YAAIX,OAAOO,aAAP,IAAwBL,UAAUE,MAAtC,EAA8C;AAAA,sBAC5BK,OAAOC,IAAP,CAAYV,OAAOO,aAAnB,CAD4B;;AAC5C,uDAAmD;AAA9C,gBAAII,kBAAJ;AACHT,sBAAUE,MAAV,CAAiBW,cAAjB,CAAgCJ,KAAhC,EAAqCX,OAAOO,aAAP,CAAqBI,KAArB,CAArC;AACD;AACF;;AACDT,kBAAUC,OAAV,CAAkBa,MAAlB,CAAyBH,KAAzB,EAAgC,CAAhC;AACD;AACF;AACD;;;;;;;;;+BAMWZ,W,EAA8C;AACvD,UAAI,CAACA,WAAL,EAAkB;AAChBA,sBAAc,SAAd;AACD;;AACD,UAAIC,YAAY,KAAKP,UAAL,CAAgBM,WAAhB,CAAhB;AACA,UAAIC,SAAJ,EAAe,OAAOA,UAAUC,OAAjB,CAAf,KACK;AACH,eAAO,IAAP;AACD;AACF;AACD;;;;;;;;8BAKUc,I,EAAchB,W,EAA4C;AAClE,UAAIE,UAAU,KAAKe,UAAL,CAAgBjB,WAAhB,CAAd;;AACA,UAAIE,OAAJ,EAAa;AAAA;AAAA;AAAA;;AAAA;AACX,+BAAmBA,OAAnB,8HAA4B;AAAA,gBAAnBH,MAAmB;;AAC1B,gBAAIA,OAAOiB,IAAP,IAAeA,IAAnB,EAAyB;AACvB,qBAAOjB,MAAP;AACD;AACF;AALU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMZ;;AACD,aAAO,IAAP;AACD;AACD;;;;;;;oCAIgBC,W,EAA2B;AACzC,UAAIC,YAAY,KAAKP,UAAL,CAAgBM,WAAhB,CAAhB;;AACA,UAAI,CAACC,SAAL,EAAgB;AACd;AACD;;AAJwC;AAAA;AAAA;;AAAA;AAKzC,8BAAmBA,UAAUC,OAA7B,mIAAsC;AAAA,cAA7BH,MAA6B;AACpC,eAAKmB,YAAL,CAAkBnB,MAAlB,EAA0BC,WAA1B;AACD;AAPwC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQzC,aAAO,KAAKN,UAAL,CAAgBM,WAAhB,CAAP;AACD;AACD;;;;;;;;;;wBAOImB,O,EAA0BC,Q,EAA+C;AAC3E,UAAIC,UAAoB,EAAxB;AACA,WAAK7B,MAAL,CAAYM,QAAZ,CAAqB,OAArB;AACA,UAAIwB,OAAyBF,YAA8B,EAA3D;;AAEA,UAAID,OAAJ,EAAa;AACX,YAAIA,QAAQI,QAAZ,EAAsB;AACpB,eAAK/B,MAAL,CAAYM,QAAZ,CAAqBqB,QAAQI,QAA7B;AACD;;AACD,YAAIJ,QAAQE,OAAZ,EAAqB;AACnB,cAAI1B,EAAE6B,OAAF,CAAUL,QAAQE,OAAlB,CAAJ,EAAgC;AAC9BA,sBAAUF,QAAQE,OAAlB;AACD,WAFD,MAEO,IAAI1B,EAAE8B,QAAF,CAAWN,QAAQE,OAAnB,KAA+BF,QAAQO,SAA3C,EAAsD;AAC3DL,sBAAUF,QAAQO,SAAR,CAAkBP,QAAQE,OAA1B,CAAV;AACD;AACF;AACF;;AAED,UAAI1B,EAAEgC,OAAF,CAAUN,OAAV,CAAJ,EAAwB;AACtB,aAAK7B,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,EAA2B,6CAA3B;AACA,eAAOyB,IAAP;AACD;;AACD,UAAMM,aAAsB,EAA5B;AACAN,WAAKM,UAAL,GAAkBA,UAAlB;AAvB2E;AAAA;AAAA;;AAAA;AAyB3E,8BAAwBP,OAAxB,mIAAiC;AAAA,cAAxBrB,WAAwB;AAC/B,cAAI6B,kBAAkB,KAAtB;AACA,cAAI5B,YAAY,KAAKP,UAAL,CAAgBM,WAAhB,CAAhB;;AACA,cAAI,CAACC,SAAL,EAAgB;AACd,iBAAKT,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,EAA2B,gDAAgDG,WAA3E;AACA;AACD;;AACD,eAAKR,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,EAA2B,8CAA8CG,WAAzE;AAP+B;AAAA;AAAA;;AAAA;AAS/B,kCAAmBC,UAAUC,OAA7B,mIAAsC;AAAA,kBAA7BH,MAA6B;AACpC,mBAAKP,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,EAA2B,6CAA6CE,OAAOiB,IAA/E;;AACA,kBAAIrB,EAAEC,UAAF,CAAaG,OAAO+B,OAApB,CAAJ,EAAkC;AAChC,oBAAI;AACF/B,yBAAO+B,OAAP,CAAeX,OAAf,EAAwBG,IAAxB,EAA8B,KAAK9B,MAAnC;AACD,iBAFD,CAEE,OAAOuC,CAAP,EAAU;AACVA,oBAAE9B,SAAF,GAAcD,WAAd;AACA4B,6BAAWxB,IAAX,CAAgB2B,CAAhB;AACAF,oCAAkB,IAAlB;AACA,uBAAKrC,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,sBAAwCG,WAAxC;AACA;AACD;AACF;AACF;AAtB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAuB/B,cAAI6B,eAAJ,EAAqB;AACnB;AACD,WAzB8B,CA2B/B;AACA;;;AACA,cAAIP,KAAKU,GAAL,IAAY/B,UAAUE,MAA1B,EAAkC;AAChC,gBAAI;AACFF,wBAAUE,MAAV,CAAiB8B,IAAjB,CAAsBd,OAAtB,EAA+BG,IAA/B,EAAqC,KAAK9B,MAA1C;AACD,aAFD,CAEE,OAAOuC,CAAP,EAAU;AACVA,gBAAE9B,SAAF,GAAcD,WAAd;AACA4B,yBAAWxB,IAAX,CAAgB2B,CAAhB;AACA,mBAAKvC,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,sBAAwCG,WAAxC;AACA;AACD;AACF;;AAtC8B;AAAA;AAAA;;AAAA;AAwC/B,kCAAmBC,UAAUC,OAA7B,mIAAsC;AAAA,kBAA7BH,OAA6B;AACpC,mBAAKP,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,EAA2B,2CAA2CE,QAAOiB,IAA7E;;AACA,kBAAIrB,EAAEC,UAAF,CAAaG,QAAOmC,GAApB,CAAJ,EAA8B;AAC5B,oBAAI;AACF,sBAAIC,cAAcpC,QAAOmC,GAAP,CAAWf,OAAX,EAAoBG,IAApB,EAA0B,KAAK9B,MAA/B,CAAlB;;AACA,sBAAIG,EAAEyC,QAAF,CAAWD,WAAX,CAAJ,EAA6B;AAC3Bb,2BAAOa,WAAP;AACD;AACF,iBALD,CAKE,OAAOJ,CAAP,EAAU;AACVA,oBAAE9B,SAAF,GAAcD,WAAd;AACA,uBAAKR,MAAL,CAAYK,GAAZ,CAAgB,SAAhB,sBAAwCG,WAAxC;AACA4B,6BAAWxB,IAAX,CAAgB2B,CAAhB;AACA;AACD;AACF;AACF;AAvD8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwDhC;AAjF0E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAkF3E,UAAIZ,QAAQkB,aAAR,KAA0BC,SAA1B,IAAuCnB,QAAQkB,aAAnD,EAAkE;AAChE,gCAAsBT,UAAtB,gBAAkC;AAA7B,cAAIW,YAAaX,UAAb,KAAJ;AACH,cAAIY,MAAMD,UAAUE,KAAV,IAAmBF,UAAUG,OAAvC;;AACA,cAAIH,qBAAqBI,sCAAzB,EAA6C;AAC3CH,6BAAUD,UAAUtC,SAApB,cAAiCsC,UAAUxC,MAA3C,gBAAuDyC,GAAvD;AACD;;AACD,eAAKhD,MAAL,CAAYK,GAAZ,CAAgB,OAAhB,EAAyB2C,GAAzB;AACD;AACF;;AACD,aAAOlB,IAAP;AACD","sourcesContent":["import { ArgdownPluginError } from \"./ArgdownPluginError\";\n\n\"use strict\";\n\nimport { ArgdownTreeWalker } from \"./ArgdownTreeWalker\";\nimport * as _ from \"lodash\";\nimport { IArgdownLogger } from \"./IArgdownLogger\";\nimport { IArgdownPlugin } from \"./IArgdownPlugin\";\nimport { IArgdownRequest } from \"./IArgdownRequest\";\nimport { IArgdownResponse } from \"./IArgdownResponse\";\nimport { Logger } from \"./Logger\";\n\n/**\n * A processor is a \"working step\" in a process, containing a group of plugins\n */\nexport interface IArgdownProcessor {\n  plugins: IArgdownPlugin[];\n  /**\n   * The tree walker will only be added if any plugins of this processor define tokenListeners or ruleListeners.\n   */\n  walker: ArgdownTreeWalker | null;\n}\n\n/**\n * An ArgdownApplication chains together a collection of plugins, passing a request and response object between them.\n * Each plugin uses configuration settings from the provided request object to produce or transform data saved in the provided response object.\n * Without any plugins the ArgdownApplication will do nothing. Even the parsing and lexing of Argdown input is accomplished by the [[ParserPlugin]].\n *\n * Plugins are grouped into processors that will be executed after one another each time the [[run]] method is called.\n * Which processors are executed in a run is determined by the request.process list.\n *\n * For each processor ArgdownApplication will try to execute plugin methods in the following order:\n *\n *  - any [[IArgdownPlugin.prepare]] methods: these methods can be used to add plugin default settings to the request\n *    and to check that all required data is present in the response object.\n *  - any event listeners defined in [[IArgdownPlugin.tokenListeners]] and [[IArgdownPlugin.ruleListeners]]. If any plugin in a processor\n *    defines such listeners, an ArgdownTreeWalker will be added to this processor which will visit all nodes in the abstract syntax tree (response.ast).\n *  - any [[IArgdownPlugin.run]] methods: these methods should be used to transform response data not contained within response.ast.\n *\n * All plugin methods called by ArgdownApplication receive a request, response and logger object as parameters.\n * In each of the three rounds the plugins are called in the order they were added to the processor.\n *\n * Most runs will first have to call the ParserPlugin, MetaDataPlugin, ModelPlugin and TagPlugin to add\n * the basic Argdown data to the response object. This includes:\n *\n *  - the AST\n *  - metaData contained in the front matter\n *  - statements and arguments dictionaries\n *  - the relations list\n *  - tag list and tagDictionary\n *  - the sections tree\n *  - metaData of arguments, statements and headings\n *\n * Plugins are expected at the beginning of their prepare method to check for any missing required data in the response object.\n * If required properties are missing, the plugin should throw an [[ArgdownPluginError]].\n * Throwing an error in any of the plugin methods called by ArgdownApplication\n * will cancel the run of the current processor and skip to the next processor.\n * All errors  will be caught, collected and optionally logged by the ArgdownApplication.\n *\n * Plugins should not keep any local mutable state. Instead they should use the request object for configuration\n * and the response object for returning produced or transformed data. The only obvious exceptions are I/O plugins,\n * for example export plugins that save the exported data as new files.\n *\n * The `@argdown/cli` package provides a subclass called `AsyncArgdownApplication` which adds a `AsyncArgdownApplication.runAsync` method to this class.\n * This can be used to support Promises and async/await in I/O operations.\n * The app.runAsync method works exactly like the app.run method\n * except that it tries to call `await plugin.runAsyc(...);` before calling any `plugin.run(...);` methods.\n *\n * @example\n * ```typescript\n *\n * import {ArgdownApplication, IArgdownRequest, IHtmlResponse, ParserPlugin, ModelPlugin, TagPlugin, HtmlExportPlugin} from \"@argdown/parser\";\n *\n * const app = new ArgdownApplication();\n *\n * const parserPlugin = new ParserPlugin();\n * app.addPlugin(parserPlugin, \"parse-input\");\n *\n * const modelPlugin = new ModelPlugin();\n * app.addPlugin(modelPlugin, \"build-model\");\n *\n * const tagPlugin = new TagPlugin();\n * app.addPlugin(tagPlugin, \"build-model\");\n *\n * const htmlExportPlugin = new HtmlExportPlugin();\n * app.addPlugin(htmlExportPlugin, \"export-html\");\n *\n * const input = `\n * # My first Argdown document\n *\n * [S1]: a statement\n *    - [A1]: an argument\n * `;\n * const request:IArgdownRequest = {\n *  input,\n *  process: [\"parse-input\", \"build-model\", \"export-html\"],\n *  logLevel: \"verbose\"\n * }\n * const response:IHtmlResponse = app.run(request);\n * console.log(response.html);\n * ```\n */\nexport class ArgdownApplication {\n  processors: { [name: string]: IArgdownProcessor } = {};\n  logger: IArgdownLogger = new Logger();\n  /**\n   *\n   * @param logger optional parameter to provide a logger different from the default one\n   */\n  constructor(logger?: IArgdownLogger) {\n    this.processors = {};\n    if (logger && _.isFunction(logger.log) && _.isFunction(logger.setLevel)) {\n      this.logger = logger;\n    }\n  }\n  /**\n   * Adds a plugin to the application.\n   * Registers any tokenListeners or ruleListeners with the ArgdownTreeWalker event emitter.\n   *\n   * @param plugin\n   * @param processorId if processorId is undefined, the plugin will be added to the \"default\" processor\n   */\n  addPlugin(plugin: IArgdownPlugin, processorId?: string) {\n    if (!processorId) {\n      processorId = \"default\";\n    }\n\n    let processor = this.processors[processorId];\n    if (!processor) {\n      processor = { plugins: [], walker: null };\n      this.processors[processorId] = processor;\n    }\n\n    processor.plugins.push(plugin);\n    if (plugin.tokenListeners || plugin.ruleListeners) {\n      if (!processor.walker) {\n        processor.walker = new ArgdownTreeWalker();\n      }\n      if (plugin.tokenListeners) {\n        for (let key of Object.keys(plugin.tokenListeners)) {\n          processor.walker.addListener(key, plugin.tokenListeners[key]);\n        }\n      }\n      if (plugin.ruleListeners) {\n        for (let key of Object.keys(plugin.ruleListeners)) {\n          processor.walker.addListener(key, plugin.ruleListeners[key]);\n        }\n      }\n    }\n  }\n  /**\n   * Removes a plugin from the application.\n   * Removes all tokenListeners and ruleListeners from the ArgdownTreeWalker event emitter.\n   * @param plugin\n   * @param processorId\n   */\n  removePlugin(plugin: IArgdownPlugin, processorId: string) {\n    if (!processorId) {\n      processorId = \"default\";\n    }\n\n    let processor = this.processors[processorId];\n    if (!processor) {\n      return;\n    }\n\n    let index = processor.plugins.indexOf(plugin);\n    if (index > -1) {\n      if (plugin.tokenListeners && processor.walker) {\n        for (let key of Object.keys(plugin.tokenListeners)) {\n          processor.walker.removeListener(key, plugin.tokenListeners[key]);\n        }\n      }\n      if (plugin.ruleListeners && processor.walker) {\n        for (let key of Object.keys(plugin.ruleListeners)) {\n          processor.walker.removeListener(key, plugin.ruleListeners[key]);\n        }\n      }\n      processor.plugins.splice(index, 1);\n    }\n  }\n  /**\n   * Get the plugin list of a processor.\n   * Careful, this is not a copy!\n   *\n   * @param processorId\n   */\n  getPlugins(processorId: string): IArgdownPlugin[] | null {\n    if (!processorId) {\n      processorId = \"default\";\n    }\n    let processor = this.processors[processorId];\n    if (processor) return processor.plugins;\n    else {\n      return null;\n    }\n  }\n  /**\n   * Get a plugin that is already part of a processor\n   * @param name\n   * @param processorId\n   */\n  getPlugin(name: string, processorId: string): IArgdownPlugin | null {\n    let plugins = this.getPlugins(processorId);\n    if (plugins) {\n      for (let plugin of plugins) {\n        if (plugin.name == name) {\n          return plugin;\n        }\n      }\n    }\n    return null;\n  }\n  /**\n   * Remove a processor and all its plugins from an application.\n   * @param processorId\n   */\n  removeProcessor(processorId: string): void {\n    let processor = this.processors[processorId];\n    if (!processor) {\n      return;\n    }\n    for (let plugin of processor.plugins) {\n      this.removePlugin(plugin, processorId);\n    }\n    delete this.processors[processorId];\n  }\n  /**\n   * Execute a chain of processors\n   * @param request Use request.process to define the list of processors to run. Use request.input to add ArgdownSourceCode to be processed.\n   * @param response Can be optionally used to start with a response from a previous run.\n   * Use this if you want to avoid to run processors again that have already done their work.\n   * @returns the transformed response object after all plugins have added their data.\n   */\n  run(request: IArgdownRequest, response?: IArgdownResponse): IArgdownResponse {\n    let process: string[] = [];\n    this.logger.setLevel(\"error\");\n    let resp: IArgdownResponse = response || <IArgdownResponse>{};\n\n    if (request) {\n      if (request.logLevel) {\n        this.logger.setLevel(request.logLevel);\n      }\n      if (request.process) {\n        if (_.isArray(request.process)) {\n          process = request.process;\n        } else if (_.isString(request.process) && request.processes) {\n          process = request.processes[request.process];\n        }\n      }\n    }\n\n    if (_.isEmpty(process)) {\n      this.logger.log(\"verbose\", \"[ArgdownApplication]: No processors to run.\");\n      return resp;\n    }\n    const exceptions: Error[] = [];\n    resp.exceptions = exceptions;\n\n    for (let processorId of process) {\n      let cancelProcessor = false;\n      let processor = this.processors[processorId];\n      if (!processor) {\n        this.logger.log(\"verbose\", \"[ArgdownApplication]: Processor not found: \" + processorId);\n        continue;\n      }\n      this.logger.log(\"verbose\", \"[ArgdownApplication]: Running processor: \" + processorId);\n\n      for (let plugin of processor.plugins) {\n        this.logger.log(\"verbose\", \"[ArgdownApplication]: Preparing plugin: \" + plugin.name);\n        if (_.isFunction(plugin.prepare)) {\n          try {\n            plugin.prepare(request, resp, this.logger);\n          } catch (e) {\n            e.processor = processorId;\n            exceptions.push(e);\n            cancelProcessor = true;\n            this.logger.log(\"warning\", `Processor ${processorId} canceled.`);\n            break;\n          }\n        }\n      }\n      if (cancelProcessor) {\n        break;\n      }\n\n      // The tree walk is canceled if any plugin in this processor has thrown an error\n      // This is not ideal, but it is better than to remove all listeners of the plugin and then add them back in\n      if (resp.ast && processor.walker) {\n        try {\n          processor.walker.walk(request, resp, this.logger);\n        } catch (e) {\n          e.processor = processorId;\n          exceptions.push(e);\n          this.logger.log(\"warning\", `Processor ${processorId} canceled.`);\n          break;\n        }\n      }\n\n      for (let plugin of processor.plugins) {\n        this.logger.log(\"verbose\", \"[ArgdownApplication]: Running plugin: \" + plugin.name);\n        if (_.isFunction(plugin.run)) {\n          try {\n            let newResponse = plugin.run(request, resp, this.logger);\n            if (_.isObject(newResponse)) {\n              resp = newResponse;\n            }\n          } catch (e) {\n            e.processor = processorId;\n            this.logger.log(\"warning\", `Processor ${processorId} canceled.`);\n            exceptions.push(e);\n            break;\n          }\n        }\n      }\n    }\n    if (request.logExceptions === undefined || request.logExceptions) {\n      for (let exception of exceptions) {\n        let msg = exception.stack || exception.message;\n        if (exception instanceof ArgdownPluginError) {\n          msg = `[${exception.processor}/${exception.plugin}]: ${msg}`;\n        }\n        this.logger.log(\"error\", msg);\n      }\n    }\n    return resp;\n  }\n}\n"],"file":"ArgdownApplication.js"}